
        const workerBlob = URL.createObjectURL(new Blob([atob('IWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NvbnN0IGU9IXNlbGYuZG9jdW1lbnQmJnNlbGYuV29ya2VyR2xvYmFsU2NvcGU7Y29uc3QgdD1mdW5jdGlvbigpe2NvbnN0IGU9W10uY29uc3RydWN0b3I7dHJ5eygtMSkudG9GaXhlZCgtMSl9Y2F0Y2godCl7cmV0dXJuIHQubWVzc2FnZS5sZW5ndGgrKGUrIiIpLnNwbGl0KGUubmFtZSkuam9pbigiIikubGVuZ3RofX0oKSxuPTgwPT10LGE9NTg9PXQsbz03Nz09dCxyPXs4MDoiVjgiLDU4OiJTcGlkZXJNb25rZXkiLDc3OiJKYXZhU2NyaXB0Q29yZSJ9W3RdfHxudWxsLGk9biYmImZsYXQiaW4gQXJyYXkucHJvdG90eXBlJiYhKCJSZXBvcnRpbmdPYnNlcnZlciJpbiBzZWxmKTtmdW5jdGlvbiBzKCl7cmV0dXJuImJyYXZlImluIG5hdmlnYXRvciYmIkJyYXZlIj09T2JqZWN0LmdldFByb3RvdHlwZU9mKG5hdmlnYXRvci5icmF2ZSkuY29uc3RydWN0b3IubmFtZSYmImZ1bmN0aW9uIGlzQnJhdmUoKSB7IFtuYXRpdmUgY29kZV0gfSI9PW5hdmlnYXRvci5icmF2ZS5pc0JyYXZlLnRvU3RyaW5nKCl9ZnVuY3Rpb24gYygpe2NvbnN0IGU9e3Vua25vd246ITEsYWxsb3c6ITEsc3RhbmRhcmQ6ITEsc3RyaWN0OiExfTt0cnl7aWYoKCgpPT57dHJ5e3dpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0PU9mZmxpbmVBdWRpb0NvbnRleHR8fHdlYmtpdE9mZmxpbmVBdWRpb0NvbnRleHR9Y2F0Y2goZSl7fWlmKCF3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dClyZXR1cm4hMTtjb25zdCBlPW5ldyBPZmZsaW5lQXVkaW9Db250ZXh0KDEsMSw0NDEwMCkuY3JlYXRlQW5hbHlzZXIoKSx0PW5ldyBGbG9hdDMyQXJyYXkoZS5mcmVxdWVuY3lCaW5Db3VudCk7ZS5nZXRGbG9hdEZyZXF1ZW5jeURhdGEodCk7cmV0dXJuIG5ldyBTZXQodCkuc2l6ZT4xfSkoKSlyZXR1cm4gZS5zdHJpY3Q9ITAsZTtjb25zdCB0PS8oQ2hyb20oZXxpdW0pfE1pY3Jvc29mdCBFZGdlKSBQREYgKFBsdWdpbnxWaWV3ZXIpLyxuPVsuLi5uYXZpZ2F0b3IucGx1Z2luc10sYT0yPT1uLmZpbHRlcigoZT0+dC50ZXN0KGUubmFtZSkpKS5sZW5ndGg7cmV0dXJuIG4ubGVuZ3RoJiYhYT8oZS5zdGFuZGFyZD0hMCxlKTooZS5hbGxvdz0hMCxlKX1jYXRjaCh0KXtyZXR1cm4gZS51bmtub3duPSEwLGV9fWNvbnN0IGw9ZT0+e2NvbnN0IHQ9bmV3IFNldChbIkZSQUdNRU5UX1NIQURFUi5ISUdIX0ZMT0FULnByZWNpc2lvbiIsIkZSQUdNRU5UX1NIQURFUi5ISUdIX0ZMT0FULnJhbmdlTWF4IiwiRlJBR01FTlRfU0hBREVSLkhJR0hfRkxPQVQucmFuZ2VNaW4iLCJGUkFHTUVOVF9TSEFERVIuSElHSF9JTlQucHJlY2lzaW9uIiwiRlJBR01FTlRfU0hBREVSLkhJR0hfSU5ULnJhbmdlTWF4IiwiRlJBR01FTlRfU0hBREVSLkhJR0hfSU5ULnJhbmdlTWluIiwiRlJBR01FTlRfU0hBREVSLkxPV19GTE9BVC5wcmVjaXNpb24iLCJGUkFHTUVOVF9TSEFERVIuTE9XX0ZMT0FULnJhbmdlTWF4IiwiRlJBR01FTlRfU0hBREVSLkxPV19GTE9BVC5yYW5nZU1pbiIsIkZSQUdNRU5UX1NIQURFUi5NRURJVU1fRkxPQVQucHJlY2lzaW9uIiwiRlJBR01FTlRfU0hBREVSLk1FRElVTV9GTE9BVC5yYW5nZU1heCIsIkZSQUdNRU5UX1NIQURFUi5NRURJVU1fRkxPQVQucmFuZ2VNaW4iLCJNQVhfQ09NQklORURfRlJBR01FTlRfVU5JRk9STV9DT01QT05FTlRTIiwiTUFYX0NPTUJJTkVEX1VOSUZPUk1fQkxPQ0tTIiwiTUFYX0NPTUJJTkVEX1ZFUlRFWF9VTklGT1JNX0NPTVBPTkVOVFMiLCJNQVhfRFJBV19CVUZGRVJTX1dFQkdMIiwiTUFYX0ZSQUdNRU5UX0lOUFVUX0NPTVBPTkVOVFMiLCJNQVhfRlJBR01FTlRfVU5JRk9STV9CTE9DS1MiLCJNQVhfRlJBR01FTlRfVU5JRk9STV9DT01QT05FTlRTIiwiTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUIiwiTUFYX1RSQU5TRk9STV9GRUVEQkFDS19JTlRFUkxFQVZFRF9DT01QT05FTlRTIiwiTUFYX1VOSUZPUk1fQlVGRkVSX0JJTkRJTkdTIiwiTUFYX1ZBUllJTkdfQ09NUE9ORU5UUyIsIk1BWF9WRVJURVhfT1VUUFVUX0NPTVBPTkVOVFMiLCJNQVhfVkVSVEVYX1VOSUZPUk1fQkxPQ0tTIiwiTUFYX1ZFUlRFWF9VTklGT1JNX0NPTVBPTkVOVFMiLCJTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04iLCJVTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCIsIlVOTUFTS0VEX1ZFTkRPUl9XRUJHTCIsIlZFUlNJT04iLCJWRVJURVhfU0hBREVSLkhJR0hfRkxPQVQucHJlY2lzaW9uIiwiVkVSVEVYX1NIQURFUi5ISUdIX0ZMT0FULnJhbmdlTWF4IiwiVkVSVEVYX1NIQURFUi5ISUdIX0ZMT0FULnJhbmdlTWluIiwiVkVSVEVYX1NIQURFUi5ISUdIX0lOVC5wcmVjaXNpb24iLCJWRVJURVhfU0hBREVSLkhJR0hfSU5ULnJhbmdlTWF4IiwiVkVSVEVYX1NIQURFUi5ISUdIX0lOVC5yYW5nZU1pbiIsIlZFUlRFWF9TSEFERVIuTE9XX0ZMT0FULnByZWNpc2lvbiIsIlZFUlRFWF9TSEFERVIuTE9XX0ZMT0FULnJhbmdlTWF4IiwiVkVSVEVYX1NIQURFUi5MT1dfRkxPQVQucmFuZ2VNaW4iLCJWRVJURVhfU0hBREVSLk1FRElVTV9GTE9BVC5wcmVjaXNpb24iLCJWRVJURVhfU0hBREVSLk1FRElVTV9GTE9BVC5yYW5nZU1heCIsIlZFUlRFWF9TSEFERVIuTUVESVVNX0ZMT0FULnJhbmdlTWluIl0pO3JldHVybiBPYmplY3Qua2V5cyhlKS5yZWR1Y2UoKChuLGEpPT4odC5oYXMoYSl8fChuW2FdPWVbYV0pLG4pKSx7fSl9LGQ9ZT0+L3dpbmRvd3MgcGhvbmUvZ2kudGVzdChlKT8iV2luZG93cyBQaG9uZSI6L3dpbihkb3dzfDE2fDMyfDY0fDk1fDk4fG50KXx3b3c2NC9naS50ZXN0KGUpPyJXaW5kb3dzIjovYW5kcm9pZC9naS50ZXN0KGUpPyJBbmRyb2lkIjovY3Jvcy9naS50ZXN0KGUpPyJDaHJvbWUgT1MiOi9saW51eC9naS50ZXN0KGUpPyJMaW51eCI6L2lwYWQvZ2kudGVzdChlKT8iaVBhZCI6L2lwaG9uZS9naS50ZXN0KGUpPyJpUGhvbmUiOi9pcG9kL2dpLnRlc3QoZSk/ImlQb2QiOi9pb3MvZ2kudGVzdChlKT8iaU9TIjovbWFjL2dpLnRlc3QoZSk/Ik1hYyI6Ik90aGVyIjtmdW5jdGlvbiBtKGUsdCl7Y29uc3Qgbj0vd2luKGRvd3N8MTZ8MzJ8NjR8OTV8OTh8bnQpfHdvdzY0L2dpLnRlc3QoZSk/IldpbmRvd3MiOi9hbmRyb2lkfGxpbnV4fGNyb3MvZ2kudGVzdChlKT8iTGludXgiOi8oaShvc3xwKGFkfGhvbmV8b2QpKSl8bWFjL2dpLnRlc3QoZSk/IkFwcGxlIjoiT3RoZXIiO2lmKCF0KXJldHVybltuXTtyZXR1cm5bbiwvd2luL2dpLnRlc3QodCk/IldpbmRvd3MiOi9hbmRyb2lkfGFybXxsaW51eC9naS50ZXN0KHQpPyJMaW51eCI6LyhpKG9zfHAoYWR8aG9uZXxvZCkpKXxtYWMvZ2kudGVzdCh0KT8iQXBwbGUiOiJPdGhlciJdfWNvbnN0e3VzZXJBZ2VudDp1LHBsYXRmb3JtOmd9PXNlbGYubmF2aWdhdG9yfHx7fSxbcCxoXT1tKHUsZyksYj0oe3VhOmUsb3M6dCxpc0JyYXZlOm59KT0+e2NvbnN0IGE9L2lwYWR8aXBob25lfGlwb2R8aW9zfG1hYy9naS50ZXN0KHQpLG89L09QUlwvL2cudGVzdChlKSxyPS9WaXZhbGRpL2cudGVzdChlKSxpPS9EdWNrRHVja0dvL2cudGVzdChlKSxzPS9ZYUJyb3dzZXIvZy50ZXN0KGUpLGM9ZS5tYXRjaCgvKHBhbGVtb29uKVwvKFxkKykuL2kpLGw9ZS5tYXRjaCgvKGVkZ2lvc3xlZGd8ZWRnZXxlZGdhKVwvKFxkKykuL2kpLGQ9bCYmL2VkZ2lvcy9pLnRlc3QobFsxXSksbT1lLm1hdGNoKC8oY3Jpb3N8Y2hyb21lKVwvKFxkKykuL2kpLHU9ZS5tYXRjaCgvKGZ4aW9zfGZpcmVmb3gpXC8oXGQrKS4vaSksZz0vQXBwbGVXZWJLaXQvZy50ZXN0KGUpJiYvU2FmYXJpL2cudGVzdChlKSYmIXUmJiFtJiYhbCYmZS5tYXRjaCgvKHZlcnNpb24pXC8oXGQrKVwuKFxkfFwuKStccyhtb2JpbGV8c2FmYXJpKS9pKTtpZihtKXtyZXR1cm5gJHttWzFdfSAke21bMl19JHtvPyIgT3BlcmEiOnI/IiBWaXZhbGRpIjppPyIgRHVja0R1Y2tHbyI6cz8iIFlhbmRleCI6bD8iIEVkZ2UiOm4/IiBCcmF2ZSI6IiJ9YH1pZihkKXtyZXR1cm5gJHtsWzFdfSAke2xbMl19YH1pZih1KXtyZXR1cm5gJHtjP2NbMV06dVsxXX0gJHtjP2NbMl06dVsyXX1gfWlmKGEmJmcpe3JldHVybmAkeyJTYWZhcmkifSAke2dbMl19YH1yZXR1cm4idW5rbm93biJ9LGY9KHt1c2VyQWdlbnQ6ZSxleGNsdWRlQnVpbGQ6dD0hMH0pPT57aWYoIWUpcmV0dXJuInVua25vd24iO2NvbnN0IG49L1woKC4rKVwpLyxhPS8oKGFuZHJvaWQpLispL2ksbz0vXihsaW51eHxbYS16XXx3dnxtb2JpbGV8W2Etel17Mn0oLXxfKVthLXpdezJ9fFthLXpdezJ9KSR8d2luZG93c3wocnY6fHRyaWRlbnR8d2Vidmlld3xpZW1vYmlsZSkuKy9pLHI9L2J1aWxkXC8uK1xzfFxzYnVpbGRcLy4rL2ksaT0vYW5kcm9pZCggfC0pXGQrL2kscz0vKCh3aW5kb3dzKS4rKS9pLGM9L14od2luZG93c3xtcygtfClvZmZpY2V8bWljcm9zb2Z0fGNvbXBhdGlibGV8W2Etel18eDY0fFthLXpdezJ9KC18XylbYS16XXsyfXxbYS16XXsyfSkkfChydjp8b3V0bG9va3xtcygtfClvZmZpY2V8bWljcm9zb2Z0fHRyaWRlbnR8XC5uZXR8bXNpZXxodHRyYWNrfG1lZGlhIGNlbnRlcnxpbmZvcGF0aHxhb2x8b3BlcmF8aWVtb2JpbGV8d2ViYnJvd3NlcikuKy9pLGw9L3cob3d8aW4pNjQvaSxkPS9jcm9zL2ksbT0vXihbYS16XXx4MTF8W2Etel17Mn0oLXxfKVthLXpdezJ9fFthLXpdezJ9KSR8KHJ2Onx0cmlkZW50KS4rL2ksdT0vXGQrXC5cZCtcLlxkKy9pLGc9L2xpbnV4fHgxMXx1YnVudHV8ZGViaWFuL2kscD0vXihbYS16XXx4MTF8dW5rbm93bnxjb21wYXRpYmxlfFthLXpdezJ9KC18XylbYS16XXsyfXxbYS16XXsyfSkkfChydjp8amF2YXxvcmFjbGV8XCtodHRwfGh0dHB8dW5rbm93bnxtb3ppbGxhfGtvbnF1ZXJvcnx2YWx2ZSkuKy9pLGg9LyhjcHUgaXBob25lfGNwdSBvc3xpcGhvbmUgb3N8bWFjIG9zfG1hY29zfGludGVsIG9zfHBwYyBtYWMpLisvaSxiPS9eKFthLXpdfG1hY2ludG9zaHxjb21wYXRpYmxlfG1pbWljfFthLXpdezJ9KC18XylbYS16XXsyfXxbYS16XXsyfXxydnxcZCtcLlxkKykkfChydjp8c2lsa3x2YWx2ZSkuKy9pLGY9LyhwcGMgfGludGVsIHwpKG1hY3xtYWMgfClvcyAoeCB8eHwpKFxkezJ9KF98XC4pXGR7MSwyfXxcZHsyLH0pL2ksUz0vKChzeW1iaWFub3N8bm9raWF8YmxhY2tiZXJyeXxtb3JwaG9zfG1hYykuKyl8XC9saW51eHxmcmVlYnNkfHN5bWJvc3xzZXJpZXMgXGQrfHdpblxkK3x1bml4fGhwLXV4fGJzZGl8YnNkfHg4Nl82NC9pLHk9KGUsdCk9PmUuZmlsdGVyKChlPT50LnRlc3QoZSkpKS5sZW5ndGg7aWYoZT1lLnRyaW0oKS5yZXBsYWNlKC9cc3syLH0vLCIgIikucmVwbGFjZSgvXCgoa2h0bWx8dW5saWtlfHZpemlvfGxpa2UgZ2VjfGludGVybmFsIGR1bW15fG9yZ1wuZWNsaXBzZXxvcGVuc3NsfGlwdjZ8dmlhIHRyYW5zbGF0ZXxzYWZhcml8Y2FyZGFtb24pLit8eHRcZCtcKS9naSwiIiksbi50ZXN0KGUpKXtjb25zdCBFPWUubWF0Y2gobilbMF0uc2xpY2UoMSwtMSkucmVwbGFjZSgvLC9nLCI7Iikuc3BsaXQoIjsiKS5tYXAoKGU9PmUudHJpbSgpKSk7aWYoeShFLGEpKXJldHVybiBFLm1hcCgoZT0+aS50ZXN0KGUpP2kuZXhlYyhlKVswXS5yZXBsYWNlKCItIiwiICIpOmUpKS5maWx0ZXIoKGU9PiFvLnRlc3QoZSkpKS5qb2luKCIgIikucmVwbGFjZSh0P3I6IiIsIiIpLnRyaW0oKS5yZXBsYWNlKC9cc3syLH0vLCIgIik7aWYoeShFLHMpKXJldHVybiBFLmZpbHRlcigoZT0+IWMudGVzdChlKSkpLmpvaW4oIiAiKS5yZXBsYWNlKC9cc05UIChcZCtcLlxkKykvLCgoZSx0KT0+IjEwLjAiPT10PyIgMTAiOiI2LjMiPT10PyIgOC4xIjoiNi4yIj09dD8iIDgiOiI2LjEiPT10PyIgNyI6IjYuMCI9PXQ/IiBWaXN0YSI6IjUuMiI9PXQ/IiBYUCBQcm8iOiI1LjEiPT10PyIgWFAiOiI1LjAiPT10PyIgMjAwMCI6IjQuMCI9PXQ/ZToiICIrdCkpLnJlcGxhY2UobCwiKDY0LWJpdCkiKS50cmltKCkucmVwbGFjZSgvXHN7Mix9LywiICIpO2lmKHkoRSxkKSlyZXR1cm4gRS5maWx0ZXIoKGU9PiFtLnRlc3QoZSkpKS5qb2luKCIgIikucmVwbGFjZSh0P3U6IiIsIiIpLnRyaW0oKS5yZXBsYWNlKC9cc3syLH0vLCIgIik7aWYoeShFLGcpKXJldHVybiBFLmZpbHRlcigoZT0+IXAudGVzdChlKSkpLmpvaW4oIiAiKS50cmltKCkucmVwbGFjZSgvXHN7Mix9LywiICIpO2lmKHkoRSxoKSlyZXR1cm4gRS5tYXAoKGU9PntpZihmLnRlc3QoZSkpe2NvbnN0IHQ9Zi5leGVjKGUpWzBdLG49eyIxMF83IjoiTGlvbiIsIjEwXzgiOiJNb3VudGFpbiBMaW9uIiwiMTBfOSI6Ik1hdmVyaWNrcyIsIjEwXzEwIjoiWW9zZW1pdGUiLCIxMF8xMSI6IkVsIENhcGl0YW4iLCIxMF8xMiI6IlNpZXJyYSIsIjEwXzEzIjoiSGlnaCBTaWVycmEiLCIxMF8xNCI6Ik1vamF2ZSIsIjEwXzE1IjoiQ2F0YWxpbmEiLDExOiJCaWcgU3VyIiwxMjoiTW9udGVyZXkiLDEzOiJWZW50dXJhIn0sYT0oKC8oXGR7Mn0oX3xcLilcZHsxLDJ9fFxkezIsfSkvLmV4ZWModCl8fFtdKVswXXx8IiIpLnJlcGxhY2UoL1wuL2csIl8iKSxvPW5bL14xMC8udGVzdChhKT9hOigvXlxkezIsfS8uZXhlYyhhKXx8W10pWzBdXTtyZXR1cm4gbz9gbWFjT1MgJHtvfWA6dH1yZXR1cm4gZX0pKS5maWx0ZXIoKGU9PiFiLnRlc3QoZSkpKS5qb2luKCIgIikucmVwbGFjZSgvXHNsaWtlIG1hYy4rL2dpLCIiKS50cmltKCkucmVwbGFjZSgvXHN7Mix9LywiICIpO3tjb25zdCBlPUUuZmlsdGVyKChlPT5TLnRlc3QoZSkpKTtyZXR1cm4gZS5sZW5ndGg/ZS5qb2luKCIgIikudHJpbSgpLnJlcGxhY2UoL1xzezIsfS8sIiAiKTpFLmpvaW4oIiAiKX19cmV0dXJuInVua25vd24ifSxTPWU9Pntjb25zdCB0PSgvTW96aWxsYVwvNVwuMCBcKChNYWNpbnRvc2g7IEludGVsIE1hYyBPUyBYIDEwXzE1Xzd8V2luZG93cyBOVCAxMFwuMDsgV2luNjQ7IHg2NHwoWDExOyAoQ3JPU3xMaW51eCkgeDg2XzY0KXwoTGludXg7IEFuZHJvaWQgMTAoOyBLfCkpKVwpIEFwcGxlV2ViS2l0XC81MzdcLjM2IFwoS0hUTUwsIGxpa2UgR2Vja29cKSBDaHJvbWVcL1xkK1wuMFwuMFwuMCggTW9iaWxlfCkgU2FmYXJpXC81MzdcLjM2Ly5leGVjKGUpfHxbXSlbMV07cmV0dXJuIG4mJiEhdH0seT0oKCk9Pntjb25zdCBlPXt9O2xldCB0PTA7cmV0dXJue2xvZ1Rlc3RSZXN1bHQ6KHt0ZXN0Om4scGFzc2VkOmEsdGltZTpvPTB9KT0+e3QrPW87Y29uc3Qgcj1gJHtvLnRvRml4ZWQoMil9bXNgO3JldHVybiBlW25dPXIsITB9LGdldExvZzooKT0+ZSxnZXRUb3RhbDooKT0+dH19KSgpLHtsb2dUZXN0UmVzdWx0OkV9PXksdz0oKT0+e2xldCBlPTA7Y29uc3QgdD1bXTtyZXR1cm57c3RvcDooKT0+ZT8odC5wdXNoKHBlcmZvcm1hbmNlLm5vdygpLWUpLHQucmVkdWNlKCgoZSx0KT0+ZSt0KSwwKSk6ZSxzdGFydDooKT0+KGU9cGVyZm9ybWFuY2Uubm93KCksZSl9fSxrPShlLHQ9MCk9PihlLnN0b3AoKSxuZXcgUHJvbWlzZSgobj0+c2V0VGltZW91dCgoKCk9Pm4oZS5zdGFydCgpKSksdCkpKS5jYXRjaCgoZT0+e30pKSksdj1bWzEyODUxMl0sWzk3ODZdLFsxMjkzMzMsODIwNSw5Nzk0LDY1MDM5XSxbOTgzMl0sWzk3ODRdLFs5ODk1XSxbODI2NV0sWzg1MDVdLFsxMjc5ODcsNjUwMzksODIwNSw5ODk1LDY1MDM5XSxbMTI5Mzk0XSxbOTc4NV0sWzk3NjBdLFsxMjk0ODksODIwNSwxMjk0NTZdLFsxMjk0ODcsODIwNSw5Nzk0LDY1MDM5XSxbOTk3NV0sWzEyOTQ4OSw4MjA1LDEyOTMwOSw4MjA1LDEyOTQ4OV0sWzk3NTJdLFs5OTY4XSxbOTk2MV0sWzk5NzJdLFs5OTkyXSxbOTIwMV0sWzk5MjhdLFs5NzMwXSxbOTk2OV0sWzk3MzFdLFs5NzMyXSxbOTk3Nl0sWzk4MjNdLFs5OTM3XSxbOWUzXSxbOTk5M10sWzk5OTldLFsxMjgxMDUsODIwNSwxMDA4NCw2NTAzOSw4MjA1LDEyODEzOSw4MjA1LDEyODEwNF0sWzEyODEwNCw4MjA1LDEyODEwNSw4MjA1LDEyODEwMyw4MjA1LDEyODEwMl0sWzEyODEwNCw4MjA1LDEyODEwNSw4MjA1LDEyODEwMl0sWzEyODUxMl0sWzE2OV0sWzE3NF0sWzg0ODJdLFsxMjgwNjUsNjUwMzksODIwNSwxMjg0ODgsNjUwMzldLFsxMDAwMl0sWzk5ODZdLFs5OTM1XSxbOTg3NF0sWzk4NzZdLFs5ODgxXSxbOTkzOV0sWzk4NzldLFs5OTA0XSxbOTkwNV0sWzk4ODhdLFs5NzYyXSxbOTc2M10sWzExMDE0XSxbODU5OV0sWzEwMTQ1XSxbMTEwMTNdLFs5ODgzXSxbMTAwMTddLFsxMDAxM10sWzk3NjZdLFs5NjU0XSxbOTE5N10sWzkxOTldLFs5MTY3XSxbOTc5Ml0sWzk3OTRdLFsxMDAwNl0sWzEyMzM2XSxbOTg3N10sWzk4ODRdLFsxMDAwNF0sWzEwMDM1XSxbMTAwNTVdLFs5NzI0XSxbOTY0Ml0sWzEwMDgzXSxbMTAwODRdLFs5OTk2XSxbOTc1N10sWzk5OTddLFsxMDA1Ml0sWzk4NzhdLFs4NjE4XSxbOTc3NV0sWzk3NzBdLFs5Nzc0XSxbOTc0NV0sWzEwMDM2XSxbMTI3MzQ0XSxbMTI3MzU5XV0ubWFwKChlPT5TdHJpbmcuZnJvbUNvZGVQb2ludCguLi5lKSkpLEE9IlxuXHQnU2Vnb2UgRmx1ZW50IEljb25zJyxcblx0J0luayBGcmVlJyxcblx0J0JhaG5zY2hyaWZ0Jyxcblx0J1NlZ29lIE1ETDIgQXNzZXRzJyxcblx0J0hvbG9MZW5zIE1ETDIgQXNzZXRzJyxcblx0J0xlZWxhd2FkZWUgVUknLFxuXHQnSmF2YW5lc2UgVGV4dCcsXG5cdCdTZWdvZSBVSSBFbW9qaScsXG5cdCdBbGRoYWJpJyxcblx0J0dhZHVnaScsXG5cdCdNeWFubWFyIFRleHQnLFxuXHQnTmlybWFsYSBVSScsXG5cdCdMdWNpZGEgQ29uc29sZScsXG5cdCdDYW1icmlhIE1hdGgnLFxuXHQnQmFpIEphbWp1cmVlJyxcblx0J0NoYWtyYSBQZXRjaCcsXG5cdCdDaGFybW9ubWFuJyxcblx0J0ZhaGt3YW5nJyxcblx0J0syRCcsXG5cdCdLb2RjaGFzYW4nLFxuXHQnS29IbycsXG5cdCdTYXJhYnVuJyxcblx0J1NyaXNha2RpJyxcblx0J0dhbHZqaScsXG5cdCdNdWt0YU1haGVlIFJlZ3VsYXInLFxuXHQnSW5haU1hdGhpIEJvbGQnLFxuXHQnQW1lcmljYW4gVHlwZXdyaXRlciBTZW1pYm9sZCcsXG5cdCdGdXR1cmEgQm9sZCcsXG5cdCdTaWduUGFpbnRlci1Ib3VzZVNjcmlwdCBTZW1pYm9sZCcsXG5cdCdQaW5nRmFuZyBISyBMaWdodCcsXG5cdCdLb2hpbm9vciBEZXZhbmFnYXJpIE1lZGl1bScsXG5cdCdMdW1pbmFyaScsXG5cdCdHZW5ldmEnLFxuXHQnSGVsdmV0aWNhIE5ldWUnLFxuXHQnRHJvaWQgU2FucyBNb25vJyxcblx0J0RhbmNpbmcgU2NyaXB0Jyxcblx0J1JvYm90bycsXG5cdCdVYnVudHUnLFxuXHQnTGliZXJhdGlvbiBNb25vJyxcblx0J1NvdXJjZSBDb2RlIFBybycsXG5cdCdEZWphVnUgU2FucycsXG5cdCdPcGVuU3ltYm9sJyxcblx0J0NoaWxhbmthJyxcblx0J0NvdXNpbmUnLFxuXHQnQXJpbW8nLFxuXHQnSm9tb2xoYXJpJyxcblx0J01PTk8nLFxuXHQnTm90byBDb2xvciBFbW9qaScsXG5cdHNhbnMtc2VyaWYgIWltcG9ydGFudFxuIjtjb25zdCBEPXt9LE09e0FVRElPOiExLENBTlZBUzohMSxGT05UUzohMSxTQ1JFRU46ITEsVElNRV9aT05FOiExLFdFQkdMOiExfTtmdW5jdGlvbiBDKGUsdCxuKXtyZXR1cm4gZT8oZS5wYXJlbnROb2RlPy5yZXBsYWNlQ2hpbGQodCxlKSwiZnVuY3Rpb24iIT10eXBlb2Ygbnx8bigpKTpudWxsfWZ1bmN0aW9uIFQoZSwuLi50KXtjb25zdCBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInRlbXBsYXRlIik7cmV0dXJuIG4uaW5uZXJIVE1MPWUubWFwKCgoZSxuKT0+YCR7ZX0ke3Rbbl18fCIifWApKS5qb2luKCIiKSxkb2N1bWVudC5pbXBvcnROb2RlKG4uY29udGVudCwhMCl9Y29uc3QgeD0oKCk9Pntjb25zdCBlPVtdO3JldHVybntnZXRFcnJvcnM6KCk9PmUsY2FwdHVyZUVycm9yOih0LG49IiIpPT57Y29uc29sZS5lcnJvcih0KTtjb25zdHtuYW1lOmEsbWVzc2FnZTpvfT10LHI9Ly4rKFxzKS4rL2cudGVzdChvKT9uP2Ake299IFske259XWA6bzp2b2lkIDA7Y29uc3QgaT17RXJyb3I6ITAsRXZhbEVycm9yOiEwLEludGVybmFsRXJyb3I6ITAsUmFuZ2VFcnJvcjohMCxSZWZlcmVuY2VFcnJvcjohMCxTeW50YXhFcnJvcjohMCxUeXBlRXJyb3I6ITAsVVJJRXJyb3I6ITAsSW52YWxpZFN0YXRlRXJyb3I6ITAsU2VjdXJpdHlFcnJvcjohMH1bYV0/YTp2b2lkIDA7ZS5wdXNoKHt0cnVzdGVkTmFtZTppLHRydXN0ZWRNZXNzYWdlOnJ9KX19fSkoKSx7Y2FwdHVyZUVycm9yOlJ9PXgsTj0oZSx0PSIiKT0+e3RyeXtyZXR1cm4gZSgpfWNhdGNoKGUpe3JldHVybiB0P1IoZSx0KTpSKGUpfX0sST0oZSx0PVtdLG49W10sYT0hMSk9PntsZXQgbyxyO3RyeXtvPWUoKX1jYXRjaChlKXtyZXR1cm59Y29uc3QgaT10Lmxlbmd0aDtsZXQgcz1vO3RyeXtmb3Iocj0wO3I8aTtyKyspe3M9c1t0W3JdXX19Y2F0Y2goZSl7cmV0dXJufXJldHVybiBhJiZuLmxlbmd0aD9zLmFwcGx5KG8sbik6YSYmIW4ubGVuZ3RoP3MuYXBwbHkobyk6c30sTD1lPT57ZSYmY29uc29sZS5sb2coZSk7bGV0IHQ9MDt0cnl7dD1wZXJmb3JtYW5jZS5ub3coKX1jYXRjaChlKXtSKGUpfXJldHVybiBlPT57bGV0IG49MDt0cnl7cmV0dXJuIG49cGVyZm9ybWFuY2Uubm93KCktdCxlJiZjb25zb2xlLmxvZyhgJHtlfTogJHtuLzFlM30gc2Vjb25kc2ApLG59Y2F0Y2goZSl7cmV0dXJuIFIoZSksMH19fTt0cnl7c3BlZWNoU3ludGhlc2lzLmdldFZvaWNlcygpfWNhdGNoKGUpe31jb25zdCBQPWZ1bmN0aW9uKCl7Y29uc3QgZT17fTtyZXR1cm57Z2V0UmVjb3JkczooKT0+ZSxkb2N1bWVudExpZToodCxuKT0+e2NvbnN0IGE9biBpbnN0YW5jZW9mIEFycmF5O3JldHVybiBlW3RdP2E/ZVt0XT1bLi4uZVt0XSwuLi5uXTplW3RdLnB1c2gobik6ZVt0XT1hP246W25dfX19KCkse2RvY3VtZW50TGllOk99PVAsQj0iXG5cdGhlaWdodDogMTAwdmg7XG5cdHdpZHRoOiAxMDB2dztcblx0cG9zaXRpb246IGFic29sdXRlO1xuXHRsZWZ0Oi0xMDAwMHB4O1xuXHR2aXNpYmlsaXR5OiBoaWRkZW47XG4iO2Z1bmN0aW9uIEgoKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgyNipNYXRoLnJhbmRvbSgpKzk3KStNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgtNyl9SCgpO2NvbnN0IEY9IlJlZmxlY3QiaW4gc2VsZjtmdW5jdGlvbiBHKHtzcGF3bkVycjplLHdpdGhTdGFjazp0LGZpbmFsOm59KXt0cnl7dGhyb3cgZSgpLEVycm9yKCl9Y2F0Y2goZSl7cmV0dXJuIWZ1bmN0aW9uKGUpe3JldHVybiJUeXBlRXJyb3IiPT1lLmNvbnN0cnVjdG9yLm5hbWV9KGUpfHwhIXQmJnQoZSl9ZmluYWxseXtuJiZuKCl9fWZ1bmN0aW9uIFYoZSl7dHJ5e3JldHVybiBlKCksITF9Y2F0Y2goZSl7cmV0dXJuITB9fWZ1bmN0aW9uIF8oZSl7cmV0dXJue1tgZnVuY3Rpb24gJHtlfSgpIHsgW25hdGl2ZSBjb2RlXSB9YF06ITAsW2BmdW5jdGlvbiBnZXQgJHtlfSgpIHsgW25hdGl2ZSBjb2RlXSB9YF06ITAsImZ1bmN0aW9uICgpIHsgW25hdGl2ZSBjb2RlXSB9IjohMCxbYGZ1bmN0aW9uICR7ZX0oKSB7XG4gICAgW25hdGl2ZSBjb2RlXVxufWBdOiEwLFtgZnVuY3Rpb24gZ2V0ICR7ZX0oKSB7XG4gICAgW25hdGl2ZSBjb2RlXVxufWBdOiEwLCJmdW5jdGlvbiAoKSB7XG4gICAgW25hdGl2ZSBjb2RlXVxufSI6ITB9fWZ1bmN0aW9uIFcoZSx0LG49MSl7cmV0dXJuIDA9PT1uP3QudGVzdChlLm1lc3NhZ2UpOnQudGVzdChlLnN0YWNrLnNwbGl0KCJcbiIpW25dKX1jb25zdCB6PS9hdCBGdW5jdGlvblwudG9TdHJpbmcgLyxqPS9hdCBPYmplY3RcLnRvU3RyaW5nLyxVPS9hdCAoRnVuY3Rpb25cLik/XFtTeW1ib2wuaGFzSW5zdGFuY2VcXS8sJD0vYXQgKFByb3h5XC4pP1xbU3ltYm9sLmhhc0luc3RhbmNlXF0vLFg9L3N0cmljdCBtb2RlLztmdW5jdGlvbiBxKHtzY29wZTplLGFwaUZ1bmN0aW9uOnQscHJvdG86cixvYmo6aSxsaWVQcm9wczpzfSl7aWYoImZ1bmN0aW9uIiE9dHlwZW9mIHQpcmV0dXJue2xpZWQ6MCxsaWVUeXBlczpbXX07Y29uc3QgYz10Lm5hbWUucmVwbGFjZSgvZ2V0XHMvLCIiKSxsPWk/Lm5hbWUsZD1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7bGV0IG09eyJmYWlsZWQgaWxsZWdhbCBlcnJvciI6ISFpJiZHKHtzcGF3bkVycjooKT0+aS5wcm90b3R5cGVbY119KSwiZmFpbGVkIHVuZGVmaW5lZCBwcm9wZXJ0aWVzIjohIWkmJi9eKHNjcmVlbnxuYXZpZ2F0b3IpJC9pLnRlc3QobCkmJiEhKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2VsZltsLnRvTG93ZXJDYXNlKCldLGMpfHxGJiZSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzZWxmW2wudG9Mb3dlckNhc2UoKV0sYykpLCJmYWlsZWQgY2FsbCBpbnRlcmZhY2UgZXJyb3IiOkcoe3NwYXduRXJyOigpPT57bmV3IHQsdC5jYWxsKHIpfX0pLCJmYWlsZWQgYXBwbHkgaW50ZXJmYWNlIGVycm9yIjpHKHtzcGF3bkVycjooKT0+e25ldyB0LHQuYXBwbHkocil9fSksImZhaWxlZCBuZXcgaW5zdGFuY2UgZXJyb3IiOkcoe3NwYXduRXJyOigpPT5uZXcgdH0pLCJmYWlsZWQgY2xhc3MgZXh0ZW5kcyBlcnJvciI6IW8mJkcoe3NwYXduRXJyOigpPT57fX0pLCJmYWlsZWQgbnVsbCBjb252ZXJzaW9uIGVycm9yIjpHKHtzcGF3bkVycjooKT0+T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsbnVsbCkudG9TdHJpbmcoKSxmaW5hbDooKT0+T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZCl9KSwiZmFpbGVkIHRvU3RyaW5nIjohXyhjKVtlLkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpXXx8IV8oInRvU3RyaW5nIilbZS5GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0LnRvU3RyaW5nKV0sJ2ZhaWxlZCAicHJvdG90eXBlIiBpbiBmdW5jdGlvbic6InByb3RvdHlwZSJpbiB0LCJmYWlsZWQgZGVzY3JpcHRvciI6ISEoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCJhcmd1bWVudHMiKXx8UmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwiYXJndW1lbnRzIil8fE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwiY2FsbGVyIil8fFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsImNhbGxlciIpfHxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsInByb3RvdHlwZSIpfHxSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCJwcm90b3R5cGUiKXx8T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCJ0b1N0cmluZyIpfHxSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCJ0b1N0cmluZyIpKSwiZmFpbGVkIG93biBwcm9wZXJ0eSI6ISEodC5oYXNPd25Qcm9wZXJ0eSgiYXJndW1lbnRzIil8fHQuaGFzT3duUHJvcGVydHkoImNhbGxlciIpfHx0Lmhhc093blByb3BlcnR5KCJwcm90b3R5cGUiKXx8dC5oYXNPd25Qcm9wZXJ0eSgidG9TdHJpbmciKSksImZhaWxlZCBkZXNjcmlwdG9yIGtleXMiOiJsZW5ndGgsbmFtZSIhPU9iamVjdC5rZXlzKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKS5zb3J0KCkudG9TdHJpbmcoKSwiZmFpbGVkIG93biBwcm9wZXJ0eSBuYW1lcyI6Imxlbmd0aCxuYW1lIiE9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCkuc29ydCgpLnRvU3RyaW5nKCksImZhaWxlZCBvd24ga2V5cyBuYW1lcyI6RiYmImxlbmd0aCxuYW1lIiE9UmVmbGVjdC5vd25LZXlzKHQpLnNvcnQoKS50b1N0cmluZygpLCJmYWlsZWQgb2JqZWN0IHRvU3RyaW5nIGVycm9yIjpHKHtzcGF3bkVycjooKT0+T2JqZWN0LmNyZWF0ZSh0KS50b1N0cmluZygpLHdpdGhTdGFjazplPT5uJiYhVyhlLHopfSl8fEcoe3NwYXduRXJyOigpPT5PYmplY3QuY3JlYXRlKG5ldyBQcm94eSh0LHt9KSkudG9TdHJpbmcoKSx3aXRoU3RhY2s6ZT0+biYmIVcoZSxqKX0pLCJmYWlsZWQgYXQgaW5jb21wYXRpYmxlIHByb3h5IGVycm9yIjpHKHtzcGF3bkVycjooKT0+e3QuYXJndW1lbnRzLHQuY2FsbGVyfSx3aXRoU3RhY2s6ZT0+YSYmIVcoZSxYLDApfSksImZhaWxlZCBhdCB0b1N0cmluZyBpbmNvbXBhdGlibGUgcHJveHkgZXJyb3IiOkcoe3NwYXduRXJyOigpPT57dC50b1N0cmluZy5hcmd1bWVudHMsdC50b1N0cmluZy5jYWxsZXJ9LHdpdGhTdGFjazplPT5hJiYhVyhlLFgsMCl9KSwiZmFpbGVkIGF0IHRvbyBtdWNoIHJlY3Vyc2lvbiBlcnJvciI6Ryh7c3Bhd25FcnI6KCk9PntPYmplY3Quc2V0UHJvdG90eXBlT2YodCxPYmplY3QuY3JlYXRlKHQpKS50b1N0cmluZygpfSxmaW5hbDooKT0+T2JqZWN0LnNldFByb3RvdHlwZU9mKHQsZCl9KX07aWYoInRvU3RyaW5nIj09Y3x8ISFzWyJGdW5jdGlvbi50b1N0cmluZyJdfHwhIXNbIlBlcm1pc3Npb25zLnF1ZXJ5Il0pe2NvbnN0IGU9bmV3IFByb3h5KHQse30pLGE9bmV3IFByb3h5KHQse30pLG89bmV3IFByb3h5KHQse30pO209ey4uLm0sImZhaWxlZCBhdCB0b28gbXVjaCByZWN1cnNpb24gX19wcm90b19fIGVycm9yIjohRyh7c3Bhd25FcnI6KCk9Pnt0Ll9fcHJvdG9fXz1wcm94eSx0Kyt9LGZpbmFsOigpPT5PYmplY3Quc2V0UHJvdG90eXBlT2YodCxkKX0pLCJmYWlsZWQgYXQgY2hhaW4gY3ljbGUgZXJyb3IiOiFHKHtzcGF3bkVycjooKT0+e09iamVjdC5zZXRQcm90b3R5cGVPZihlLE9iamVjdC5jcmVhdGUoZSkpLnRvU3RyaW5nKCl9LGZpbmFsOigpPT5PYmplY3Quc2V0UHJvdG90eXBlT2YoZSxkKX0pLCJmYWlsZWQgYXQgY2hhaW4gY3ljbGUgX19wcm90b19fIGVycm9yIjohRyh7c3Bhd25FcnI6KCk9PnthLl9fcHJvdG9fXz1hLGErK30sZmluYWw6KCk9Pk9iamVjdC5zZXRQcm90b3R5cGVPZihhLGQpfSksImZhaWxlZCBhdCByZWZsZWN0IHNldCBwcm90byI6RiYmRyh7c3Bhd25FcnI6KCk9Pnt0aHJvdyBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHQsT2JqZWN0LmNyZWF0ZSh0KSksbmV3IFR5cGVFcnJvcn0sZmluYWw6KCk9Pk9iamVjdC5zZXRQcm90b3R5cGVPZih0LGQpfSksImZhaWxlZCBhdCByZWZsZWN0IHNldCBwcm90byBwcm94eSI6RiYmIUcoe3NwYXduRXJyOigpPT57UmVmbGVjdC5zZXRQcm90b3R5cGVPZihvLE9iamVjdC5jcmVhdGUobykpfSxmaW5hbDooKT0+T2JqZWN0LnNldFByb3RvdHlwZU9mKG8sZCl9KSwiZmFpbGVkIGF0IGluc3RhbmNlb2YgY2hlY2sgZXJyb3IiOm4mJihHKHtzcGF3bkVycjooKT0+e30sd2l0aFN0YWNrOmU9PiFXKGUsVSl9KXx8Ryh7c3Bhd25FcnI6KCk9PntuZXcgUHJveHkodCx7fSl9LHdpdGhTdGFjazplPT4hVyhlLCQpfSkpLCJmYWlsZWQgYXQgZGVmaW5lIHByb3BlcnRpZXMiOm4mJkYmJlYoKCgpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIiIse2NvbmZpZ3VyYWJsZTohMH0pLnRvU3RyaW5nKCksUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0LCIiKX0pKX19Y29uc3QgdT1PYmplY3Qua2V5cyhtKS5maWx0ZXIoKGU9PiEhbVtlXSkpO3JldHVybntsaWVkOnUubGVuZ3RoLGxpZVR5cGVzOnV9fWZ1bmN0aW9uIEsoZSl7Y29uc3QgdD17fSxuPVtdO3JldHVybntnZXRQcm9wczooKT0+dCxnZXRQcm9wc1NlYXJjaGVkOigpPT5uLHNlYXJjaExpZXM6KGEsbyk9Pntjb25zdHt0YXJnZXQ6cixpZ25vcmU6aX09b3x8e307bGV0IHM7dHJ5e2lmKHM9YSgpLCEoZT0+dm9pZCAwIT09ZSYmISFlKShzKSlyZXR1cm59Y2F0Y2goZSl7cmV0dXJufWNvbnN0IGM9cy5wcm90b3R5cGU/cy5wcm90b3R5cGU6cztbLi4ubmV3IFNldChbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYyksLi4uT2JqZWN0LmtleXMoYyldKV0uc29ydCgpLmZvckVhY2goKGE9PntpZigiY29uc3RydWN0b3IiPT1hfHxyJiYhbmV3IFNldChyKS5oYXMoYSl8fGkmJm5ldyBTZXQoaSkuaGFzKGEpKXJldHVybjtjb25zdCBvPS9ccyguKylcXS8sYz1gJHtzLm5hbWU/cy5uYW1lOm8udGVzdChzKT9vLmV4ZWMocyk/LlsxXTp2b2lkIDB9LiR7YX1gO24ucHVzaChjKTt0cnl7Y29uc3Qgbj1zLnByb3RvdHlwZT9zLnByb3RvdHlwZTpzO2xldCBvO3RyeXtpZigiZnVuY3Rpb24iPT10eXBlb2YgblthXSlyZXR1cm4gbz1xKHtzY29wZTplLGFwaUZ1bmN0aW9uOm5bYV0scHJvdG86bixvYmo6bnVsbCxsaWVQcm9wczp0fSksby5saWVkPyhPKGMsby5saWVUeXBlcyksdFtjXT1vLmxpZVR5cGVzKTp2b2lkIDA7aWYoIm5hbWUiIT1hJiYibGVuZ3RoIiE9YSYmYVswXSE9PWFbMF0udG9VcHBlckNhc2UoKSl7Y29uc3QgZT1bImZhaWxlZCBkZXNjcmlwdG9yLnZhbHVlIHVuZGVmaW5lZCJdO3JldHVybiBPKGMsZSksdFtjXT1lfX1jYXRjaChlKXt9Y29uc3Qgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sYSkuZ2V0O3JldHVybiBvPXEoe3Njb3BlOmUsYXBpRnVuY3Rpb246cixwcm90bzpuLG9iajpzLGxpZVByb3BzOnR9KSxvLmxpZWQ/KE8oYyxvLmxpZVR5cGVzKSx0W2NdPW8ubGllVHlwZXMpOnZvaWQgMH1jYXRjaChlKXtjb25zdCBuPSJmYWlsZWQgcHJvdG90eXBlIHRlc3QgZXhlY3V0aW9uIjtyZXR1cm4gTyhjLG4pLHRbY109W25dfX0pKX19fWNvbnN0e2lmcmFtZVdpbmRvdzpZLGRpdjpRfT1mdW5jdGlvbigpe2lmKGUpcmV0dXJue2lmcmFtZVdpbmRvdzpzZWxmfTt0cnl7Y29uc3QgZT1zZWxmLmxlbmd0aCx0PW5ldyBEb2N1bWVudEZyYWdtZW50LGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iiksbz1IKCk7YS5zZXRBdHRyaWJ1dGUoImlkIixvKSx0LmFwcGVuZENoaWxkKGEpLGEuaW5uZXJIVE1MPWA8ZGl2IHN0eWxlPSIke0J9Ij48aWZyYW1lPjwvaWZyYW1lPjwvZGl2PmAsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KTtjb25zdCByPWZ1bmN0aW9uKGUpe3RyeXtpZighbilyZXR1cm4gZTtjb25zdCB0PWUuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7dC5zZXRBdHRyaWJ1dGUoImlkIixIKCkpLHQuc2V0QXR0cmlidXRlKCJzdHlsZSIsQiksdC5pbm5lckhUTUw9IjxkaXY+PGlmcmFtZT48L2lmcmFtZT48L2Rpdj4iLGUuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KTtjb25zdCBhPVsuLi5bLi4udC5jaGlsZE5vZGVzXVswXS5jaGlsZE5vZGVzXVswXTtpZighYSlyZXR1cm4gbnVsbDtjb25zdHtjb250ZW50V2luZG93Om99PWF8fHt9O2lmKCFvKXJldHVybiBudWxsO2NvbnN0IHI9by5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJkaXYiKTtyZXR1cm4gci5pbm5lckhUTUw9IjxkaXY+PGlmcmFtZT48L2lmcmFtZT48L2Rpdj4iLG8uZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyKSxbLi4uWy4uLnIuY2hpbGROb2Rlc11bMF0uY2hpbGROb2Rlc11bMF0uY29udGVudFdpbmRvd31jYXRjaCh0KXtyZXR1cm4gUih0LCJjbGllbnQgYmxvY2tlZCBiZWhlbW90aCBpZnJhbWUiKSxlfX0oc2VsZltlXSk7cmV0dXJue2lmcmFtZVdpbmRvdzpyfHxzZWxmLGRpdjphfX1jYXRjaChlKXtyZXR1cm4gUihlLCJjbGllbnQgYmxvY2tlZCBwaGFudG9tIGlmcmFtZSIpLHtpZnJhbWVXaW5kb3c6c2VsZn19fSgpfHx7fTtjb25zdCBKPXBlcmZvcm1hbmNlLm5vdygpLHtsaWVEZXRlY3RvcjpaLGxpZUxpc3Q6ZWUsbGllRGV0YWlsOnRlLHByb3BzU2VhcmNoZWQ6bmV9PWZ1bmN0aW9uKGUpe2NvbnN0IHQ9SyhlKSx7c2VhcmNoTGllczpufT10O24oKCgpPT5GdW5jdGlvbikse3RhcmdldDpbInRvU3RyaW5nIl0saWdub3JlOlsiY2FsbGVyIiwiYXJndW1lbnRzIl19KSxuKCgoKT0+QW5hbHlzZXJOb2RlKSksbigoKCk9PkF1ZGlvQnVmZmVyKSx7dGFyZ2V0OlsiY29weUZyb21DaGFubmVsIiwiZ2V0Q2hhbm5lbERhdGEiXX0pLG4oKCgpPT5CaXF1YWRGaWx0ZXJOb2RlKSx7dGFyZ2V0OlsiZ2V0RnJlcXVlbmN5UmVzcG9uc2UiXX0pLG4oKCgpPT5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpLHt0YXJnZXQ6WyJnZXRJbWFnZURhdGEiLCJnZXRMaW5lRGFzaCIsImlzUG9pbnRJblBhdGgiLCJpc1BvaW50SW5TdHJva2UiLCJtZWFzdXJlVGV4dCIsInF1YWRyYXRpY0N1cnZlVG8iLCJmaWxsVGV4dCIsInN0cm9rZVRleHQiLCJmb250Il19KSxuKCgoKT0+Q1NTU3R5bGVEZWNsYXJhdGlvbikse3RhcmdldDpbInNldFByb3BlcnR5Il19KSxuKCgoKT0+Q1NTMlByb3BlcnRpZXMpLHt0YXJnZXQ6WyJzZXRQcm9wZXJ0eSJdfSksbigoKCk9PkRhdGUpLHt0YXJnZXQ6WyJnZXREYXRlIiwiZ2V0RGF5IiwiZ2V0RnVsbFllYXIiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRNb250aCIsImdldFRpbWUiLCJnZXRUaW1lem9uZU9mZnNldCIsInNldERhdGUiLCJzZXRGdWxsWWVhciIsInNldEhvdXJzIiwic2V0TWlsbGlzZWNvbmRzIiwic2V0TW9udGgiLCJzZXRTZWNvbmRzIiwic2V0VGltZSIsInRvRGF0ZVN0cmluZyIsInRvSlNPTiIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInRvTG9jYWxlU3RyaW5nIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwidG9TdHJpbmciLCJ0b1RpbWVTdHJpbmciLCJ2YWx1ZU9mIl19KSxuKCgoKT0+SW50bC5EYXRlVGltZUZvcm1hdCkse3RhcmdldDpbImZvcm1hdCIsImZvcm1hdFJhbmdlIiwiZm9ybWF0VG9QYXJ0cyIsInJlc29sdmVkT3B0aW9ucyJdfSksbigoKCk9PkRvY3VtZW50KSx7dGFyZ2V0OlsiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsImdldEVsZW1lbnRCeUlkIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImdldEVsZW1lbnRzQnlOYW1lIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZU5TIiwicmVmZXJyZXIiLCJ3cml0ZSIsIndyaXRlbG4iXSxpZ25vcmU6WyJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJvbm1vdXNlZW50ZXIiLCJvbm1vdXNlbGVhdmUiXX0pLG4oKCgpPT5ET01SZWN0KSksbigoKCk9PkRPTVJlY3RSZWFkT25seSkpLG4oKCgpPT5FbGVtZW50KSx7dGFyZ2V0OlsiYXBwZW5kIiwiYXBwZW5kQ2hpbGQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXRDbGllbnRSZWN0cyIsImluc2VydEFkamFjZW50RWxlbWVudCIsImluc2VydEFkamFjZW50SFRNTCIsImluc2VydEFkamFjZW50VGV4dCIsImluc2VydEJlZm9yZSIsInByZXBlbmQiLCJyZXBsYWNlQ2hpbGQiLCJyZXBsYWNlV2l0aCIsInNldEF0dHJpYnV0ZSJdfSksbigoKCk9PkZvbnRGYWNlKSx7dGFyZ2V0OlsiZmFtaWx5IiwibG9hZCIsInN0YXR1cyJdfSksbigoKCk9PkhUTUxDYW52YXNFbGVtZW50KSksbigoKCk9PkhUTUxFbGVtZW50KSx7dGFyZ2V0OlsiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInNjcm9sbEhlaWdodCIsInNjcm9sbFdpZHRoIl0saWdub3JlOlsib25tb3VzZWVudGVyIiwib25tb3VzZWxlYXZlIl19KSxuKCgoKT0+SFRNTElGcmFtZUVsZW1lbnQpLHt0YXJnZXQ6WyJjb250ZW50RG9jdW1lbnQiLCJjb250ZW50V2luZG93Il19KSxuKCgoKT0+SW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSkse3RhcmdldDpbImJvdW5kaW5nQ2xpZW50UmVjdCIsImludGVyc2VjdGlvblJlY3QiLCJyb290Qm91bmRzIl19KSxuKCgoKT0+TWF0aCkse3RhcmdldDpbImFjb3MiLCJhY29zaCIsImFzaW5oIiwiYXRhbiIsImF0YW4yIiwiYXRhbmgiLCJjYnJ0IiwiY29zIiwiY29zaCIsImV4cCIsImV4cG0xIiwibG9nIiwibG9nMTAiLCJsb2cxcCIsInNpbiIsInNpbmgiLCJzcXJ0IiwidGFuIiwidGFuaCJdfSksbigoKCk9Pk1lZGlhRGV2aWNlcykse3RhcmdldDpbImVudW1lcmF0ZURldmljZXMiLCJnZXREaXNwbGF5TWVkaWEiLCJnZXRVc2VyTWVkaWEiXX0pLG4oKCgpPT5OYXZpZ2F0b3IpLHt0YXJnZXQ6WyJhcHBDb2RlTmFtZSIsImFwcE5hbWUiLCJhcHBWZXJzaW9uIiwiYnVpbGRJRCIsImNvbm5lY3Rpb24iLCJkZXZpY2VNZW1vcnkiLCJnZXRCYXR0ZXJ5IiwiZ2V0R2FtZXBhZHMiLCJnZXRWUkRpc3BsYXlzIiwiaGFyZHdhcmVDb25jdXJyZW5jeSIsImxhbmd1YWdlIiwibGFuZ3VhZ2VzIiwibWF4VG91Y2hQb2ludHMiLCJtaW1lVHlwZXMiLCJvc2NwdSIsInBsYXRmb3JtIiwicGx1Z2lucyIsInByb2R1Y3QiLCJwcm9kdWN0U3ViIiwic2VuZEJlYWNvbiIsInNlcnZpY2VXb3JrZXIiLCJ1c2VyQWdlbnQiLCJ2ZW5kb3IiLCJ2ZW5kb3JTdWIiXX0pLG4oKCgpPT5Ob2RlKSx7dGFyZ2V0OlsiYXBwZW5kQ2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJyZXBsYWNlQ2hpbGQiXX0pLG4oKCgpPT5PZmZzY3JlZW5DYW52YXMpLHt0YXJnZXQ6WyJjb252ZXJ0VG9CbG9iIiwiZ2V0Q29udGV4dCJdfSksbigoKCk9Pk9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkse3RhcmdldDpbImdldEltYWdlRGF0YSIsImdldExpbmVEYXNoIiwiaXNQb2ludEluUGF0aCIsImlzUG9pbnRJblN0cm9rZSIsIm1lYXN1cmVUZXh0IiwicXVhZHJhdGljQ3VydmVUbyIsImZvbnQiXX0pLG4oKCgpPT5QZXJtaXNzaW9ucykse3RhcmdldDpbInF1ZXJ5Il19KSxuKCgoKT0+UmFuZ2UpLHt0YXJnZXQ6WyJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXRDbGllbnRSZWN0cyJdfSksbigoKCk9PkludGwuUmVsYXRpdmVUaW1lRm9ybWF0KSx7dGFyZ2V0OlsicmVzb2x2ZWRPcHRpb25zIl19KSxuKCgoKT0+U2NyZWVuKSksbigoKCk9PnNwZWVjaFN5bnRoZXNpcykse3RhcmdldDpbImdldFZvaWNlcyJdfSksbigoKCk9PlN0cmluZykse3RhcmdldDpbImZyb21Db2RlUG9pbnQiXX0pLG4oKCgpPT5TVkdSZWN0KSksbigoKCk9PlNWR1JlY3RFbGVtZW50KSx7dGFyZ2V0OlsiZ2V0QkJveCJdfSksbigoKCk9PlNWR1RleHRDb250ZW50RWxlbWVudCkse3RhcmdldDpbImdldEV4dGVudE9mQ2hhciIsImdldFN1YlN0cmluZ0xlbmd0aCIsImdldENvbXB1dGVkVGV4dExlbmd0aCJdfSksbigoKCk9PlRleHRNZXRyaWNzKSksbigoKCk9PldlYkdMUmVuZGVyaW5nQ29udGV4dCkse3RhcmdldDpbImJ1ZmZlckRhdGEiLCJnZXRQYXJhbWV0ZXIiLCJyZWFkUGl4ZWxzIl19KSxuKCgoKT0+V2ViR0wyUmVuZGVyaW5nQ29udGV4dCkse3RhcmdldDpbImJ1ZmZlckRhdGEiLCJnZXRQYXJhbWV0ZXIiLCJyZWFkUGl4ZWxzIl19KTtjb25zdCBhPXQuZ2V0UHJvcHMoKSxvPXQuZ2V0UHJvcHNTZWFyY2hlZCgpO3JldHVybntsaWVEZXRlY3Rvcjp0LGxpZUxpc3Q6T2JqZWN0LmtleXMoYSkuc29ydCgpLGxpZURldGFpbDphLGxpZUNvdW50Ok9iamVjdC5rZXlzKGEpLnJlZHVjZSgoKGUsdCk9PmUrYVt0XS5sZW5ndGgpLDApLHByb3BzU2VhcmNoZWQ6b319KFkpO2xldCBhZSxvZTtpZighZSl7YWU9KCgpPT57Y29uc3QgZT1aLmdldFByb3BzKCk7cmV0dXJuIE9iamVjdC5rZXlzKGUpLnJlZHVjZSgoKHQsbik9Pnt2YXIgYTtyZXR1cm4gdFtuXT0oYT1lW25dKT9hLmZpbHRlcigoZT0+IS9vYmplY3QgdG9TdHJpbmd8dG9TdHJpbmcgaW5jb21wYXRpYmxlIHByb3h5Ly50ZXN0KGUpKSkubGVuZ3RoOmEsdH0pLHt9KX0pKCksb2U9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0ZSkpOyhwZXJmb3JtYW5jZS5ub3coKS1KKS50b0ZpeGVkKDIpfWNvbnN0IHJlPSgpPT57Y29uc3QgZT1QLmdldFJlY29yZHMoKSx0PU9iamVjdC5rZXlzKGUpLnJlZHVjZSgoKHQsbik9PnQrPWVbbl0ubGVuZ3RoKSwwKTtyZXR1cm57ZGF0YTplLHRvdGFsTGllczp0fX0saWU9e2FhOjEsYWI6MSxhYzoxLGFkOjEsYWU6MSxhZjoxLGFnOjEsYWg6MSxhaToxLGFqOjEsYWs6MSxhbDoxLGFtOjEsYW46MSxhbzoxLGFwOjEsYXE6MSxhcjoxLGFzOjEsYXQ6MSxhdToxLGF2OjEsYXc6MSxheDoxLGF5OjEsYXo6MSxiYToxLGJiOjEsYmM6MSxiZDoxLGJlOjEsYmY6MSxiZzoxLGJoOjEsYmk6MSxiajoxLGJrOjEsYmw6MSxibToxLGJuOjEsYm86MSxicDoxLGJyOjEsYnM6MSxidDoxLGJ1OjEsYnY6MSxidzoxLGJ4OjEsYnk6MSxjYToxLGNiOjEsY2M6MSxjZDoxLGNlOjEsY2c6MSxjaDoxLGNpOjEsY2s6MSxjbDoxLGNtOjEsY246MSxjbzoxLGNwOjEsY3E6MSxjcjoxLGNzOjEsY3Q6MSxjdToxLGN3OjEsY3k6MSxjejoxLGRhOjEsZGI6MSxkYzoxLGRkOjEsZGU6MSxkZjoxLGRnOjEsZGg6MSxkaToxLGRqOjEsZGs6MSxkbDoxLGRtOjEsZG46MSxkbzoxLGRwOjEsZHE6MSxkcjoxLGRzOjEsZHQ6MSxkdToxLGR2OjEsZHc6MSxkeDoxLGR5OjEsZHo6MSxlYToxLGViOjEsZWM6MSxlZDoxLGVlOjEsZWY6MSxlZzoxLGVoOjEsZWk6MSxlajoxLGVrOjEsZWw6MSxlbToxLGVuOjEsZW86MSxlcDoxLGVxOjEsZXI6MSxlczoxLGV0OjEsZXU6MSxldjoxLGV3OjEsZXg6MSxleToxLGV6OjEsZmE6MSxmYjoxLGZjOjEsZmQ6MSxmZToxLGZmOjEsZmc6MSxmaDoxLGZpOjEsZmo6MSxmazoxLGZsOjEsZm06MSxmbjoxLGZvOjEsZnA6MSxmcjoxLGZzOjEsZnQ6MSxmdToxLGZ3OjEsZnk6MSxnYToxLGdiOjEsZ2M6MSxnZDoxLGdlOjEsZ2Y6MSxnZzoxLGdoOjEsZ2k6MSxnajoxLGdrOjEsZ2w6MSxnbToxLGduOjEsZ286MSxncDoxLGdyOjEsZ3M6MSxndDoxLGd1OjEsZ3c6MSxneToxLGd6OjEsaGE6MSxoYjoxLGhjOjEsaGQ6MSxoZToxLGhmOjEsaGc6MSxoaDoxLGhpOjEsaGo6MSxoazoxLGhsOjEsaG06MSxobjoxLGhvOjEsaHA6MSxocToxLGhyOjEsaHM6MSxodDoxLGh1OjEsaHY6MSxodzoxLGh5OjEsaWE6MSxpYjoxLGljOjEsaWQ6MSxpZToxLGlmOjEsaWc6MSxpaDoxLGlpOjEsaWo6MSxpazoxLGlsOjEsaW06MSxpbjoxLGlvOjEsaXA6MSxpcToxLGlyOjEsaXM6MSxpdDoxLGl1OjEsaXY6MSxpdzoxLGl4OjEsaXk6MSxpejoxLGphOjEsamM6MSxqZToxLGppOjEsamo6MSxqazoxLGpuOjEsam86MSxqdToxLGthOjEsa2I6MSxrYzoxLGtkOjEsa2U6MSxrZjoxLGtnOjEsa2g6MSxraToxLGtqOjEsa2s6MSxrbDoxLGttOjEsa246MSxrbzoxLGtwOjEsa3I6MSxrczoxLGt0OjEsa3U6MSxrdjoxLGt3OjEsa3k6MSxsYToxLGxiOjEsbGM6MSxsZDoxLGxlOjEsbGY6MSxsZzoxLGxoOjEsbGk6MSxsajoxLGxrOjEsbGw6MSxsbToxLGxuOjEsbG86MSxscDoxLGxxOjEsbHI6MSxsczoxLGx0OjEsbHU6MSxsdjoxLGx3OjEsbHg6MSxseToxLGx6OjEsbWE6MSxtYjoxLG1jOjEsbWQ6MSxtZToxLG1mOjEsbWc6MSxtaDoxLG1pOjEsbWo6MSxtazoxLG1sOjEsbW06MSxtbjoxLG1vOjEsbXA6MSxtcToxLG1yOjEsbXM6MSxtdDoxLG11OjEsbXY6MSxtdzoxLG15OjEsbmE6MSxuYjoxLG5jOjEsbmQ6MSxuZToxLG5mOjEsbmc6MSxuaDoxLG5pOjEsbmo6MSxuazoxLG5sOjEsbm06MSxubjoxLG5vOjEsbnA6MSxucToxLG5yOjEsbnM6MSxudDoxLG51OjEsbnY6MSxudzoxLG54OjEsbnk6MSxuejoxLG9hOjEsb2I6MSxvYzoxLG9kOjEsb2U6MSxvZjoxLG9nOjEsb2g6MSxvaToxLG9qOjEsb2s6MSxvbDoxLG9tOjEsb246MSxvbzoxLG9wOjEsb3E6MSxvcjoxLG9zOjEsb3Q6MSxvdToxLG92OjEsb3c6MSxveDoxLG95OjEsb3o6MSxwYToxLHBiOjEscGM6MSxwZDoxLHBlOjEscGY6MSxwZzoxLHBoOjEscGk6MSxwajoxLHBrOjEscGw6MSxwbToxLHBuOjEscG86MSxwcDoxLHByOjEscHM6MSxwdDoxLHB1OjEscHc6MSxweToxLHB6OjEscWE6MSxxZToxLHFpOjEscW86MSxxcjoxLHFzOjEscXQ6MSxxdToxLHJhOjEscmI6MSxyYzoxLHJkOjEscmU6MSxyZjoxLHJnOjEscmg6MSxyaToxLHJqOjEscms6MSxybDoxLHJtOjEscm46MSxybzoxLHJwOjEscnE6MSxycjoxLHJzOjEscnQ6MSxydToxLHJ2OjEscnc6MSxyeDoxLHJ5OjEscno6MSxzYToxLHNiOjEsc2M6MSxzZDoxLHNlOjEsc2Y6MSxzZzoxLHNoOjEsc2k6MSxzajoxLHNrOjEsc2w6MSxzbToxLHNuOjEsc286MSxzcDoxLHNxOjEsc3I6MSxzczoxLHN0OjEsc3U6MSxzdjoxLHN3OjEsc3k6MSxzejoxLHRhOjEsdGI6MSx0YzoxLHRkOjEsdGU6MSx0ZjoxLHRnOjEsdGg6MSx0aToxLHRqOjEsdGs6MSx0bDoxLHRtOjEsdG46MSx0bzoxLHRwOjEsdHI6MSx0czoxLHR0OjEsdHU6MSx0djoxLHR3OjEsdHg6MSx0eToxLHR6OjEsdWE6MSx1YjoxLHVjOjEsdWQ6MSx1ZToxLHVmOjEsdWc6MSx1aDoxLHVpOjEsdWo6MSx1azoxLHVsOjEsdW06MSx1bjoxLHVvOjEsdXA6MSx1cToxLHVyOjEsdXM6MSx1dDoxLHV1OjEsdXY6MSx1dzoxLHV4OjEsdXk6MSx1ejoxLHZhOjEsdmM6MSx2ZDoxLHZlOjEsdmc6MSx2aToxLHZsOjEsdm46MSx2bzoxLHZyOjEsdnM6MSx2dDoxLHZ1OjEsdnY6MSx2eToxLHZ6OjEsd2E6MSx3YjoxLHdjOjEsd2Q6MSx3ZToxLHdmOjEsd2c6MSx3aDoxLHdpOjEsd2o6MSx3azoxLHdsOjEsd206MSx3bjoxLHdvOjEsd3A6MSx3cjoxLHdzOjEsd3Q6MSx3dToxLHd3OjEsd3k6MSx3ejoxLHhhOjEseGI6MSx4YzoxLHhlOjEseGY6MSx4ZzoxLHhoOjEseGk6MSx4bDoxLHhtOjEseG46MSx4bzoxLHhwOjEseHE6MSx4czoxLHh0OjEseHU6MSx4djoxLHh3OjEseHg6MSx4eToxLHlhOjEseWI6MSx5YzoxLHlkOjEseWU6MSx5ZjoxLHlnOjEseWg6MSx5aToxLHlqOjEseWs6MSx5bDoxLHltOjEseW46MSx5bzoxLHlwOjEseXI6MSx5czoxLHl0OjEseXU6MSx5djoxLHl3OjEseXg6MSx5ejoxLHphOjEsemI6MSx6YzoxLHpkOjEsemU6MSx6ZzoxLHpoOjEsemk6MSx6ajoxLHprOjEsemw6MSx6bToxLHpuOjEsem86MSx6cDoxLHpxOjEsenM6MSx6dDoxLHp1OjEsenY6MSx6dzoxLHp5OjEseno6MX0sc2U9KGUse3N0cmljdDp0PSExfT17fSk9PntpZighZSlyZXR1cm5bXTtjb25zdCBuPVtdO1svKFtBLVpdezMsfVthLXpdKS9nLC8oW2Etel1bQS1aXXszLH0pL2csLyhbYS16XVtBLVpdezIsfVthLXpdKS9nLC8oW2Etel1bXGRdezIsfVthLXpdKS9nLC8oW0EtWl1bXGRdezIsfVthLXpdKS9nLC8oW2Etel1bXGRdezIsfVtBLVpdKS9nXS5mb3JFYWNoKCh0PT57Y29uc3QgYT1lLm1hdGNoKHQpO2lmKGEpcmV0dXJuIG4ucHVzaChhLmpvaW4oIiwgIikpfSkpO2NvbnN0IGE9W10sbz1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXGR8XFd8Xy9nLCIgIikucmVwbGFjZSgvXHMrL2csIiAiKS50cmltKCkuc3BsaXQoIiAiKS5qb2luKCJfIikscj1vLmxlbmd0aCxpPVsuLi5vXTtpLmZvckVhY2goKChlLHQpPT57Y29uc3Qgbj10KzE7aWYoIl8iPT1pW25dfHwiXyI9PWV8fG49PXIpcmV0dXJuITA7Y29uc3Qgbz1lK2lbdCsxXTshISFpZVtvXSYmYS5wdXNoKG8pfSkpO2NvbnN0IHM9Wy4uLiF0JiZhLmxlbmd0aDwzP1tdOmEsLi4uIXQmJm4ubGVuZ3RoPDQ/W106bl0sYz1bImJ6IiwiY2YiLCJmeCIsIm14IiwidmIiLCJ4ZCIsImd4IiwiUENJZSIsInZtIiwiTlZJRElBR2EiXTtyZXR1cm4gcy5maWx0ZXIoKGU9PiFjLmluY2x1ZGVzKGUpKSl9O2Z1bmN0aW9uIGNlKGUpe2lmKGUpcmV0dXJuKCIiK2UpLnJlcGxhY2UoL0FOR0xFIFwofFxzRGlyZWN0M0QuK3xcc0QzRC4rfFxzdnNfLitcKXxcKChEUk18UE9MQVJJU3xMTFZNKS4rfE1lc2EuK3woQVRJfElOVEVMKS0uK3xNZXRhbFxzLVxzLit8TlZJRElBXHNbXGR8XC5dKy9naSwiIikucmVwbGFjZSgvKFxzKHRpfFxkezEsMn1HQnxzdXBlcikkKS9naSwiIikucmVwbGFjZSgvXHN7Mix9L2csIiAiKS50cmltKCkucmVwbGFjZSgvKChyfGcpKHR8KSh4fHN8XGQpIHxHcmFwaGljcyB8R2VGb3JjZSB8UmFkZW9uIChIRCB8UHJvIHwpKShcZCspL2ksKCguLi5lKT0+YCR7ZVsxXX0ke2VbNl1bMF19JHtlWzZdLnNsaWNlKDEpLnJlcGxhY2UoL1xkL2csIjAiKX1zYCkpfWNvbnN0IGxlPWU9PntpZighZSlyZXR1cm47Y29uc3QgdD0oZT0+e2NvbnN0IHQ9WyJBTUQiLCJBTkdMRSIsIkFTVVMiLCJBVEkiLCJBVEkgUmFkZW9uIiwiQVRJIFRlY2hub2xvZ2llcyBJbmMiLCJBZHJlbm8iLCJBbmRyb2lkIEVtdWxhdG9yIiwiQXBwbGUiLCJBcHBsZSBHUFUiLCJBcHBsZSBNMSIsIkNoaXBzZXQiLCJEM0QxMSIsIkRpcmVjdDNEIiwiRXhwcmVzcyBDaGlwc2V0IiwiR2VGb3JjZSIsIkdlbmVyYXRpb24iLCJHZW5lcmljIFJlbmRlcmVyIiwiR29vZ2xlIiwiR29vZ2xlIFN3aWZ0U2hhZGVyIiwiR3JhcGhpY3MiLCJHcmFwaGljcyBNZWRpYSBBY2NlbGVyYXRvciIsIkhEIEdyYXBoaWNzIEZhbWlseSIsIkludGVsIiwiSW50ZWwoUikgSEQgR3JhcGhpY3MiLCJJbnRlbChSKSBVSEQgR3JhcGhpY3MiLCJJcmlzIiwiS0JMIEdyYXBoaWNzIiwiTWFsaSIsIk1lc2EiLCJNZXNhIERSSSIsIk1ldGFsIiwiTWljcm9zb2Z0IiwiTWljcm9zb2Z0IEJhc2ljIFJlbmRlciBEcml2ZXIiLCJNaWNyb3NvZnQgQ29ycG9yYXRpb24iLCJOVklESUEiLCJOVklESUEgQ29ycG9yYXRpb24iLCJOVklESUFHYW1lUmVhZHlEM0QiLCJPcGVuR0wiLCJPcGVuR0wgRW5naW5lIiwiT3BlbiBTb3VyY2UgVGVjaG5vbG9neSBDZW50ZXIiLCJQYXJhbGxlbHMiLCJQYXJhbGxlbHMgRGlzcGxheSBBZGFwdGVyIiwiUENJZSIsIlBsdXMgR3JhcGhpY3MiLCJQb3dlclZSIiwiUHJvIEdyYXBoaWNzIiwiUXVhZHJvIiwiUmFkZW9uIiwiUmFkZW9uIFBybyIsIlJhZGVvbiBQcm8gVmVnYSIsIlNhbXN1bmciLCJTU0UyIiwiVk13YXJlIiwiVk13YXJlIFNWR0EgM0QiLCJWZWdhIiwiVmlydHVhbEJveCIsIlZpcnR1YWxCb3ggR3JhcGhpY3MgQWRhcHRlciIsIlZ1bGthbiIsIlhlIEdyYXBoaWNzIiwibGx2bXBpcGUiXS5maWx0ZXIoKHQ9PigiIitlKS5pbmNsdWRlcyh0KSkpO3JldHVyblsuLi5uZXcgU2V0KHQpXS5zb3J0KCkuam9pbigiLCAiKX0pKGUpLG49dC5sZW5ndGgsYT0vXHN7Mix9fF5cc3xccyQvLnRlc3QoZSksbz0vXkFOR0xFLy50ZXN0KGUpJiYhKC9eQU5HTEUgXCgoLispXCkvLmV4ZWMoZSl8fFtdKVsxXSxyPXNlKGUse3N0cmljdDohMH0pLmpvaW4oIiwgIiksaT1uJiYhYSYmIW8scz1pJiYhci5sZW5ndGg/ImhpZ2giOmkmJnIubGVuZ3RoPyJtb2RlcmF0ZSI6ImxvdyIsYz0iaGlnaCI9PXM/IkEiOiJtb2RlcmF0ZSI9PXM/IkMiOiJGIixsPW5ldyBTZXQoW2E/ImZvdW5kIGV4dHJhIHNwYWNlcyI6dm9pZCAwLG8/ImJyb2tlbiBhbmdsZSBzdHJ1Y3R1cmUiOnZvaWQgMF0pO3JldHVybiBsLmRlbGV0ZSh2b2lkIDApLHtwYXJ0czp0LHdhcm5pbmdzOlsuLi5sXSxnaWJiZXJzOnIsY29uZmlkZW5jZTpzLGdyYWRlOmN9fSxkZT0oKCk9Pntjb25zdCBlPVtdO3JldHVybntnZXRCaW46KCk9PmUsc2VuZFRvVHJhc2g6KHQsbixhPXZvaWQgMCk9Pntjb25zdCBvPSJmdW5jdGlvbiI9PXR5cGVvZiBuPyJwcm94eSBiZWhhdmlvciBkZXRlY3RlZCI6bjtyZXR1cm4gZS5wdXNoKHtuYW1lOnQsdmFsdWU6b30pLGF9fX0pKCkse3NlbmRUb1RyYXNoOm1lfT1kZTtjb25zdCB1ZT17NzpbIkNhbWJyaWEgTWF0aCIsIkx1Y2lkYSBDb25zb2xlIl0sODpbIkFsZGhhYmkiLCJHYWR1Z2kiLCJNeWFubWFyIFRleHQiLCJOaXJtYWxhIFVJIl0sOC4xOlsiTGVlbGF3YWRlZSBVSSIsIkphdmFuZXNlIFRleHQiLCJTZWdvZSBVSSBFbW9qaSJdLDEwOlsiSG9sb0xlbnMgTURMMiBBc3NldHMiLCJTZWdvZSBNREwyIEFzc2V0cyIsIkJhaG5zY2hyaWZ0IiwiSW5rIEZyZWUiXSwxMTpbIlNlZ29lIEZsdWVudCBJY29ucyJdfSxnZT17MTAuOTpbIkhlbHZldGljYSBOZXVlIiwiR2VuZXZhIl0sIjEwLjEwIjpbIktvaGlub29yIERldmFuYWdhcmkgTWVkaXVtIiwiTHVtaW5hcmkiXSwxMC4xMTpbIlBpbmdGYW5nIEhLIExpZ2h0Il0sMTAuMTI6WyJBbWVyaWNhbiBUeXBld3JpdGVyIFNlbWlib2xkIiwiRnV0dXJhIEJvbGQiLCJTaWduUGFpbnRlci1Ib3VzZVNjcmlwdCBTZW1pYm9sZCJdLCIxMC4xMy0xMC4xNCI6WyJJbmFpTWF0aGkgQm9sZCJdLCIxMC4xNS0xMSI6WyJHYWx2amkiLCJNdWt0YU1haGVlIFJlZ3VsYXIiXSwxMjpbIkJhaSBKYW1qdXJlZSIsIkNoYWtyYSBQZXRjaCIsIkNoYXJtb25tYW4iLCJLb2RjaGFzYW4iXX0scGU9eyJNaWNyb3NvZnQgT3V0bG9vayI6WyJNUyBPdXRsb29rIl0sIkFkb2JlIEFjcm9iYXQiOlsiWldBZG9iZUYiXSxMaWJyZU9mZmljZTpbIkFtaXJpIiwiS0FDU1RPZmZpY2UiLCJMaWJlcmF0aW9uIE1vbm8iLCJTb3VyY2UgQ29kZSBQcm8iXSxPcGVuT2ZmaWNlOlsiRGVqYVZ1IFNhbnMiLCJHZW50aXVtIEJvb2sgQmFzaWMiLCJPcGVuU3ltYm9sIl19LGhlPVsuLi5PYmplY3Qua2V5cyhnZSkubWFwKChlPT5nZVtlXSkpLmZsYXQoKSwuLi5PYmplY3Qua2V5cyh1ZSkubWFwKChlPT51ZVtlXSkpLmZsYXQoKSwiQXJpbW8iLCJDaGlsYW5rYSIsIkNvdXNpbmUiLCJKb21vbGhhcmkiLCJNT05PIiwiTm90byBDb2xvciBFbW9qaSIsIlVidW50dSIsIkRhbmNpbmcgU2NyaXB0IiwiRHJvaWQgU2FucyBNb25vIiwiUm9ib3RvIiwuLi5PYmplY3Qua2V5cyhwZSkubWFwKChlPT5wZVtlXSkpLmZsYXQoKV0uc29ydCgpO2FzeW5jIGZ1bmN0aW9uIGJlKCl7dHJ5e2NvbnN0IHQ9dygpO2F3YWl0IGsodCk7Y29uc3Qgbj1ZJiZZLmRvY3VtZW50JiZZLmRvY3VtZW50LmJvZHk/WS5kb2N1bWVudDpkb2N1bWVudCxhPSJmb250LWZpbmdlcnByaW50IixvPW4uY3JlYXRlRWxlbWVudCgiZGl2Iik7by5zZXRBdHRyaWJ1dGUoImlkIixhKSxuLmJvZHkuYXBwZW5kQ2hpbGQobyk7Y29uc3R7ZW1vamlTZXQ6cixwaXhlbFNpemVTeXN0ZW1TdW06aX09KCh7ZG9jOmUsaWQ6dCxlbW9qaXM6bn0pPT57dHJ5e0MoZS5nZXRFbGVtZW50QnlJZCh0KSxUYAoJCQkJPGRpdiBpZD0icGl4ZWwtZW1vamktY29udGFpbmVyIj4KCQkJCTxzdHlsZT4KCQkJCQkucGl4ZWwtZW1vamkgewoJCQkJCQlmb250LWZhbWlseTogJHtBfTsKCQkJCQkJZm9udC1zaXplOiAyMDBweCAhaW1wb3J0YW50OwoJCQkJCQloZWlnaHQ6IGF1dG87CgkJCQkJCXBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50OwoJCQkJCQl0cmFuc2Zvcm06IHNjYWxlKDEuMDAwOTk5KTsKCQkJCQl9CgkJCQkJPC9zdHlsZT4KCQkJCQkke24ubWFwKChlPT5gPGRpdiBjbGFzcz0icGl4ZWwtZW1vamkiPiR7ZX08L2Rpdj5gKSkuam9pbigiIil9CgkJCQk8L2Rpdj4KCQkJYCk7Y29uc3QgYT1lPT4oe3dpZHRoOmUuaW5saW5lU2l6ZSxoZWlnaHQ6ZS5ibG9ja1NpemV9KSxvPW5ldyBTZXQscj1bLi4uZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCJwaXhlbC1lbW9qaSIpXS5yZWR1Y2UoKChlLHQscik9Pntjb25zdCBpPWdldENvbXB1dGVkU3R5bGUodCkscz1uW3JdLHtoZWlnaHQ6Yyx3aWR0aDpsfT1hKGkpLGQ9YCR7bH0sJHtjfWA7cmV0dXJuIG8uaGFzKGQpfHwoby5hZGQoZCksZS5hZGQocykpLGV9KSxuZXcgU2V0KSxpPWU9PitlLnJlcGxhY2UoInB4IiwiIikscz0xZS01KlsuLi5vXS5tYXAoKGU9PmUuc3BsaXQoIiwiKS5tYXAoKGU9PmkoZSkpKS5yZWR1Y2UoKChlLHQpPT5lKygrdHx8MCkpLDApKSkucmVkdWNlKCgoZSx0KT0+ZSt0KSwwKTtyZXR1cm4gZS5ib2R5LnJlbW92ZUNoaWxkKGUuZ2V0RWxlbWVudEJ5SWQoInBpeGVsLWVtb2ppLWNvbnRhaW5lciIpKSx7ZW1vamlTZXQ6Wy4uLnJdLHBpeGVsU2l6ZVN5c3RlbVN1bTpzfX1jYXRjaChlKXtyZXR1cm4gY29uc29sZS5lcnJvcihlKSx7ZW1vamlTZXQ6W10scGl4ZWxTaXplU3lzdGVtU3VtOjB9fX0pKHtkb2M6bixpZDphLGVtb2ppczp2fSl8fHt9LHM9aGUsYz1hd2FpdChhc3luYyBlPT57dHJ5e2xldCB0PVtdO2RvY3VtZW50LmZvbnRzLmNoZWNrKGAwcHggIiR7SCgpfSJgKXx8KHQ9ZS5yZWR1Y2UoKChlLHQpPT4oZG9jdW1lbnQuZm9udHMuY2hlY2soYDBweCAiJHt0fSJgKSYmZS5wdXNoKHQpLGUpKSxbXSkpO2NvbnN0IG49ZS5tYXAoKGU9Pm5ldyBGb250RmFjZShlLGBsb2NhbCgiJHtlfSIpYCkpKSxhPShhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQobi5tYXAoKGU9PmUubG9hZCgpKSkpKS5yZWR1Y2UoKChlLHQpPT4oImZ1bGZpbGxlZCI9PXQuc3RhdHVzJiZlLnB1c2godC52YWx1ZS5mYW1pbHkpLGUpKSxbXSk7cmV0dXJuWy4uLm5ldyBTZXQoWy4uLnQsLi4uYV0pXS5zb3J0KCl9Y2F0Y2goZSl7cmV0dXJuIGNvbnNvbGUuZXJyb3IoZSksW119fSkocyksbD0oKHtmb250czplLGZvbnRNYXA6dH0pPT57Y29uc3Qgbj17MTE6dFsxMV0uZmluZCgodD0+ZS5pbmNsdWRlcyh0KSkpLDEwOnRbMTBdLmZpbmQoKHQ9PmUuaW5jbHVkZXModCkpKSw4LjE6dFs4LjFdLmZpbmQoKHQ9PmUuaW5jbHVkZXModCkpKSw4OnRbOF0uZmluZCgodD0+ZS5pbmNsdWRlcyh0KSkpLDc6dFs3XS5maWx0ZXIoKHQ9PmUuaW5jbHVkZXModCkpKS5sZW5ndGg9PXRbN10ubGVuZ3RofSxhPXsiMTAsMTEsNyw4LDguMSI6IjExIiwiMTAsNyw4LDguMSI6IjEwIiwiNyw4LDguMSI6IjguMSIsIjExLDcsOCw4LjEiOiI4LjEiLCI3LDgiOiI4IiwiMTAsNyw4IjoiOCIsIjEwLDExLDcsOCI6IjgiLDc6IjciLCI3LDguMSI6IjciLCIxMCw3LDguMSI6IjciLCIxMCwxMSw3LDguMSI6IjcifVsiIitPYmplY3Qua2V5cyhuKS5zb3J0KCkuZmlsdGVyKChlPT4hIW5bZV0pKV07cmV0dXJuIGE/YFdpbmRvd3MgJHthfWA6dm9pZCAwfSkoe2ZvbnRzOmU9Yyxmb250TWFwOnVlfSl8fCgoe2ZvbnRzOmUsZm9udE1hcDp0fSk9Pntjb25zdCBuPXsxMjp0WzEyXS5maW5kKCh0PT5lLmluY2x1ZGVzKHQpKSksIjEwLjE1LTExIjp0WyIxMC4xNS0xMSJdLmZpbmQoKHQ9PmUuaW5jbHVkZXModCkpKSwiMTAuMTMtMTAuMTQiOnRbIjEwLjEzLTEwLjE0Il0uZmluZCgodD0+ZS5pbmNsdWRlcyh0KSkpLDEwLjEyOnRbMTAuMTJdLmZpbmQoKHQ9PmUuaW5jbHVkZXModCkpKSwxMC4xMTp0WzEwLjExXS5maW5kKCh0PT5lLmluY2x1ZGVzKHQpKSksIjEwLjEwIjp0WyIxMC4xMCJdLmZpbmQoKHQ9PmUuaW5jbHVkZXModCkpKSwxMC45OnRbMTAuOV0uZmlsdGVyKCh0PT5lLmluY2x1ZGVzKHQpKSkubGVuZ3RoPT10WzEwLjldLmxlbmd0aH0sYT17IjEwLjEwLDEwLjExLDEwLjEyLDEwLjEzLTEwLjE0LDEwLjE1LTExLDEwLjksMTIiOiJNb250ZXJleSIsIjEwLjEwLDEwLjExLDEwLjEyLDEwLjEzLTEwLjE0LDEwLjE1LTExLDEwLjkiOiIxMC4xNS0xMSIsIjEwLjEwLDEwLjExLDEwLjEyLDEwLjEzLTEwLjE0LDEwLjkiOiIxMC4xMy0xMC4xNCIsIjEwLjEwLDEwLjExLDEwLjEyLDEwLjkiOiJTaWVycmEiLCIxMC4xMCwxMC4xMSwxMC45IjoiRWwgQ2FwaXRhbiIsIjEwLjEwLDEwLjkiOiJZb3NlbWl0ZSIsMTAuOToiTWF2ZXJpY2tzIn1bIiIrT2JqZWN0LmtleXMobikuc29ydCgpLmZpbHRlcigoZT0+ISFuW2VdKSldO3JldHVybiBhP2BtYWNPUyAke2F9YDp2b2lkIDB9KSh7Zm9udHM6ZSxmb250TWFwOmdlfSksZD0oZT0+T2JqZWN0LmtleXMocGUpLnJlZHVjZSgoKHQsbik9Pntjb25zdCBhPXBlW25dO3JldHVybiBhLmZpbHRlcigodD0+ZS5pbmNsdWRlcyh0KSkpLmxlbmd0aD09YS5sZW5ndGg/Wy4uLnQsbl06dH0pLFtdKSkoYyksbT1hZVsiRm9udEZhY2UubG9hZCJdfHxhZVsiRm9udEZhY2UuZmFtaWx5Il18fGFlWyJGb250RmFjZS5zdGF0dXMiXXx8YWVbIlN0cmluZy5mcm9tQ29kZVBvaW50Il18fGFlWyJDU1NTdHlsZURlY2xhcmF0aW9uLnNldFByb3BlcnR5Il18fGFlWyJDU1MyUHJvcGVydGllcy5zZXRQcm9wZXJ0eSJdO3JldHVybiBmdW5jdGlvbihlLHQpe2lmKCFlfHwhdHx8IXQubGVuZ3RoKXJldHVybiExO2NvbnN0IG49dC5yZWR1Y2UoKChlLHQpPT4oZVt0XT0hMCxlKSkse30pO3JldHVybiEoISgiQ2FtYnJpYSBNYXRoImluIG58fCJOaXJtYWxhIFVJImluIG58fCJMZWVsYXdhZGVlIFVJImluIG58fCJIb2xvTGVucyBNREwyIEFzc2V0cyJpbiBufHwiU2Vnb2UgRmx1ZW50IEljb25zImluIG4pfHwiV2luZG93cyI9PWUpfHwhKCEoIkhlbHZldGljYSBOZXVlImluIG58fCJMdW1pbmFyaSJpbiBufHwiUGluZ0ZhbmcgSEsgTGlnaHQiaW4gbnx8IkZ1dHVyYSBCb2xkImluIG58fCJJbmFpTWF0aGkgQm9sZCJpbiBufHwiR2FsdmppImluIG58fCJDaGFrcmEgUGV0Y2giaW4gbil8fCJBcHBsZSI9PWUpfHwhKCEoIkFyaW1vImluIG58fCJNT05PImluIG58fCJVYnVudHUiaW4gbnx8Ik5vdG8gQ29sb3IgRW1vamkiaW4gbnx8IkRhbmNpbmcgU2NyaXB0ImluIG58fCJEcm9pZCBTYW5zIE1vbm8iaW4gbnx8IlJvYm90byJpbiBuKXx8IkxpbnV4Ij09ZSl9KHAsYykmJihNLkZPTlRTPSEwLEQuRm9udE9zSXNCYWQ9ITAsbWUoInBsYXRmb3JtIixgJHtwfSBzeXN0ZW0gYW5kIGZvbnRzIGFyZSBzdXNwaWNpb3VzYCkpLEUoe3RpbWU6dC5zdG9wKCksdGVzdDoiZm9udHMiLHBhc3NlZDohMH0pLHtmb250RmFjZUxvYWRGb250czpjLHBsYXRmb3JtVmVyc2lvbjpsLGFwcHM6ZCxlbW9qaVNldDpyLHBpeGVsU2l6ZVN5c3RlbVN1bTppLGxpZWQ6bX19Y2F0Y2goZSl7cmV0dXJuIEUoe3Rlc3Q6ImZvbnRzIixwYXNzZWQ6ITF9KSx2b2lkIFIoZSl9dmFyIGV9bGV0IGZlPSIiLFNlPSIiO2FzeW5jIGZ1bmN0aW9uIHllKCl7Y29uc3QgdD1hc3luYygpPT57Y29uc3QgZT13KCk7YXdhaXQgayhlKTtjb25zdCB0PWF3YWl0KGFzeW5jIGU9PntpZighKCJ1c2VyQWdlbnREYXRhImluIGUpKXJldHVybjtjb25zdCB0PWF3YWl0IGUudXNlckFnZW50RGF0YS5nZXRIaWdoRW50cm9weVZhbHVlcyhbInBsYXRmb3JtIiwicGxhdGZvcm1WZXJzaW9uIiwiYXJjaGl0ZWN0dXJlIiwiYml0bmVzcyIsIm1vZGVsIiwidWFGdWxsVmVyc2lvbiJdKSx7YnJhbmRzOm4sbW9iaWxlOmF9PWUudXNlckFnZW50RGF0YXx8e30sbz0oZSx0PSExKT0+ZS5maWx0ZXIoKGU9PiEvTm90Ly50ZXN0KGUuYnJhbmQpKSkubWFwKChlPT5gJHtlLmJyYW5kfSR7dD9gICR7ZS52ZXJzaW9ufWA6IiJ9YCkpLHI9ZT0+ZS5sZW5ndGg+MT9lLmZpbHRlcigoZT0+IS9DaHJvbWl1bS8udGVzdChlKSkpOmU7cmV0dXJuIHQuYnJhbmRzfHwodC5icmFuZHM9biksdC5icmFuZHNWZXJzaW9uPW8odC5icmFuZHMsITApLHQuYnJhbmRzPW8odC5icmFuZHMpLHQuYnJhbmRzVmVyc2lvbj1yKHQuYnJhbmRzVmVyc2lvbiksdC5icmFuZHM9cih0LmJyYW5kcyksdC5tb2JpbGV8fCh0Lm1vYmlsZT1hKSxPYmplY3Qua2V5cyh0KS5zb3J0KCkucmVkdWNlKCgoZSxuKT0+KGVbbl09dFtuXSxlKSkse30pfSkobmF2aWdhdG9yKS5jYXRjaCgoZT0+Y29uc29sZS5lcnJvcihlKSkpLHt3ZWJnbFZlbmRvcjpuLHdlYmdsUmVuZGVyZXI6YX09KGU9Pnt0cnl7cmV0dXJuIGUoKX1jYXRjaChlKXtyZXR1cm59fSkoKCgpPT57Y29uc3QgZT1uZXcgT2Zmc2NyZWVuQ2FudmFzKDI1NiwyNTYpLmdldENvbnRleHQoIndlYmdsIiksdD1lLmdldEV4dGVuc2lvbigiV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mbyIpO3JldHVybnt3ZWJnbFZlbmRvcjplLmdldFBhcmFtZXRlcih0LlVOTUFTS0VEX1ZFTkRPUl9XRUJHTCksd2ViZ2xSZW5kZXJlcjplLmdldFBhcmFtZXRlcih0LlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMKX19KSl8fHt9LG89KCgpPT57Y29uc3QgZT0obmV3IERhdGUpLmdldERhdGUoKSx0PShuZXcgRGF0ZSkuZ2V0TW9udGgoKSxuPURhdGUoKS5zcGxpdGAgYFszXSxhPWU9PjE9PSgiIitlKS5sZW5ndGg/YDAke2V9YDplLG89YCR7dCsxfS8ke2EoZSl9LyR7bn1gLHI9YCR7bn0tJHthKHQrMSl9LSR7YShlKX1gO3JldHVybisoKERhdGUucGFyc2UobmV3IERhdGUobykpLStuZXcgRGF0ZShyKSkvNmU0KS50b0ZpeGVkKDApfSkoKSxyPUludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZSxpPSgoKT0+e2NvbnN0IGU9WyJDb2xsYXRvciIsIkRhdGVUaW1lRm9ybWF0IiwiRGlzcGxheU5hbWVzIiwiTGlzdEZvcm1hdCIsIk51bWJlckZvcm1hdCIsIlBsdXJhbFJ1bGVzIiwiUmVsYXRpdmVUaW1lRm9ybWF0Il0ucmVkdWNlKCgoZSx0KT0+e3RyeXtjb25zdCBuPW5ldyBJbnRsW3RdO2lmKCFuKXJldHVybiBlO2NvbnN0e2xvY2FsZTphfT1uLnJlc29sdmVkT3B0aW9ucygpfHx7fTtyZXR1cm5bLi4uZSxhXX1jYXRjaCh0KXtyZXR1cm4gZX19KSxbXSk7cmV0dXJuWy4uLm5ldyBTZXQoZSldfSkoKSx7aGFyZHdhcmVDb25jdXJyZW5jeTpzLGxhbmd1YWdlOmMsbGFuZ3VhZ2VzOmwscGxhdGZvcm06ZCx1c2VyQWdlbnQ6bSxkZXZpY2VNZW1vcnk6dX09bmF2aWdhdG9yfHx7fTthd2FpdCBrKGUpO2NvbnN0e2xpZUxpc3Q6ZyxsaWVEZXRhaWw6cH09ZnVuY3Rpb24oZSl7Y29uc3QgdD1LKGUpLHtzZWFyY2hMaWVzOm59PXQ7bigoKCk9PkZ1bmN0aW9uKSx7dGFyZ2V0OlsidG9TdHJpbmciXSxpZ25vcmU6WyJjYWxsZXIiLCJhcmd1bWVudHMiXX0pLG4oKCgpPT5Xb3JrZXJOYXZpZ2F0b3IpLHt0YXJnZXQ6WyJkZXZpY2VNZW1vcnkiLCJoYXJkd2FyZUNvbmN1cnJlbmN5IiwibGFuZ3VhZ2UiLCJsYW5ndWFnZXMiLCJwbGF0Zm9ybSIsInVzZXJBZ2VudCJdfSk7Y29uc3QgYT10LmdldFByb3BzKCksbz10LmdldFByb3BzU2VhcmNoZWQoKTtyZXR1cm57bGllRGV0ZWN0b3I6dCxsaWVMaXN0Ok9iamVjdC5rZXlzKGEpLnNvcnQoKSxsaWVEZXRhaWw6YSxsaWVDb3VudDpPYmplY3Qua2V5cyhhKS5yZWR1Y2UoKChlLHQpPT5lK2FbdF0ubGVuZ3RoKSwwKSxwcm9wc1NlYXJjaGVkOm99fShzZWxmKSxoPWcubGVuZ3RoO2xldCBiO2NvbnN0IGY9KCIiK2MpLnNwbGl0KCIsIilbMF07dHJ5e2I9MS4udG9Mb2NhbGVTdHJpbmcoZnx8dm9pZCAwLHtzdHlsZToiY3VycmVuY3kiLGN1cnJlbmN5OiJVU0QiLGN1cnJlbmN5RGlzcGxheToibmFtZSIsbWluaW11bUZyYWN0aW9uRGlnaXRzOjAsbWF4aW11bUZyYWN0aW9uRGlnaXRzOjB9KX1jYXRjaChlKXt9Y29uc3QgUz0xLi50b0xvY2FsZVN0cmluZyh2b2lkIDAse3N0eWxlOiJjdXJyZW5jeSIsY3VycmVuY3k6IlVTRCIsY3VycmVuY3lEaXNwbGF5OiJuYW1lIixtaW5pbXVtRnJhY3Rpb25EaWdpdHM6MCxtYXhpbXVtRnJhY3Rpb25EaWdpdHM6MH0pLHk9Uz09YixFPW5ldyBTZXQoKCIiK2MpLnNwbGl0KCIsIikpLmhhcygiIitpKSx7aHJlZjp2LHBhdGhuYW1lOkF9PXNlbGYubG9jYXRpb258fHt9LEQ9ISh2JiZBJiYvXlwvKGRvY3N8Y3JlZXBqc3xwdWJsaWMpfFwvY3JlZXAuanMkLy50ZXN0KEEpJiZuZXcgUmVnRXhwKGAke0F9JGApLnRlc3QodikpO3JldHVybntsaWVkOmh8fCtELGxpZXM6e3Byb3RvOiEhaCYmcH0sbG9jYWxlOiIiK2ksc3lzdGVtQ3VycmVuY3lMb2NhbGU6YixlbmdpbmVDdXJyZW5jeUxvY2FsZTpTLGxvY2FsZUVudHJvcHlJc1RydXN0eTp5LGxvY2FsZUludGxFbnRyb3B5SXNUcnVzdHk6RSx0aW1lem9uZU9mZnNldDpvLHRpbWV6b25lTG9jYXRpb246cixkZXZpY2VNZW1vcnk6dSxoYXJkd2FyZUNvbmN1cnJlbmN5OnMsbGFuZ3VhZ2U6YyxsYW5ndWFnZXM6IiIrbCxwbGF0Zm9ybTpkLHVzZXJBZ2VudDptLHdlYmdsUmVuZGVyZXI6YSx3ZWJnbFZlbmRvcjpuLHVzZXJBZ2VudERhdGE6dH19LG49KGUsdCk9PmFkZEV2ZW50TGlzdGVuZXIoZSx0KSxhPWU9PnQoKS50aGVuKCh0PT5lLnBvc3RNZXNzYWdlKHQpKSk7cmV0dXJuIGUmJihnbG9iYWxUaGlzLlNlcnZpY2VXb3JrZXJHbG9iYWxTY29wZT9uKCJtZXNzYWdlIiwoZT0+YShlLnNvdXJjZSkpKTpnbG9iYWxUaGlzLlNoYXJlZFdvcmtlckdsb2JhbFNjb3BlP24oImNvbm5lY3QiLChlPT5hKGUucG9ydHNbMF0pKSk6YShzZWxmKSksZT8wOjF9YXN5bmMgZnVuY3Rpb24gRWUoKXt0cnl7Y29uc3QgZT13KCk7YXdhaXQgayhlKTtjb25zdCB0PWU9Pnt0cnl7cmV0dXJuIGUoKX1jYXRjaChlKXtyZXR1cm59fSxhPShlLHQpPT5lJiZlLl9fcHJvdG9fXy5jb25zdHJ1Y3Rvci5uYW1lPT10LG89KHtzY3JpcHRTb3VyY2U6ZX0pPT5uZXcgUHJvbWlzZSgoZT0+e2NvbnN0IG49c2V0VGltZW91dCgoKCk9PmUobnVsbCkpLDNlMyksbz10KCgoKT0+bmV3IFdvcmtlcih3b3JrZXJCbG9iKSkpO2lmKCFhKG8sIldvcmtlciIpKXJldHVybiBlKG51bGwpO28ub25tZXNzYWdlPXQ9PihvLnRlcm1pbmF0ZSgpLGNsZWFyVGltZW91dChuKSxlKHQuZGF0YSkpfSkpLGk9KHtzY3JpcHRTb3VyY2U6ZX0pPT5uZXcgUHJvbWlzZSgoZT0+e2NvbnN0IG49c2V0VGltZW91dCgoKCk9PmUobnVsbCkpLDNlMyksbz10KCgoKT0+bmV3IFNoYXJlZFdvcmtlcih3b3JrZXJCbG9iKSkpO2lmKCFhKG8sIlNoYXJlZFdvcmtlciIpKXJldHVybiBlKG51bGwpO28ucG9ydC5zdGFydCgpLG8ucG9ydC5vbm1lc3NhZ2U9dD0+KG8ucG9ydC5jbG9zZSgpLGNsZWFyVGltZW91dChuKSxlKHQuZGF0YSkpfSkpLHM9Ii4vY3JlZXAuanMiO2xldCBjO2lmKChjfHx7fSkudXNlckFnZW50fHwoU2U9IlNoYXJlZFdvcmtlckdsb2JhbFNjb3BlIixmZT0ic2hhcmVkIixjPWF3YWl0IGkoe3NjcmlwdFNvdXJjZTpzfSkuY2F0Y2goKGU9PntSKGUpLGNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlKX0pKSksKGN8fHt9KS51c2VyQWdlbnR8fChTZT0iRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGUiLGZlPSJkZWRpY2F0ZWQiLGM9YXdhaXQgbyh7c2NyaXB0U291cmNlOnN9KS5jYXRjaCgoZT0+e1IoZSksY29uc29sZS5lcnJvcihlLm1lc3NhZ2UpfSkpKSwhKGN8fHt9KS51c2VyQWdlbnQpcmV0dXJuO2Muc3lzdGVtPWQoYy51c2VyQWdlbnQpLGMuZGV2aWNlPWYoe3VzZXJBZ2VudDpjLnVzZXJBZ2VudH0pO2NvbnN0e3N5c3RlbTpsLHVzZXJBZ2VudDp1LHVzZXJBZ2VudERhdGE6ZyxwbGF0Zm9ybTpwLGRldmljZU1lbW9yeTpoLGhhcmR3YXJlQ29uY3VycmVuY3k6eX09Y3x8e30sdj0iZG9lcyBub3QgbWF0Y2ggd29ya2VyIHNjb3BlIjtpZihwIT1uYXZpZ2F0b3IucGxhdGZvcm0mJk8oIk5hdmlnYXRvci5wbGF0Zm9ybSIsdiksdSE9bmF2aWdhdG9yLnVzZXJBZ2VudCYmTygiTmF2aWdhdG9yLnVzZXJBZ2VudCIsdikseSYmeSE9bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kmJk8oIk5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5Iix2KSxoJiZoIT1uYXZpZ2F0b3IuZGV2aWNlTWVtb3J5JiZPKCJOYXZpZ2F0b3IuZGV2aWNlTWVtb3J5Iix2KSxjLmxpZXMucHJvdG8pe2NvbnN0e3Byb3RvOmV9PWMubGllcztPYmplY3Qua2V5cyhlKS5mb3JFYWNoKCh0PT57Y29uc3Qgbj1gV29ya2VyR2xvYmFsU2NvcGUuJHt0fWA7ZVt0XS5mb3JFYWNoKChlPT5PKG4sZSkpKX0pKX1jb25zdFtBLERdPW0odSxwKTtBIT1EJiYoYy5saWVkPSEwLGMubGllcy5vcz1gJHtEfSBwbGF0Zm9ybSBhbmQgJHtBfSB1c2VyIGFnZW50IGRvIG5vdCBtYXRjaGAsTygiV29ya2VyR2xvYmFsU2NvcGUiLGMubGllcy5vcykpO2NvbnN0IE09Yih7dWE6dSxvczpsLGlzQnJhdmU6ITF9KSxDPS9zYWZhcmkvaS50ZXN0KE0pfHwvaXBob25lfGlwYWQvaS50ZXN0KHUpPyJKYXZhU2NyaXB0Q29yZSI6L2ZpcmVmb3gvaS50ZXN0KHUpPyJTcGlkZXJNb25rZXkiOi9jaHJvbWUvaS50ZXN0KHUpPyJWOCI6dm9pZCAwO0MhPXImJihjLmxpZWQ9ITAsYy5saWVzLmVuZ2luZT1gJHtyfSBKUyBydW50aW1lIGFuZCAke0N9IHVzZXIgYWdlbnQgZG8gbm90IG1hdGNoYCxPKCJXb3JrZXJHbG9iYWxTY29wZSIsYy5saWVzLmVuZ2luZSkpO2NvbnN0IFQ9ZT0+KC9cZCsvLmV4ZWMoZSl8fFtdKVswXSx4PVQoTSksTj1UKGc/Zy51YUZ1bGxWZXJzaW9uOiIiKTtOJiZ4JiYhKE49PXgpJiYoYy5saWVkPSEwLGMubGllcy52ZXJzaW9uPWB1c2VyQWdlbnREYXRhIHZlcnNpb24gJHtOfSBhbmQgdXNlciBhZ2VudCB2ZXJzaW9uICR7eH0gZG8gbm90IG1hdGNoYCxPKCJXb3JrZXJHbG9iYWxTY29wZSIsYy5saWVzLnZlcnNpb24pKTtjb25zdCBJPW4mJkNTUy5zdXBwb3J0cygiYWNjZW50LWNvbG9yOiBpbml0aWFsIiksTD0oZSx0KT0+e2lmKCEvd2luZG93c3xtYWMvaS50ZXN0KGUpfHwhdD8ucGxhdGZvcm1WZXJzaW9uKXJldHVybiExO2lmKCJtYWNPUyI9PXQucGxhdGZvcm0pcmV0dXJuISFJJiYvXy8udGVzdCh0LnBsYXRmb3JtVmVyc2lvbik7Y29uc3Qgbj0oL3dpbmRvd3MgKFtcZHxcLl0rKS9pLmV4ZWMoZSl8fFtdKVsxXSxhPTEwPT0rbix7cGxhdGZvcm1WZXJzaW9uOm99PXQscj17Ni4xOiI3Iiw2LjI6IjgiLDYuMzoiOC4xIiwiMTAuMCI6IjEwIn1bb107aWYoIUkmJnIpcmV0dXJuIHIhPW47Y29uc3QgaT1vLnNwbGl0KCIuIik7aWYoMyE9aS5sZW5ndGgpcmV0dXJuITA7Y29uc3Qgcz0raVswXT4wO3JldHVybiBzJiYhYXx8IXMmJmF9O0woYy5kZXZpY2UsZykmJihjLmxpZWQ9ITAsYy5saWVzLnBsYXRmb3JtVmVyc2lvbj0icGxhdGZvcm0gdmVyc2lvbiBpcyBmYWtlIixPKCJXb3JrZXJHbG9iYWxTY29wZSIsYy5saWVzLnBsYXRmb3JtVmVyc2lvbikpLGMudXNlckFnZW50VmVyc2lvbj14LGMudXNlckFnZW50RGF0YVZlcnNpb249TixjLnVzZXJBZ2VudEVuZ2luZT1DO2NvbnN0IFA9ey4uLmxlKGMud2ViZ2xSZW5kZXJlcil8fHt9LGNvbXByZXNzZWRHUFU6Y2UoYy53ZWJnbFJlbmRlcmVyKX07cmV0dXJuIEUoe3RpbWU6ZS5zdG9wKCksdGVzdDpgJHtmZX0gd29ya2VyYCxwYXNzZWQ6ITB9KSx7Li4uYyxncHU6UCx1YVBvc3RSZWR1Y3Rpb246UyhjLnVzZXJBZ2VudCl9fWNhdGNoKGUpe3JldHVybiBFKHt0ZXN0OiJ3b3JrZXIiLHBhc3NlZDohMX0pLHZvaWQgUihlLCJ3b3JrZXJzIGZhaWxlZCBvciBibG9ja2VkIGJ5IGNsaWVudCIpfX1jb25zdCB3ZT1lPT57Y29uc3QgdD1gJHtKU09OLnN0cmluZ2lmeShlKX1gO3JldHVybigiMDAwMDAwMCIrKHQuc3BsaXQoIiIpLnJlZHVjZSgoKGUsbixhKT0+TWF0aC5pbXVsKDMxLGUpK3QuY2hhckNvZGVBdChhKXwwKSwyMTY2MTM2MjYxKT4+PjApLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC04KX0sa2U9U3RyaW5nLmZyb21DaGFyQ29kZSgyNipNYXRoLnJhbmRvbSgpKzk3KStNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgtNyksdmU9KGUsdD0iU0hBLTI1NiIpPT57Y29uc3Qgbj1gJHtKU09OLnN0cmluZ2lmeShlKX1gLGE9KG5ldyBUZXh0RW5jb2RlcikuZW5jb2RlKG4pO3JldHVybiBjcnlwdG8uc3VidGxlLmRpZ2VzdCh0LGEpLnRoZW4oKGU9PkFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoZSkpLm1hcCgoZT0+KCIwMCIrZS50b1N0cmluZygxNikpLnNsaWNlKC0yKSkpLmpvaW4oIiIpKSl9LEFlPU1hdGgucmFuZG9tKCk7YXN5bmMgZnVuY3Rpb24gRGUoKXtjb25zdCBlPW5ldyBPZmZsaW5lQXVkaW9Db250ZXh0KDEsMTAwLDQ0MTAwKSx0PWUuY3JlYXRlT3NjaWxsYXRvcigpO3JldHVybiB0LmZyZXF1ZW5jeS52YWx1ZT0wLHQuc3RhcnQoMCksZS5zdGFydFJlbmRlcmluZygpLG5ldyBQcm9taXNlKCh0PT57ZS5vbmNvbXBsZXRlPWU9Pntjb25zdCBuPWUucmVuZGVyZWRCdWZmZXIuZ2V0Q2hhbm5lbERhdGE/LigwKTtufHx0KCExKSx0KCIiK1suLi5uZXcgU2V0KG4pXSE9IjAiKX19KSkuZmluYWxseSgoKCk9PnQuZGlzY29ubmVjdCgpKSl9YXN5bmMgZnVuY3Rpb24gTWUoKXt0cnl7Y29uc3QgZT13KCk7YXdhaXQgayhlKTt0cnl7d2luZG93Lk9mZmxpbmVBdWRpb0NvbnRleHQ9T2ZmbGluZUF1ZGlvQ29udGV4dHx8d2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dH1jYXRjaChlKXt9aWYoIXdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0KXJldHVybiB2b2lkIEUoe3Rlc3Q6ImF1ZGlvIixwYXNzZWQ6ITF9KTtjb25zdCB0PWFlWyJBdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YSJdLG49YWVbIkF1ZGlvQnVmZmVyLmNvcHlGcm9tQ2hhbm5lbCJdO2xldCBhPXR8fG58fCExO2NvbnN0IG89NWUzLHI9bmV3IE9mZmxpbmVBdWRpb0NvbnRleHQoMSxvLDQ0MTAwKSxpPXIuY3JlYXRlQW5hbHlzZXIoKSxzPXIuY3JlYXRlT3NjaWxsYXRvcigpLGM9ci5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKSxsPXIuY3JlYXRlQmlxdWFkRmlsdGVyKCksZD1uZXcgRmxvYXQzMkFycmF5KGkuZnJlcXVlbmN5QmluQ291bnQpO2kuZ2V0RmxvYXRGcmVxdWVuY3lEYXRhPy4oZCk7Y29uc3QgbT1uZXcgU2V0KGQpLnNpemU7aWYobT4xKXthPSEwO08oIkFuYWx5c2VyTm9kZS5nZXRGbG9hdEZyZXF1ZW5jeURhdGEiLGBleHBlY3RlZCAtSW5maW5pdHkgKHNpbGVuY2UpIGFuZCBnb3QgJHttfSBmcmVxdWVuY2llc2ApfWNvbnN0IHU9eyJBbmFseXNlck5vZGUuY2hhbm5lbENvdW50IjpOKCgoKT0+aS5jaGFubmVsQ291bnQpKSwiQW5hbHlzZXJOb2RlLmNoYW5uZWxDb3VudE1vZGUiOk4oKCgpPT5pLmNoYW5uZWxDb3VudE1vZGUpKSwiQW5hbHlzZXJOb2RlLmNoYW5uZWxJbnRlcnByZXRhdGlvbiI6TigoKCk9PmkuY2hhbm5lbEludGVycHJldGF0aW9uKSksIkFuYWx5c2VyTm9kZS5jb250ZXh0LnNhbXBsZVJhdGUiOk4oKCgpPT5pLmNvbnRleHQuc2FtcGxlUmF0ZSkpLCJBbmFseXNlck5vZGUuZmZ0U2l6ZSI6TigoKCk9PmkuZmZ0U2l6ZSkpLCJBbmFseXNlck5vZGUuZnJlcXVlbmN5QmluQ291bnQiOk4oKCgpPT5pLmZyZXF1ZW5jeUJpbkNvdW50KSksIkFuYWx5c2VyTm9kZS5tYXhEZWNpYmVscyI6TigoKCk9PmkubWF4RGVjaWJlbHMpKSwiQW5hbHlzZXJOb2RlLm1pbkRlY2liZWxzIjpOKCgoKT0+aS5taW5EZWNpYmVscykpLCJBbmFseXNlck5vZGUubnVtYmVyT2ZJbnB1dHMiOk4oKCgpPT5pLm51bWJlck9mSW5wdXRzKSksIkFuYWx5c2VyTm9kZS5udW1iZXJPZk91dHB1dHMiOk4oKCgpPT5pLm51bWJlck9mT3V0cHV0cykpLCJBbmFseXNlck5vZGUuc21vb3RoaW5nVGltZUNvbnN0YW50IjpOKCgoKT0+aS5zbW9vdGhpbmdUaW1lQ29uc3RhbnQpKSwiQW5hbHlzZXJOb2RlLmNvbnRleHQubGlzdGVuZXIuZm9yd2FyZFgubWF4VmFsdWUiOk4oKCgpPT5JKCgoKT0+aS5jb250ZXh0Lmxpc3RlbmVyLmZvcndhcmRYLm1heFZhbHVlKSkpKSwiQmlxdWFkRmlsdGVyTm9kZS5nYWluLm1heFZhbHVlIjpOKCgoKT0+bC5nYWluLm1heFZhbHVlKSksIkJpcXVhZEZpbHRlck5vZGUuZnJlcXVlbmN5LmRlZmF1bHRWYWx1ZSI6TigoKCk9PmwuZnJlcXVlbmN5LmRlZmF1bHRWYWx1ZSkpLCJCaXF1YWRGaWx0ZXJOb2RlLmZyZXF1ZW5jeS5tYXhWYWx1ZSI6TigoKCk9PmwuZnJlcXVlbmN5Lm1heFZhbHVlKSksIkR5bmFtaWNzQ29tcHJlc3Nvck5vZGUuYXR0YWNrLmRlZmF1bHRWYWx1ZSI6TigoKCk9PmMuYXR0YWNrLmRlZmF1bHRWYWx1ZSkpLCJEeW5hbWljc0NvbXByZXNzb3JOb2RlLmtuZWUuZGVmYXVsdFZhbHVlIjpOKCgoKT0+Yy5rbmVlLmRlZmF1bHRWYWx1ZSkpLCJEeW5hbWljc0NvbXByZXNzb3JOb2RlLmtuZWUubWF4VmFsdWUiOk4oKCgpPT5jLmtuZWUubWF4VmFsdWUpKSwiRHluYW1pY3NDb21wcmVzc29yTm9kZS5yYXRpby5kZWZhdWx0VmFsdWUiOk4oKCgpPT5jLnJhdGlvLmRlZmF1bHRWYWx1ZSkpLCJEeW5hbWljc0NvbXByZXNzb3JOb2RlLnJhdGlvLm1heFZhbHVlIjpOKCgoKT0+Yy5yYXRpby5tYXhWYWx1ZSkpLCJEeW5hbWljc0NvbXByZXNzb3JOb2RlLnJlbGVhc2UuZGVmYXVsdFZhbHVlIjpOKCgoKT0+Yy5yZWxlYXNlLmRlZmF1bHRWYWx1ZSkpLCJEeW5hbWljc0NvbXByZXNzb3JOb2RlLnJlbGVhc2UubWF4VmFsdWUiOk4oKCgpPT5jLnJlbGVhc2UubWF4VmFsdWUpKSwiRHluYW1pY3NDb21wcmVzc29yTm9kZS50aHJlc2hvbGQuZGVmYXVsdFZhbHVlIjpOKCgoKT0+Yy50aHJlc2hvbGQuZGVmYXVsdFZhbHVlKSksIkR5bmFtaWNzQ29tcHJlc3Nvck5vZGUudGhyZXNob2xkLm1pblZhbHVlIjpOKCgoKT0+Yy50aHJlc2hvbGQubWluVmFsdWUpKSwiT3NjaWxsYXRvck5vZGUuZGV0dW5lLm1heFZhbHVlIjpOKCgoKT0+cy5kZXR1bmUubWF4VmFsdWUpKSwiT3NjaWxsYXRvck5vZGUuZGV0dW5lLm1pblZhbHVlIjpOKCgoKT0+cy5kZXR1bmUubWluVmFsdWUpKSwiT3NjaWxsYXRvck5vZGUuZnJlcXVlbmN5LmRlZmF1bHRWYWx1ZSI6TigoKCk9PnMuZnJlcXVlbmN5LmRlZmF1bHRWYWx1ZSkpLCJPc2NpbGxhdG9yTm9kZS5mcmVxdWVuY3kubWF4VmFsdWUiOk4oKCgpPT5zLmZyZXF1ZW5jeS5tYXhWYWx1ZSkpLCJPc2NpbGxhdG9yTm9kZS5mcmVxdWVuY3kubWluVmFsdWUiOk4oKCgpPT5zLmZyZXF1ZW5jeS5taW5WYWx1ZSkpfSxnPWU9Pm5ldyBQcm9taXNlKCh0PT57Y29uc3Qgbj1lLmNyZWF0ZUFuYWx5c2VyKCksYT1lLmNyZWF0ZU9zY2lsbGF0b3IoKSxvPWUuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7dHJ5e2EudHlwZT0idHJpYW5nbGUiLGEuZnJlcXVlbmN5LnZhbHVlPTFlNCxvLnRocmVzaG9sZC52YWx1ZT0tNTAsby5rbmVlLnZhbHVlPTQwLG8uYXR0YWNrLnZhbHVlPTB9Y2F0Y2goZSl7fXJldHVybiBhLmNvbm5lY3Qobyksby5jb25uZWN0KG4pLG8uY29ubmVjdChlLmRlc3RpbmF0aW9uKSxhLnN0YXJ0KDApLGUuc3RhcnRSZW5kZXJpbmcoKSxlLmFkZEV2ZW50TGlzdGVuZXIoImNvbXBsZXRlIiwoZT0+e3RyeXtvLmRpc2Nvbm5lY3QoKSxhLmRpc2Nvbm5lY3QoKTtjb25zdCByPW5ldyBGbG9hdDMyQXJyYXkobi5mcmVxdWVuY3lCaW5Db3VudCk7bi5nZXRGbG9hdEZyZXF1ZW5jeURhdGE/LihyKTtjb25zdCBpPW5ldyBGbG9hdDMyQXJyYXkobi5mZnRTaXplKTtyZXR1cm4iZ2V0RmxvYXRUaW1lRG9tYWluRGF0YSJpbiBuJiZuLmdldEZsb2F0VGltZURvbWFpbkRhdGEoaSksdCh7ZmxvYXRGcmVxdWVuY3lEYXRhOnIsZmxvYXRUaW1lRG9tYWluRGF0YTppLGJ1ZmZlcjplLnJlbmRlcmVkQnVmZmVyLGNvbXByZXNzb3JHYWluUmVkdWN0aW9uOm8ucmVkdWN0aW9uLnZhbHVlfHxvLnJlZHVjdGlvbn0pfWNhdGNoKGUpe3JldHVybiB0KG51bGwpfX0pKX0pKTthd2FpdCBrKGUpO2NvbnN0W3AsaF09YXdhaXQgUHJvbWlzZS5hbGwoW2cobmV3IE9mZmxpbmVBdWRpb0NvbnRleHQoMSxvLDQ0MTAwKSksRGUoKS5jYXRjaCgoKCk9PiExKSldKSx7ZmxvYXRGcmVxdWVuY3lEYXRhOmIsZmxvYXRUaW1lRG9tYWluRGF0YTpmLGJ1ZmZlcjpTLGNvbXByZXNzb3JHYWluUmVkdWN0aW9uOnl9PXB8fHt9O2F3YWl0IGsoZSk7Y29uc3Qgdj0oZSx0LG4pPT57Y29uc3QgYT1bXTtmb3IobGV0IG89dDtvPG47bysrKWEucHVzaChlW29dKTtyZXR1cm4gYX0sQT1lPT5lP1suLi5lXS5yZWR1Y2UoKChlLHQpPT5lK01hdGguYWJzKHQpKSwwKTowLEQ9QShiKSxDPUEoZiksVD1uZXcgRmxvYXQzMkFycmF5KG8pO2xldCB4PW5ldyBGbG9hdDMyQXJyYXk7UyYmKFMuY29weUZyb21DaGFubmVsPy4oVCwwKSx4PVMuZ2V0Q2hhbm5lbERhdGE/LigwKXx8W10pO2NvbnN0IFI9dihbLi4uVF0sNDUwMCw0NjAwKSxMPXYoWy4uLnhdLDQ1MDAsNDYwMCksUD1BKHYoWy4uLnhdLDQ1MDAsbykpO2gmJihhPSEwLE8oIkF1ZGlvQnVmZmVyIiwiYXVkaW8gaXMgZmFrZSIpKTtjb25zdCBCPSIiK0w9PSIiK1IsSD0iY29weUZyb21DaGFubmVsImluIEF1ZGlvQnVmZmVyLnByb3RvdHlwZTtpZihIJiYhQil7YT0hMDtPKCJBdWRpb0J1ZmZlciIsImdldENoYW5uZWxEYXRhIGFuZCBjb3B5RnJvbUNoYW5uZWwgc2FtcGxlcyBtaXNtYXRjaCIpfWNvbnN0IEY9bmV3IFNldChbLi4ueF0pLnNpemU7aWYoRj09byl7bWUoIkF1ZGlvQnVmZmVyIixgJHtGfSB1bmlxdWUgc2FtcGxlcyBvZiAke299IGlzIHRvbyBoaWdoYCl9Y29uc3QgRz0oZSx0KT0+TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKih0LWUrMSkpK2UsVj0oZSx0LG4pPT57Y29uc3R7bGVuZ3RoOmF9PXQsbz1HKDI3NSxhLTIxKSxyPW8rMTAsaT1vKzIwO3QuZ2V0Q2hhbm5lbERhdGEoMClbb109ZSx0LmdldENoYW5uZWxEYXRhKDApW3JdPWUsdC5nZXRDaGFubmVsRGF0YSgwKVtpXT1lLHQuY29weUZyb21DaGFubmVsKG4sMCk7Y29uc3Qgcz1bMD09PXQuZ2V0Q2hhbm5lbERhdGEoMClbb10/TWF0aC5yYW5kb20oKTowLDA9PT10LmdldENoYW5uZWxEYXRhKDApW3JdP01hdGgucmFuZG9tKCk6MCwwPT09dC5nZXRDaGFubmVsRGF0YSgwKVtpXT9NYXRoLnJhbmRvbSgpOjBdO3JldHVyblsuLi5uZXcgU2V0KFsuLi50LmdldENoYW5uZWxEYXRhKDApLC4uLm4sLi4uc10pXS5maWx0ZXIoKGU9PjAhPT1lKSl9LF89KGUsdCxuKT0+e3QuY29weVRvQ2hhbm5lbChuLm1hcCgoKCk9PmUpKSwwKTtjb25zdCBhPXQuZ2V0Q2hhbm5lbERhdGEoMClbMF07cmV0dXJuWy4uLnQuZ2V0Q2hhbm5lbERhdGEoMCldLm1hcCgoZT0+ZT09PWEmJmU/ZTpNYXRoLnJhbmRvbSgpKSkuZmlsdGVyKChlPT5lIT09YSkpfSxXPSgoKT0+e2NvbnN0IGU9MmUzO3RyeXtjb25zdCB0PVsuLi5uZXcgU2V0KFsuLi5WKEFlLG5ldyBBdWRpb0J1ZmZlcih7bGVuZ3RoOmUsc2FtcGxlUmF0ZTo0NDEwMH0pLG5ldyBGbG9hdDMyQXJyYXkoZSkpLC4uLl8oQWUsbmV3IEF1ZGlvQnVmZmVyKHtsZW5ndGg6ZSxzYW1wbGVSYXRlOjQ0MTAwfSksbmV3IEZsb2F0MzJBcnJheShlKSldKV07cmV0dXJuKygxIT09dC5sZW5ndGgmJnQucmVkdWNlKCgoZSx0KT0+ZSsgK3QpLDApKX1jYXRjaChlKXtyZXR1cm4gY29uc29sZS5lcnJvcihlKSwwfX0pKCl8fFsuLi5uZXcgU2V0KHguc2xpY2UoMCwxMDApKV0ucmVkdWNlKCgoZSx0KT0+ZSt0KSwwKSx6PXsiLTIwLjUzODI4NjIwOTEwNjQ0NSwxNjQ1MzcuNjQ3OTY4MjkyMjQsNTAyLjU5OTkyODMwNjgxMjIiOlsxMjQuMDQzNDc1Mjc1MTYwNzRdLCItMjAuNTM4Mjg4MTE2NDU1MDc4LDE2NDUzNy42NDc5NjgyOTIyNCw1MDIuNTk5OTI4MzA2ODEyMiI6WzEyNC4wNDM0NzUyNzUxNjA3NF0sIi0yMC41MzgyODgxMTY0NTUwNzgsMTY0NTM3LjY0Nzk1MzAzMzQ1LDUwMi41OTk5MjgzMDY4MTIyIjpbMTI0LjA0MzQ3NTI3NTE2MDc0LDEyNC4wNDM0NzUxODU3NTM3OCwxMjQuMDQzNDc1MTkzMjA0MzYsMTI0LjA0MzQ3NTIzMDQ1NzI2XSwiLTIwLjUzODI4NjIwOTEwNjQ0NSwxNjQ1MzcuNjQ4MDU5ODQ0OTcsNTAyLjU5OTkyODMwNjgxMjIiOlsxMjQuMDQzNDc1Mjc1MTYwNzRdLCItMjAuNTM4Mjg4MTE2NDU1MDc4LDE2NDUzNy42NDgwNTk4NDQ5Nyw1MDIuNTk5OTI4MzA2ODEyMiI6WzEyNC4wNDM0NzUyNzUxNjA3NCwxMjQuMDQzNDc1MTg1NzUzNzgsMTI0LjA0MzQ3NTIwMDY1NDk0LDEyNC4wNDM0NzUyMzc5MDc4NCwxMjQuMDQzNDc1MjUyODA5LDEyNC4wNDM0NzUyNjAyNTk1OCwxMjQuMDQzNDc1MjIzMDA2NjgsMTI0LjA0MzQ3NTIzMDQ1NzI2LDEyNC4wNDM0NzUyNDUzNTg0Ml0sIi0yMC41MzgyODgxMTY0NTUwNzgsMTY0ODgxLjk3Mjc5MzU3OTEsNTAyLjU5OTkwMzE3OTA4ODg3IjpbMTI0LjA0MzQ0ODg0Mzk1Njg3XSwiLTIwLjUzODI4ODExNjQ1NTA3OCwxNjQ4ODEuOTcyOTMwOTA4Miw1MDIuNTk5OTAzMTc5MDg4ODciOlsxMjQuMDQzNDQ4ODQzOTU2ODddLCItMjAuNTM4Mjg2MjA5MTA2NDQ1LDE2NDg4Mi4yMDgyNzQ4NDEzLDUwMi41OTk5MDMxNzkxMTQzNCI6WzEyNC4wNDM0NDg4NDM5Nzg3XSwiLTIwLjUzODI4ODExNjQ1NTA3OCwxNjQ4ODIuMjA4MzY2Mzk0MDQsNTAyLjU5OTkwMzE3OTExNDM0IjpbMTI0LjA0MzQ0ODg0Mzk3ODddLCItMjAuNTM4Mjg2MjA5MTA2NDQ1LDE2NDg2My40NTMxOTM2NjQ1NSw1MDIuNTk5OTAzMzQ5NTc5MSI6WzEyNC4wNDM0NDk2ODQ3NTE5OF0sIi0yMC41MzgyODgxMTY0NTUwNzgsMTY0ODYzLjQ1MzE5MzY2NDU1LDUwMi41OTk5MDMzNDk1NzkxIjpbMTI0LjA0MzQ0OTY4NDc1MTk4LDEyNC4wNDM3NTMxNDY4OTk2OSwxMjQuMDQzNDE1NDEyMDgxMjNdLCItMjAuNTM4Mjg4MTE2NDU1MDc4LDE2NDUzMS44MjY3MDU5MzI2Miw1MDIuNTk5OTI3Njc4ODY3OTciOlsxMjQuMDQzNDc1MDM3MjA3ODMsMTI0LjA0MzQ3NDk0NzgwMDg2LDEyNC4wNDM0NzQ5NTUyNTE0NCwxMjQuMDQzNDc0OTkyNTA0MzQsMTI0LjA0MzQ3NTAwNzQwNTVdLCItMjAuNTM4Mjg2MjA5MTA2NDQ1LDE2NDU0MC4xNTY3OTkzMTY0LDUwMi41OTk5MjIwOTI1ODQxNyI6WzEyNC4wNDM0NzY1NzgwODEwM10sIi0yMC41MzgyODgxMTY0NTUwNzgsMTY0NTQwLjE1Njc5OTMxNjQsNTAyLjU5OTkyMjA5MjU4NDE3IjpbMTI0LjA0MzQ3NjU3ODA4MTAzLDEyNC4wNDM0NzY1MTEwMjU4LDEyNC4wNDM0NzY1NjMxNzk4NywxMjQuMDQzNDc2NTcwNjMwNDUsMTI0LjA0Mzc4MDA0MDIyODc0XSwiLTIwLjUzODI4ODExNjQ1NTA3OCwxNjQ1NDAuMTU4MDgxMDU0Nyw1MDIuNTk5OTIyMDkyNTg0MTciOlsxMjQuMDQzNDc2NTc4MDgxMDNdLCItMjAuNTM1MjY4NzgzNTY5MzM2LDE2NDk0MC4zNjA3ODY0MzgsNTAyLjY5Njk1NDU4MjMzNzY0IjpbMTI0LjA4MDcyMjU2ODA5MV0sIi0yMC41MzgyODgxMTY0NTUwNzgsMTY0NTM4LjU1MDczOTI4ODMzLDUwMi41OTk5MzA3MTc1NDA3IjpbMTI0LjA0MzQ3NzMwNTkwOTYyXSwiLTIwLjUzNTI2ODc4MzU2OTMzNiwxNjQ5NDguMTQ1OTY1NTc2MTcsNTAyLjY5Njk1NDU4MjM2MzEiOlsxMjQuMDgwNzIyNTY4MTEyODNdLCItMjAuNTM1MjY4NzgzNTY5MzM2LDE2NDkyNi42NTkxMjYyODE3NCw1MDIuNjk2OTYxMDkzMDA2NCI6WzEyNC4wODA3Mjc2NjEwNTAzM10sIi0yMC41MzUyNjg3ODM1NjkzMzYsMTY0OTMyLjk2MTY4NTE4MDY2LDUwMi42OTY5NjE3OTk4NTQ3NiI6WzEyNC4wODA3Mjc4NzgwMjY2Nl0sIi0yMC41MzUyNjg3ODM1NjkzMzYsMTY0OTMxLjU0MjUyNjI0NTEyLDUwMi42OTY5NjE3OTk4ODAyIjpbMTI0LjA4MDcyNzg3ODA0ODQ5XSwiLTIwLjUzNTI2ODc4MzU2OTMzNiwxNjQ1OTEuOTY1OTcyOTAwNCw1MDIuNjk2OTkyNTA1OTc4NCI6WzEyNC4wODA3NDUwMDAyODMwNl0sIi0yMC41MzUyNjg3ODM1NjkzMzYsMTY0NTkwLjQxMTE0ODA3MTMsNTAyLjY5Njk5NDc3NzQ3NDIiOlsxMjQuMDgwNzQ3MDExMDA4NV0sIi0yMC41MzUyNjg3ODM1NjkzMzYsMTY0NTkwLjQxMTE1NTcwMDY4LDUwMi42OTY5OTQ3Nzc0NzQyIjpbMTI0LjA4MDc0NzAxMTAwODVdLCItMjAuNTM1MjY4NzgzNTY5MzM2LDE2NDU5My42NDI2MzkxNjAxNiw1MDIuNjk3MDA0OTAxMTkwNjciOlsxMjQuMDgwNzU1MjgyNzkwMDVdLCItMjAuNTM1MjY4NzgzNTY5MzM2LDE2NDU5NS4wMjg1Nzk3MTE5LDUwMi42OTcwMDU3ODMxNTMxNCI6WzEyNC4wODA3NTY0MzQ4MzYwOF0sIi0yMC41MzgyODgxMTY0NTUwNzgsMTY0ODYwLjk2NTc2NjkwNjc0LDUwMi42MDc1NzQ4MTE4OTE1IjpbMTI0LjA0MzQ0OTYyNzk0MTNdLCItMjAuNTM4Mjg4MTE2NDU1MDc4LDE2NDg2MC45OTM4NTgzMzc0LDUwMi42MDczNzIzODYxNDA3IjpbMTI0LjA0MzQ0OTYyODE3NDEzXSwiLTIwLjUzODI4ODExNjQ1NTA3OCwxNjQ4NjIuMTQwNzg1MjE3MjksNTAyLjU5OTkxMDA0MTMwNjQzIjpbMTI0LjA0MzQ1NzM0ODMzNjIzXSwiLTIwLjUzODI4ODExNjQ1NTA3OCwxNjQ1MzQuNTAwNDc2ODM3MTYsNTAyLjYxNTQyMTEwNDcxMDU1IjpbMTI0LjA0MzQ3NTIwMzY4MTc0XSwiLTIwLjUzODI4ODExNjQ1NTA3OCwxNjQ1MzUuMTMyNDA0MzI3NCw1MDIuNjA3OTIwMDU3MjkzMSI6WzEyNC4wNDM0NzUyMTk5Nzk4OF0sIi0yMC41MzgyODgxMTY0NTUwNzgsMTY0NTM1LjUxMTM1NjM1Mzc2LDUwMi42MDYzMzEyNjQ0ODM3NCI6WzEyNC4wNDM0NzUyMjk1MjU5NF0sIi0zMS41MDkyNjIwODQ5NjA5MzgsMTY3NzIyLjY4OTQ0NTQ5NTYsMTQ4LjQyNzE3Nzg3MjUwODc2IjpbMzUuNzM4MzI5NTkzMDkyMl0sIi0zMS41MDkyNjIwODQ5NjA5MzgsMTY3NzI4LjcyNzU2OTU4MDA4LDE0OC40MjcxODQzNDMzMzgiOlszNS43MzgzMzQwMjI0NjIzN10sIi0zMS41MDIxODk2MzYyMzA0NywxNjc3MjEuMjc1MTc3MDAxOTUsMTQ4LjQ3NTM3ODI4NjA5MzQ3IjpbMzUuNzQ5OTYwMzE0NDgyNDVdLCItMzEuNTAyMTg1ODIxNTMzMjAzLDE2NzcyNy41MjkzMTk3NjMxOCwxNDguNDc1NDIwMjM2NTg3NTIiOlszNS43NDk5NjgxNjczOTQ0XSwiLTIwLjUzODI4ODExNjQ1NTA3OCwxNjQ4NzMuODAzNjE1NTcwMDcsNTAyLjU5OTg5OTA0NDUyNTk2IjpbMTI0LjA0MzQ0ODUzMDE4MTJdLCItMjAuNTM4Mjg4MTE2NDU1MDc4LDE2NDg2My40Nzc2MDM5MTIzNSw1MDIuNTk5OTAzMzQ1MzM3MiI6WzEyNC4wNDM0NDk2ODQ5NTU3XSwiLTIwLjUzODI4ODExNjQ1NTA3OCwxNjQ4NzYuNjI0NjYwNDkxOTQsNTAyLjU5OTg5MTE5NjE3MjQiOlsxMjQuMDQzNDUzMjY1ODkxXSwiLTIwLjUzODI4ODExNjQ1NTA3OCwxNjQ4NjIuMTQ4Nzk5ODk2MjQsNTAyLjU5OTkxMDA0MTMwNjQzIjpbMTI0LjA0MzQ1NzM0ODMzNjIzXSwiLTIwLjUzODI4ODExNjQ1NTA3OCwxNjQ4OTYuNTQxNjcxNzUyOTMsNTAyLjU5OTkwNTQ5MTY0NjUiOlsxMjQuMDQzNDU4MDg4NzM3NjhdLCItMjkuODM3ODczNDU4ODYyMzA1LDE2MzIwNi40MzA1MDM4NDUyMSwwIjpbMzUuMTA4OTI3MTc1NDAyNjRdLCItMjkuODM3ODczNDU4ODYyMzA1LDE2MzIyNC42OTc4NTMwODgzOCwwIjpbMzUuMTA4OTI3NTI1NTc5OTNdLCItMjkuODM3ODY5NjQ0MTY1MDQsMTYzMjA5LjE3MjQ1NDgzMzk4LDAiOlszNS4xMDg5MzIzMjAwMjg1NF0sIi0yOS44Mzc4Njk2NDQxNjUwNCwxNjMyMDIuNzczMzY4ODM1NDUsMCI6WzM1LjEwODkzMjUzMjM3MDA5XX07VyYmKGE9ITAsTygiQXVkaW9CdWZmZXIiLCJzYW1wbGUgbm9pc2UgZGV0ZWN0ZWQiKSk7Y29uc3Qgaj16WyIiK1t5LEQsQ11dO3JldHVybiBqJiYhai5pbmNsdWRlcyhQKSYmKE0uQVVESU89ITAsbWUoIkF1ZGlvQnVmZmVyIiwic3VzcGljaW91cyBmcmVxdWVuY3kgZGF0YSIpKSxFKHt0aW1lOmUuc3RvcCgpLHRlc3Q6ImF1ZGlvIixwYXNzZWQ6ITB9KSx7dG90YWxVbmlxdWVTYW1wbGVzOkYsY29tcHJlc3NvckdhaW5SZWR1Y3Rpb246eSxmbG9hdEZyZXF1ZW5jeURhdGFTdW06RCxmbG9hdFRpbWVEb21haW5EYXRhU3VtOkMsc2FtcGxlU3VtOlAsYmluc1NhbXBsZTpMLGNvcHlTYW1wbGU6SD9SOlt2b2lkIDBdLHZhbHVlczp1LG5vaXNlOlcsbGllZDphfX1jYXRjaChlKXtyZXR1cm4gRSh7dGVzdDoiYXVkaW8iLHBhc3NlZDohMX0pLHZvaWQgUihlLCJPZmZsaW5lQXVkaW9Db250ZXh0IGZhaWxlZCBvciBibG9ja2VkIGJ5IGNsaWVudCIpfX1sZXQgQ2U9IiI7Y29uc3QgVGU9KHtjYW52YXM6ZSxjb250ZXh0OnQsc3Ryb2tlVGV4dDpuPSExLGNzc0ZvbnRGYW1pbHk6YT0iIixhcmVhOnI9e3dpZHRoOjUwLGhlaWdodDo1MH0scm91bmRzOmk9MTAsbWF4U2hhZG93Qmx1cjpzPTUwLHNlZWQ6Yz01MDAsb2Zmc2V0Omw9MjAwMTAwMDAwMSxtdWx0aXBsaWVyOmQ9MTVlM30pPT57aWYoIXQpcmV0dXJuO3QuY2xlYXJSZWN0KDAsMCxlLndpZHRoLGUuaGVpZ2h0KSxlLndpZHRoPXIud2lkdGgsZS5oZWlnaHQ9ci5oZWlnaHQsZS5zdHlsZSYmKGUuc3R5bGUuZGlzcGxheT0ibm9uZSIpO2NvbnN0IG09KCh7c2VlZDplLG9mZnNldDp0LG11bHRpcGxpZXI6bn0pPT57bGV0IGE9TnVtYmVyKGUpJU51bWJlcih0KTtyZXR1cm57Z2V0TmV4dFNlZWQ6KCk9PihhPU51bWJlcihuKSphJU51bWJlcih0KSxhKX19KSh7c2VlZDpjLG9mZnNldDpsLG11bHRpcGxpZXI6ZH0pLHtnZXROZXh0U2VlZDp1fT1tLGc9KGUsdCxuLGEpPT57Y29uc3Qgbz0oZS0xKS90KihufHwxKXx8MDtyZXR1cm4gYT9vOk1hdGguZmxvb3Iobyl9LHA9WyIjRkY2NjMzIiwiI0ZGQjM5OSIsIiNGRjMzRkYiLCIjRkZGRjk5IiwiIzAwQjNFNiIsIiNFNkIzMzMiLCIjMzM2NkU2IiwiIzk5OTk2NiIsIiM5OUZGOTkiLCIjQjM0RDREIiwiIzgwQjMwMCIsIiM4MDk5MDAiLCIjRTZCM0IzIiwiIzY2ODBCMyIsIiM2Njk5MUEiLCIjRkY5OUU2IiwiI0NDRkYxQSIsIiNGRjFBNjYiLCIjRTYzMzFBIiwiIzMzRkZDQyIsIiM2Njk5NEQiLCIjQjM2NkNDIiwiIzREODAwMCIsIiNCMzMzMDAiLCIjQ0M4MENDIiwiIzY2NjY0RCIsIiM5OTFBRkYiLCIjRTY2NkZGIiwiIzREQjNGRiIsIiMxQUIzOTkiLCIjRTY2NkIzIiwiIzMzOTkxQSIsIiNDQzk5OTkiLCIjQjNCMzFBIiwiIzAwRTY4MCIsIiM0RDgwNjYiLCIjODA5OTgwIiwiI0U2RkY4MCIsIiMxQUZGMzMiLCIjOTk5OTMzIiwiI0ZGMzM4MCIsIiNDQ0NDMDAiLCIjNjZFNjREIiwiIzREODBDQyIsIiM5OTAwQjMiLCIjRTY0RDY2IiwiIzREQjM4MCIsIiNGRjRENEQiLCIjOTlFNkU2IiwiIzY2NjZGRiJdLGg9WyhlLHQsbixhKT0+e2NvbnN0e3dpZHRoOm8saGVpZ2h0OnJ9PW47ZS5iZWdpblBhdGgoKSxlLmFyYyhnKGEoKSx0LG8pLGcoYSgpLHQsciksZyhhKCksdCxNYXRoLm1pbihvLHIpKSxnKGEoKSx0LDIqTWF0aC5QSSwhMCksZyhhKCksdCwyKk1hdGguUEksITApKSxlLnN0cm9rZSgpfSwoZSx0LG4sYSk9Pntjb25zdHt3aWR0aDpvLGhlaWdodDpyfT1uO2UuYmVnaW5QYXRoKCksZS5tb3ZlVG8oZyhhKCksdCxvKSxnKGEoKSx0LHIpKSxlLmJlemllckN1cnZlVG8oZyhhKCksdCxvKSxnKGEoKSx0LHIpLGcoYSgpLHQsbyksZyhhKCksdCxyKSxnKGEoKSx0LG8pLGcoYSgpLHQscikpLGUuc3Ryb2tlKCl9LChlLHQsbixhKT0+e2NvbnN0e3dpZHRoOm8saGVpZ2h0OnJ9PW47ZS5iZWdpblBhdGgoKSxlLm1vdmVUbyhnKGEoKSx0LG8pLGcoYSgpLHQscikpLGUucXVhZHJhdGljQ3VydmVUbyhnKGEoKSx0LG8pLGcoYSgpLHQsciksZyhhKCksdCxvKSxnKGEoKSx0LHIpKSxlLnN0cm9rZSgpfV07b3x8aC5wdXNoKCgoZSx0LG4sYSk9PntpZighKCJlbGxpcHNlImluIGUpKXJldHVybjtjb25zdHt3aWR0aDpvLGhlaWdodDpyfT1uO2UuYmVnaW5QYXRoKCksZS5lbGxpcHNlKGcoYSgpLHQsbyksZyhhKCksdCxyKSxnKGEoKSx0LE1hdGguZmxvb3Ioby8yKSksZyhhKCksdCxNYXRoLmZsb29yKHIvMikpLGcoYSgpLHQsMipNYXRoLlBJLCEwKSxnKGEoKSx0LDIqTWF0aC5QSSwhMCksZyhhKCksdCwyKk1hdGguUEksITApKSxlLnN0cm9rZSgpfSkpLG4mJmgucHVzaCgoKGUsdCxuLG8pPT57Y29uc3R7d2lkdGg6cixoZWlnaHQ6aX09bjtlLmZvbnQ9YCR7aS8yLjk5fXB4ICR7YS5yZXBsYWNlKC8haW1wb3J0YW50L2dtLCIiKX1gLGUuc3Ryb2tlVGV4dCgi8J+RvkEiLGcobygpLHQsciksZyhvKCksdCxpKSxnKG8oKSx0LHIpKX0pKSxbLi4uQXJyYXkoaSldLmZvckVhY2goKGU9PnsoKGUsdCxuLGEsbyk9Pntjb25zdHt3aWR0aDpyLGhlaWdodDppfT1uLHM9ZS5jcmVhdGVSYWRpYWxHcmFkaWVudChnKG8oKSx0LHIpLGcobygpLHQsaSksZyhvKCksdCxyKSxnKG8oKSx0LHIpLGcobygpLHQsaSksZyhvKCksdCxyKSk7cy5hZGRDb2xvclN0b3AoMCxhW2cobygpLHQsYS5sZW5ndGgpXSkscy5hZGRDb2xvclN0b3AoMSxhW2cobygpLHQsYS5sZW5ndGgpXSksZS5maWxsU3R5bGU9c30pKHQsbCxyLHAsdSksdC5zaGFkb3dCbHVyPWcodSgpLGwscywhMCksdC5zaGFkb3dDb2xvcj1wW2codSgpLGwscC5sZW5ndGgpXTsoMCxoW2codSgpLGwsaC5sZW5ndGgpXSkodCxsLHIsdSksdC5maWxsKCl9KSl9O2FzeW5jIGZ1bmN0aW9uIHhlKCl7dHJ5e2NvbnN0IGU9dygpO2F3YWl0IGsoZSk7Y29uc3QgdD1hZVsiSFRNTENhbnZhc0VsZW1lbnQudG9EYXRhVVJMIl0scj1hZVsiSFRNTENhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCJdLHM9YWVbIkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5maWxsVGV4dCJdfHxhZVsiQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELmZvbnQiXXx8YWVbIkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5nZXRJbWFnZURhdGEiXXx8YWVbIkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5zdHJva2VUZXh0Il0sYz1hZVsiU3RyaW5nLmZyb21Db2RlUG9pbnQiXTtsZXQgbD1hZVsiQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELm1lYXN1cmVUZXh0Il18fGFlWyJUZXh0TWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCJdfHxhZVsiVGV4dE1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50Il18fGFlWyJUZXh0TWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQiXXx8YWVbIlRleHRNZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQiXXx8YWVbIlRleHRNZXRyaWNzLmZvbnRCb3VuZGluZ0JveEFzY2VudCJdfHxhZVsiVGV4dE1ldHJpY3MuZm9udEJvdW5kaW5nQm94RGVzY2VudCJdfHxhZVsiVGV4dE1ldHJpY3Mud2lkdGgiXSxkPXR8fHJ8fHN8fGx8fGN8fCExLG09d2luZG93OyFpJiZZJiYobT1ZKTtjb25zdCB1PW0uZG9jdW1lbnQsZz11LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpLHA9Zy5nZXRDb250ZXh0KCIyZCIpLGg9dS5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxiPWguZ2V0Q29udGV4dCgiMmQiLHtkZXN5bmNocm9uaXplZDohMCx3aWxsUmVhZEZyZXF1ZW50bHk6ITB9KTtpZighcCl0aHJvdyBuZXcgRXJyb3IoImNhbnZhcyBjb250ZXh0IGJsb2NrZWQiKTthd2FpdCBrKGUpO2NvbnN0IGY9bz81MDo3NTtUZSh7Y2FudmFzOmcsY29udGV4dDpwLHN0cm9rZVRleHQ6ITAsY3NzRm9udEZhbWlseTpBLGFyZWE6e3dpZHRoOmYsaGVpZ2h0OmZ9LHJvdW5kczoxMH0pO2NvbnN0IFM9Zy50b0RhdGFVUkwoKTthd2FpdCBrKGUpO2NvbnN0IHk9KCgpPT57Y29uc3QgZT1bXSx0PVtdO3RyeXtjb25zdCBuPXt3aWxsUmVhZEZyZXF1ZW50bHk6ITAsZGVzeW5jaHJvbml6ZWQ6ITB9LGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIiksbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpLGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIikscz1hLmdldENvbnRleHQoIjJkIixuKSxjPW8uZ2V0Q29udGV4dCgiMmQiLG4pLGw9ci5nZXRDb250ZXh0KCIyZCIsbiksZD1pLmdldENvbnRleHQoIjJkIixuKTtpZighKHMmJmMmJmwmJmQpKXRocm93IG5ldyBFcnJvcigiY2FudmFzIGNvbnRleHQgYmxvY2tlZCIpO2Eud2lkdGg9NDAsYS5oZWlnaHQ9NDAsby53aWR0aD00MCxvLmhlaWdodD00MCxyLndpZHRoPTgsci5oZWlnaHQ9OCxpLndpZHRoPTgsaS5oZWlnaHQ9OCxbLi4uQXJyYXkoOCldLmZvckVhY2goKCh0LG4pPT5bLi4uQXJyYXkoOCldLmZvckVhY2goKCh0LGEpPT57Y29uc3Qgbz1gJHt+figyNTYqTWF0aC5yYW5kb20oKSl9LCAke35+KDI1NipNYXRoLnJhbmRvbSgpKX0sICR7fn4oMjU2Kk1hdGgucmFuZG9tKCkpfSwgMjU1YDtyZXR1cm4gbC5maWxsU3R5bGU9YHJnYmEoJHtvfSlgLGwuZmlsbFJlY3QobixhLDEsMSkscy5maWxsU3R5bGU9YHJnYmEoJHtvfSlgLHMuZmlsbFJlY3QoNSpuLDUqYSw1LDUpLGUucHVzaChvKX0pKSkpLFsuLi5BcnJheSg4KV0uZm9yRWFjaCgoKGUsbik9PlsuLi5BcnJheSg4KV0uZm9yRWFjaCgoKGUsYSk9Pntjb25zdHtkYXRhOltvLHIsaSxzXX09bC5nZXRJbWFnZURhdGEobixhLDEsMSl8fHt9LG09YCR7b30sICR7cn0sICR7aX0sICR7c31gO2QuZmlsbFN0eWxlPWByZ2JhKCR7bX0pYCxkLmZpbGxSZWN0KG4sYSwxLDEpO2NvbnN0e2RhdGE6W3UsZyxwLGhdfT1kLmdldEltYWdlRGF0YShuLGEsMSwxKXx8e30sYj1gXG5cdFx0XHRcdCR7byE9dT91OjI1NX0sXG5cdFx0XHRcdCR7ciE9Zz9nOjI1NX0sXG5cdFx0XHRcdCR7aSE9cD9wOjI1NX0sXG5cdFx0XHRcdCR7cyE9aD9oOjF9XG5cdFx0XHRgO3JldHVybiBjLmZpbGxTdHlsZT1gcmdiYSgke2J9KWAsYy5maWxsUmVjdCg1Km4sNSphLDUsNSksdC5wdXNoKG0pfSkpKSk7Y29uc3QgbT1bXSx1PW5ldyBTZXQ7Wy4uLkFycmF5KGUubGVuZ3RoKV0uZm9yRWFjaCgoKG4sYSk9Pntjb25zdCBvPWVbYV0scj10W2FdO2lmKG8hPXIpe2NvbnN0IGU9by5zcGxpdCgiLCIpLHQ9ci5zcGxpdCgiLCIpLG49W2VbMF0hPXRbMF0/InIiOiIiLGVbMV0hPXRbMV0/ImciOiIiLGVbMl0hPXRbMl0/ImIiOiIiLGVbM10hPXRbM10/ImEiOiIiXS5qb2luKCIiKTt1LmFkZChuKSxtLnB1c2goW2Esbl0pfX0pKSxDZT1hLnRvRGF0YVVSTCgpO2NvbnN0IGc9by50b0RhdGFVUkwoKTtyZXR1cm57cmdiYTp1LnNpemU/Wy4uLnVdLnNvcnQoKS5qb2luKCIsICIpOnZvaWQgMCxwaXhlbHM6bS5sZW5ndGh8fHZvaWQgMCxwaXhlbEltYWdlOmd9fWNhdGNoKGUpe3JldHVybiBjb25zb2xlLmVycm9yKGUpfX0pKCk7YXdhaXQgayhlKSxwLmZvbnQ9YDEwcHggJHtBLnJlcGxhY2UoLyFpbXBvcnRhbnQvZ20sIiIpfWA7Y29uc3QgQz1uZXcgU2V0LFQ9di5yZWR1Y2UoKChlLHQpPT57Y29uc3R7YWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ6bixhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ6YSxhY3R1YWxCb3VuZGluZ0JveExlZnQ6byxhY3R1YWxCb3VuZGluZ0JveFJpZ2h0OnIsZm9udEJvdW5kaW5nQm94QXNjZW50OmksZm9udEJvdW5kaW5nQm94RGVzY2VudDpzLHdpZHRoOmN9PXAubWVhc3VyZVRleHQodCl8fHt9LGw9W24sYSxvLHIsaSxzLGNdLmpvaW4oIiwiKTtyZXR1cm4gQy5oYXMobCl8fChDLmFkZChsKSxlLmFkZCh0KSksZX0pLG5ldyBTZXQpLHg9MWUtNSpbLi4uQ10ubWFwKChlPT5lLnNwbGl0KCIsIikucmVkdWNlKCgoZSx0KT0+ZSsoK3R8fDApKSwwKSkpLnJlZHVjZSgoKGUsdCk9PmUrdCksMCksUj03NTthd2FpdCBrKGUpLFRlKHtjYW52YXM6Zyxjb250ZXh0OnAsYXJlYTp7d2lkdGg6UixoZWlnaHQ6Un19KTtjb25zdCBOPWcudG9EYXRhVVJMKCk7YXdhaXQgayhlKSxUZSh7Y2FudmFzOmgsY29udGV4dDpiLGFyZWE6e3dpZHRoOlIsaGVpZ2h0OlJ9fSk7Y29uc3QgST1oLnRvRGF0YVVSTCgpO3AucmVzdG9yZSgpLHAuY2xlYXJSZWN0KDAsMCxnLndpZHRoLGcuaGVpZ2h0KSxnLndpZHRoPTUwLGcuaGVpZ2h0PTUwLHAuZm9udD1gNTBweCAke0EucmVwbGFjZSgvIWltcG9ydGFudC9nbSwiIil9YCxwLmZpbGxUZXh0KCJBIiw3LDM3KTtjb25zdCBMPWcudG9EYXRhVVJMKCk7cC5yZXN0b3JlKCkscC5jbGVhclJlY3QoMCwwLGcud2lkdGgsZy5oZWlnaHQpLGcud2lkdGg9NTAsZy5oZWlnaHQ9NTAscC5mb250PWAzNXB4ICR7QS5yZXBsYWNlKC8haW1wb3J0YW50L2dtLCIiKX1gLHAuZmlsbFRleHQoIvCfkb4iLDAsMzcpO2NvbnN0IFA9Zy50b0RhdGFVUkwoKTtwLmNsZWFyUmVjdCgwLDAsZy53aWR0aCxnLmhlaWdodCksKHkmJnkucGl4ZWxzfHxNYXRoLm1heCguLi5wLmdldEltYWdlRGF0YSgwLDAsOCw4KS5kYXRhKSkmJihkPSEwLE8oIkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5nZXRJbWFnZURhdGEiLCJwaXhlbCBkYXRhIG1vZGlmaWVkIikpLGcud2lkdGg9MixnLmhlaWdodD0yLHAuZmlsbFN0eWxlPSIjMDAwIixwLmZpbGxSZWN0KDAsMCxnLndpZHRoLGcuaGVpZ2h0KSxwLmZpbGxTdHlsZT0iI2ZmZiIscC5maWxsUmVjdCgyLDIsMSwxKSxwLmJlZ2luUGF0aCgpLHAuYXJjKDAsMCwyLDAsMSwhMCkscC5jbG9zZVBhdGgoKSxwLmZpbGwoKTtjb25zdCBCPXAuZ2V0SW1hZ2VEYXRhKDAsMCwyLDIpLmRhdGEuam9pbigiIiksSD17QkxJTks6WyIyNTUyNTUyNTUyNTUxOTIxOTIxOTIyNTUyNDAyNDAyNDAyNTU0ODQ4NDgyNTUiLCIyNTUyNTUyNTUyNTUxNzcxNzcxNzcyNTUyNDYyNDYyNDYyNTU1MzUzNTMyNTUiLCIyNTUyNTUyNTUyNTUxMjgxMjgxMjgyNTUxOTExOTExOTEyNTU2NDY0NjQyNTUiLCIyNTUyNTUyNTUyNTUxNzgxNzgxNzgyNTUyNDcyNDcyNDcyNTU1NjU2NTYyNTUiLCIyNTUyNTUyNTUyNTUxNzQxNzQxNzQyNTUyNDIyNDIyNDIyNTU0NzQ3NDcyNTUiLCIyNTUyNTUyNTUyNTUyMjkyMjkyMjkyNTUxMjcxMjcxMjcyNTU2ODY4NjgyNTUiLCIyNTUyNTUyNTUyNTUxOTIxOTIxOTIyNTUyNDQyNDQyNDQyNTU1MzUzNTMyNTUiXSxHRUNLTzpbIjI1NTI1NTI1NTI1NTE5MjE5MjE5MjI1NTI0MDI0MDI0MDI1NTQ4NDg0ODI1NSIsIjI1NTI1NTI1NTI1NTE5MTE5MTE5MTI1NTIzOTIzOTIzOTI1NTY0NjQ2NDI1NSIsIjI1NTI1NTI1NTI1NTE5MTE5MTE5MTI1NTIyMzIyMzIyMzI1NTYwNjA2MDI1NSIsIjI1NTI1NTI1NTI1NTE3MTE3MTE3MTI1NTIyMzIyMzIyMzI1NTYwNjA2MDI1NSJdLFdFQktJVDpbIjI1NTI1NTI1NTI1NTE4NTE4NTE4NTI1NTIzMzIzMzIzMzI1NTQ3NDc0NzI1NSIsIjI1NTI1NTI1NTI1NTE4NTE4NTE4NTI1NTIyOTIyOTIyOTI1NTQ3NDc0NzI1NSIsIjI1NTI1NTI1NTI1NTE4NTE4NTE4NTI1NTIxODIxODIxODI1NTQ3NDc0NzI1NSIsIjI1NTI1NTI1NTI1NTE5MjE5MjE5MjI1NTI0MDI0MDI0MDI1NTQ4NDg0ODI1NSIsIjI1NTI1NTI1NTI1NTE3ODE3ODE3ODI1NTI0NzI0NzI0NzI1NTU2NTY1NjI1NSIsIjI1NTI1NTI1NTI1NTE3ODE3ODE3ODI1NTI0NzI0NzI0NzI1NTU2NTY1NjI1NSIsIjI1NTI1NTI1NTI1NTE5MjE5MjE5MjI1NTI0MDI0MDI0MDI1NTQ4NDg0ODI1NSIsIjI1NTI1NTI1NTI1NTE4NjE4NjE4NjI1NTIxODIxODIxODI1NTQ2NDY0NjI1NSJdfTtELmltYWdlRGF0YUxvd0VudHJvcHk9QiwobiYmIUguQkxJTksuaW5jbHVkZXMoQil8fGEmJiFILkdFQ0tPLmluY2x1ZGVzKEIpfHxvJiYhSC5XRUJLSVQuaW5jbHVkZXMoQikpJiYoTS5DQU5WQVM9ITApLE0uQ0FOVkFTJiZtZSgiQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELmdldEltYWdlRGF0YSIsInN1c3BpY2lvdXMgcGl4ZWwgZGF0YSIpO2NvbnN0IEY9ZT0+e2NvbnN0e2FjdHVhbEJvdW5kaW5nQm94QXNjZW50OnQsYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50Om4sYWN0dWFsQm91bmRpbmdCb3hMZWZ0OmEsYWN0dWFsQm91bmRpbmdCb3hSaWdodDpvLGZvbnRCb3VuZGluZ0JveEFzY2VudDpyLGZvbnRCb3VuZGluZ0JveERlc2NlbnQ6aX09ZS5tZWFzdXJlVGV4dCgiIil8fHt9O3JldHVyblt0LG4sYSxvLHIsaV0uZmluZCgoZT0+KGV8fDApJTEhPTApKX07cmV0dXJuIGF3YWl0IGsoZSksRihwKSYmKGw9ITAsZD0hMCxPKCJDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQubWVhc3VyZVRleHQiLCJtZXRyaWMgbm9pc2UgZGV0ZWN0ZWQiKSksRSh7dGltZTplLnN0b3AoKSx0ZXN0OiJjYW52YXMgMmQiLHBhc3NlZDohMH0pLHtkYXRhVVJJOlMscGFpbnRVUkk6TixwYWludENwdVVSSTpJLHRleHRVUkk6TCxlbW9qaVVSSTpQLG1vZHM6eSx0ZXh0TWV0cmljc1N5c3RlbVN1bTp4LGxpZWRUZXh0TWV0cmljczpsLGVtb2ppU2V0OlsuLi5UXSxsaWVkOmR9fWNhdGNoKGUpe3JldHVybiBFKHt0ZXN0OiJjYW52YXMgMmQiLHBhc3NlZDohMX0pLHZvaWQgUihlKX19ZnVuY3Rpb24gUmUoKXt0cnl7Y29uc3QgZT13KCk7ZS5zdGFydCgpO2NvbnN0IHQ9KChlLHtyZXF1aXJlOlt0XX0pPT57dHJ5e2NvbnN0IHQ9ImdldENvbXB1dGVkU3R5bGUiPT1lP2dldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk6IkhUTUxFbGVtZW50LnN0eWxlIj09ZT9kb2N1bWVudC5ib2R5LnN0eWxlOiJDU1NSdWxlTGlzdC5zdHlsZSI9PWU/ZG9jdW1lbnQuc3R5bGVTaGVldHNbMF0uY3NzUnVsZXNbMF0uc3R5bGU6dm9pZCAwO2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IoImludmFsaWQgYXJndW1lbnQgc3RyaW5nIik7Y29uc3Qgbj1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCksYT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKSxvPVtdLHI9L14tLS4qJC87T2JqZWN0LmtleXModCkuZm9yRWFjaCgoZT0+e2NvbnN0IG49IWlzTmFOKCtlKSxhPXRbZV0saT1yLnRlc3QoZSkscz1yLnRlc3QoYSk7cmV0dXJuIG4mJiFzP28ucHVzaChhKTpufHxpP3ZvaWQgMDpvLnB1c2goZSl9KSk7Y29uc3QgaT17fSxzPWU9PmUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxjPWU9PmUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkrZS5zbGljZSgxKSxsPWU9PmUuc2xpY2UoMSksZD0vW0EtWl0vZztvLmZvckVhY2goKGU9PntpZihpW2VdKXJldHVybjtjb25zdCBuPWUuaW5kZXhPZigiLSIpPi0xLGE9ZC50ZXN0KGUpLG89ZS5jaGFyQXQoMCkscj1uJiYiLSI9PW8sbT1hJiZvPT1vLnRvVXBwZXJDYXNlKCk7aWYoZT1yP2woZSk6bT9jKGUpOmUsbil7Y29uc3Qgbj1lLnNwbGl0KCItIikubWFwKCgoZSx0KT0+MD09dD9lOnMoZSkpKS5qb2luKCIiKTtuIGluIHQ/aVtuXT0hMDpzKG4paW4gdCYmKGlbcyhuKV09ITApfWVsc2UgaWYoYSl7Y29uc3Qgbj1lLnJlcGxhY2UoZCwoZT0+Ii0iK2UudG9Mb3dlckNhc2UoKSkpO24gaW4gdD9pW25dPSEwOmAtJHtufWBpbiB0JiYoaVtgLSR7bn1gXT0hMCl9fSkpO3JldHVybntrZXlzOlsuLi5uZXcgU2V0KFsuLi5hLC4uLm8sLi4uT2JqZWN0LmtleXMoaSldKV0saW50ZXJmYWNlTmFtZTooIiIrbikubWF0Y2goL1xbb2JqZWN0ICguKylcXS8pWzFdfX1jYXRjaChlKXtyZXR1cm4gdm9pZCB0KGUpfX0pKCJnZXRDb21wdXRlZFN0eWxlIix7cmVxdWlyZTpbUl19KSxuPShlPT57dHJ5e2NvbnN0IHQ9WyJBY3RpdmVCb3JkZXIiLCJBY3RpdmVDYXB0aW9uIiwiQWN0aXZlVGV4dCIsIkFwcFdvcmtzcGFjZSIsIkJhY2tncm91bmQiLCJCdXR0b25Cb3JkZXIiLCJCdXR0b25GYWNlIiwiQnV0dG9uSGlnaGxpZ2h0IiwiQnV0dG9uU2hhZG93IiwiQnV0dG9uVGV4dCIsIkNhbnZhcyIsIkNhbnZhc1RleHQiLCJDYXB0aW9uVGV4dCIsIkZpZWxkIiwiRmllbGRUZXh0IiwiR3JheVRleHQiLCJIaWdobGlnaHQiLCJIaWdobGlnaHRUZXh0IiwiSW5hY3RpdmVCb3JkZXIiLCJJbmFjdGl2ZUNhcHRpb24iLCJJbmFjdGl2ZUNhcHRpb25UZXh0IiwiSW5mb0JhY2tncm91bmQiLCJJbmZvVGV4dCIsIkxpbmtUZXh0IiwiTWFyayIsIk1hcmtUZXh0IiwiTWVudSIsIk1lbnVUZXh0IiwiU2Nyb2xsYmFyIiwiVGhyZWVERGFya1NoYWRvdyIsIlRocmVlREZhY2UiLCJUaHJlZURIaWdobGlnaHQiLCJUaHJlZURMaWdodFNoYWRvdyIsIlRocmVlRFNoYWRvdyIsIlZpc2l0ZWRUZXh0IiwiV2luZG93IiwiV2luZG93RnJhbWUiLCJXaW5kb3dUZXh0Il0sbj1bImNhcHRpb24iLCJpY29uIiwibWVudSIsIm1lc3NhZ2UtYm94Iiwic21hbGwtY2FwdGlvbiIsInN0YXR1cy1iYXIiXSxhPWU9Pih7Y29sb3JzOnQubWFwKCh0PT4oZS5zZXRBdHRyaWJ1dGUoInN0eWxlIixgYmFja2dyb3VuZC1jb2xvcjogJHt0fSAhaW1wb3J0YW50YCkse1t0XTpnZXRDb21wdXRlZFN0eWxlKGUpLmJhY2tncm91bmRDb2xvcn0pKSksZm9udHM6bi5tYXAoKHQ9PntlLnNldEF0dHJpYnV0ZSgic3R5bGUiLGBmb250OiAke3R9ICFpbXBvcnRhbnRgKTtjb25zdCBuPWdldENvbXB1dGVkU3R5bGUoZSk7cmV0dXJue1t0XTpgJHtuLmZvbnRTaXplfSAke24uZm9udEZhbWlseX1gfX0pKX0pO2lmKCFlKXtlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGRvY3VtZW50LmJvZHkuYXBwZW5kKGUpO2NvbnN0IHQ9YShlKTtyZXR1cm4gZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpLHR9cmV0dXJuIGEoZSl9Y2F0Y2goZSl7cmV0dXJuIHZvaWQgUihlKX19KShRKTtyZXR1cm4gRSh7dGltZTplLnN0b3AoKSx0ZXN0OiJjb21wdXRlZCBzdHlsZSIscGFzc2VkOiEwfSkse2NvbXB1dGVkU3R5bGU6dCxzeXN0ZW06bn19Y2F0Y2goZSl7cmV0dXJuIEUoe3Rlc3Q6ImNvbXB1dGVkIHN0eWxlIixwYXNzZWQ6ITF9KSx2b2lkIFIoZSl9fWZ1bmN0aW9uIE5lKCl7Y29uc3QgZT0odCxuKT0+MD09bj90OmUobix0JW4pLHQ9KHtib2R5OmUsdHlwZTp0LHJhbmdlU3RhcnQ6bixyYW5nZUxlbjphfSk9Pntjb25zdCBvPVsuLi5BcnJheShhKV0ubWFwKCgoZSxhKT0+YEBtZWRpYShkZXZpY2UtJHt0fToke2ErPW59cHgpe2JvZHl7LS1kZXZpY2UtJHt0fToke2F9O319YCkpLmpvaW4oIiIpO2UuaW5uZXJIVE1MPWA8c3R5bGU+JHtvfTwvc3R5bGU+YDtyZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlKS5nZXRQcm9wZXJ0eVZhbHVlKGAtLWRldmljZS0ke3R9YCkudHJpbSgpfTt0cnl7Y29uc3Qgbj13KCk7bi5zdGFydCgpO2NvbnN0IGE9WS53aW5kb3cse2JvZHk6b309YS5kb2N1bWVudCx7d2lkdGg6cixhdmFpbFdpZHRoOmksaGVpZ2h0OnMsYXZhaWxIZWlnaHQ6Y309YS5zY3JlZW4sbD0hKHItaXx8cy1jKTsoc2NyZWVuLndpZHRoIT09cnx8cj44MDAmJmwpJiYoTS5JRlJBTUVfU0NSRUVOPSEwKTtjb25zdCBkPSgodCxuKT0+e2NvbnN0IGE9ZSh0LG4pO3JldHVybmAke3QvYX0vJHtuL2F9YH0pKHIscyksbT17InByZWZlcnMtcmVkdWNlZC1tb3Rpb24iOmEubWF0Y2hNZWRpYSgiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IG5vLXByZWZlcmVuY2UpIikubWF0Y2hlcz8ibm8tcHJlZmVyZW5jZSI6YS5tYXRjaE1lZGlhKCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKSIpLm1hdGNoZXM/InJlZHVjZSI6dm9pZCAwLCJwcmVmZXJzLWNvbG9yLXNjaGVtZSI6YS5tYXRjaE1lZGlhKCIocHJlZmVycy1jb2xvci1zY2hlbWU6IGxpZ2h0KSIpLm1hdGNoZXM/ImxpZ2h0IjphLm1hdGNoTWVkaWEoIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykiKS5tYXRjaGVzPyJkYXJrIjp2b2lkIDAsbW9ub2Nocm9tZTphLm1hdGNoTWVkaWEoIihtb25vY2hyb21lKSIpLm1hdGNoZXM/Im1vbm9jaHJvbWUiOmEubWF0Y2hNZWRpYSgiKG1vbm9jaHJvbWU6IDApIikubWF0Y2hlcz8ibm9uLW1vbm9jaHJvbWUiOnZvaWQgMCwiaW52ZXJ0ZWQtY29sb3JzIjphLm1hdGNoTWVkaWEoIihpbnZlcnRlZC1jb2xvcnM6IGludmVydGVkKSIpLm1hdGNoZXM/ImludmVydGVkIjphLm1hdGNoTWVkaWEoIihpbnZlcnRlZC1jb2xvcnM6IG5vbmUpIikubWF0Y2hlcz8ibm9uZSI6dm9pZCAwLCJmb3JjZWQtY29sb3JzIjphLm1hdGNoTWVkaWEoIihmb3JjZWQtY29sb3JzOiBub25lKSIpLm1hdGNoZXM/Im5vbmUiOmEubWF0Y2hNZWRpYSgiKGZvcmNlZC1jb2xvcnM6IGFjdGl2ZSkiKS5tYXRjaGVzPyJhY3RpdmUiOnZvaWQgMCwiYW55LWhvdmVyIjphLm1hdGNoTWVkaWEoIihhbnktaG92ZXI6IGhvdmVyKSIpLm1hdGNoZXM/ImhvdmVyIjphLm1hdGNoTWVkaWEoIihhbnktaG92ZXI6IG5vbmUpIikubWF0Y2hlcz8ibm9uZSI6dm9pZCAwLGhvdmVyOmEubWF0Y2hNZWRpYSgiKGhvdmVyOiBob3ZlcikiKS5tYXRjaGVzPyJob3ZlciI6YS5tYXRjaE1lZGlhKCIoaG92ZXI6IG5vbmUpIikubWF0Y2hlcz8ibm9uZSI6dm9pZCAwLCJhbnktcG9pbnRlciI6YS5tYXRjaE1lZGlhKCIoYW55LXBvaW50ZXI6IGZpbmUpIikubWF0Y2hlcz8iZmluZSI6YS5tYXRjaE1lZGlhKCIoYW55LXBvaW50ZXI6IGNvYXJzZSkiKS5tYXRjaGVzPyJjb2Fyc2UiOmEubWF0Y2hNZWRpYSgiKGFueS1wb2ludGVyOiBub25lKSIpLm1hdGNoZXM/Im5vbmUiOnZvaWQgMCxwb2ludGVyOmEubWF0Y2hNZWRpYSgiKHBvaW50ZXI6IGZpbmUpIikubWF0Y2hlcz8iZmluZSI6YS5tYXRjaE1lZGlhKCIocG9pbnRlcjogY29hcnNlKSIpLm1hdGNoZXM/ImNvYXJzZSI6YS5tYXRjaE1lZGlhKCIocG9pbnRlcjogbm9uZSkiKS5tYXRjaGVzPyJub25lIjp2b2lkIDAsImRldmljZS1hc3BlY3QtcmF0aW8iOmEubWF0Y2hNZWRpYShgKGRldmljZS1hc3BlY3QtcmF0aW86ICR7ZH0pYCkubWF0Y2hlcz9kOnZvaWQgMCwiZGV2aWNlLXNjcmVlbiI6YS5tYXRjaE1lZGlhKGAoZGV2aWNlLXdpZHRoOiAke3J9cHgpIGFuZCAoZGV2aWNlLWhlaWdodDogJHtzfXB4KWApLm1hdGNoZXM/YCR7cn0geCAke3N9YDp2b2lkIDAsImRpc3BsYXktbW9kZSI6YS5tYXRjaE1lZGlhKCIoZGlzcGxheS1tb2RlOiBmdWxsc2NyZWVuKSIpLm1hdGNoZXM/ImZ1bGxzY3JlZW4iOmEubWF0Y2hNZWRpYSgiKGRpc3BsYXktbW9kZTogc3RhbmRhbG9uZSkiKS5tYXRjaGVzPyJzdGFuZGFsb25lIjphLm1hdGNoTWVkaWEoIihkaXNwbGF5LW1vZGU6IG1pbmltYWwtdWkpIikubWF0Y2hlcz8ibWluaW1hbC11aSI6YS5tYXRjaE1lZGlhKCIoZGlzcGxheS1tb2RlOiBicm93c2VyKSIpLm1hdGNoZXM/ImJyb3dzZXIiOnZvaWQgMCwiY29sb3ItZ2FtdXQiOmEubWF0Y2hNZWRpYSgiKGNvbG9yLWdhbXV0OiBzcmdiKSIpLm1hdGNoZXM/InNyZ2IiOmEubWF0Y2hNZWRpYSgiKGNvbG9yLWdhbXV0OiBwMykiKS5tYXRjaGVzPyJwMyI6YS5tYXRjaE1lZGlhKCIoY29sb3ItZ2FtdXQ6IHJlYzIwMjApIikubWF0Y2hlcz8icmVjMjAyMCI6dm9pZCAwLG9yaWVudGF0aW9uOmEubWF0Y2hNZWRpYSgiKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpIikubWF0Y2hlcz8ibGFuZHNjYXBlIjphLm1hdGNoTWVkaWEoIihvcmllbnRhdGlvbjogcG9ydHJhaXQpIikubWF0Y2hlcz8icG9ydHJhaXQiOnZvaWQgMH07by5pbm5lckhUTUw9YFxuXHRcdDxzdHlsZT5cblx0XHRAbWVkaWEgKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IG5vLXByZWZlcmVuY2UpIHtib2R5IHstLXByZWZlcnMtcmVkdWNlZC1tb3Rpb246IG5vLXByZWZlcmVuY2V9fVxuXHRcdEBtZWRpYSAocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKSB7Ym9keSB7LS1wcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2V9fVxuXHRcdEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGxpZ2h0KSB7Ym9keSB7LS1wcmVmZXJzLWNvbG9yLXNjaGVtZTogbGlnaHR9fVxuXHRcdEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHtib2R5IHstLXByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrfX1cblx0XHRAbWVkaWEgKG1vbm9jaHJvbWUpIHtib2R5IHstLW1vbm9jaHJvbWU6IG1vbm9jaHJvbWV9fVxuXHRcdEBtZWRpYSAobW9ub2Nocm9tZTogMCkge2JvZHkgey0tbW9ub2Nocm9tZTogbm9uLW1vbm9jaHJvbWV9fVxuXHRcdEBtZWRpYSAoaW52ZXJ0ZWQtY29sb3JzOiBpbnZlcnRlZCkge2JvZHkgey0taW52ZXJ0ZWQtY29sb3JzOiBpbnZlcnRlZH19XG5cdFx0QG1lZGlhIChpbnZlcnRlZC1jb2xvcnM6IG5vbmUpIHtib2R5IHstLWludmVydGVkLWNvbG9yczogbm9uZX19XG5cdFx0QG1lZGlhIChmb3JjZWQtY29sb3JzOiBub25lKSB7Ym9keSB7LS1mb3JjZWQtY29sb3JzOiBub25lfX1cblx0XHRAbWVkaWEgKGZvcmNlZC1jb2xvcnM6IGFjdGl2ZSkge2JvZHkgey0tZm9yY2VkLWNvbG9yczogYWN0aXZlfX1cblx0XHRAbWVkaWEgKGFueS1ob3ZlcjogaG92ZXIpIHtib2R5IHstLWFueS1ob3ZlcjogaG92ZXJ9fVxuXHRcdEBtZWRpYSAoYW55LWhvdmVyOiBub25lKSB7Ym9keSB7LS1hbnktaG92ZXI6IG5vbmV9fVxuXHRcdEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7Ym9keSB7LS1ob3ZlcjogaG92ZXJ9fVxuXHRcdEBtZWRpYSAoaG92ZXI6IG5vbmUpIHtib2R5IHstLWhvdmVyOiBub25lfX1cblx0XHRAbWVkaWEgKGFueS1wb2ludGVyOiBmaW5lKSB7Ym9keSB7LS1hbnktcG9pbnRlcjogZmluZX19XG5cdFx0QG1lZGlhIChhbnktcG9pbnRlcjogY29hcnNlKSB7Ym9keSB7LS1hbnktcG9pbnRlcjogY29hcnNlfX1cblx0XHRAbWVkaWEgKGFueS1wb2ludGVyOiBub25lKSB7Ym9keSB7LS1hbnktcG9pbnRlcjogbm9uZX19XG5cdFx0QG1lZGlhIChwb2ludGVyOiBmaW5lKSB7Ym9keSB7LS1wb2ludGVyOiBmaW5lfX1cblx0XHRAbWVkaWEgKHBvaW50ZXI6IGNvYXJzZSkge2JvZHkgey0tcG9pbnRlcjogY29hcnNlfX1cblx0XHRAbWVkaWEgKHBvaW50ZXI6IG5vbmUpIHtib2R5IHstLXBvaW50ZXI6IG5vbmV9fVxuXHRcdEBtZWRpYSAoZGV2aWNlLWFzcGVjdC1yYXRpbzogJHtkfSkge2JvZHkgey0tZGV2aWNlLWFzcGVjdC1yYXRpbzogJHtkfX19XG5cdFx0QG1lZGlhIChkZXZpY2Utd2lkdGg6ICR7cn1weCkgYW5kIChkZXZpY2UtaGVpZ2h0OiAke3N9cHgpIHtib2R5IHstLWRldmljZS1zY3JlZW46ICR7cn0geCAke3N9fX1cblx0XHRAbWVkaWEgKGRpc3BsYXktbW9kZTogZnVsbHNjcmVlbikge2JvZHkgey0tZGlzcGxheS1tb2RlOiBmdWxsc2NyZWVufX1cblx0XHRAbWVkaWEgKGRpc3BsYXktbW9kZTogc3RhbmRhbG9uZSkge2JvZHkgey0tZGlzcGxheS1tb2RlOiBzdGFuZGFsb25lfX1cblx0XHRAbWVkaWEgKGRpc3BsYXktbW9kZTogbWluaW1hbC11aSkge2JvZHkgey0tZGlzcGxheS1tb2RlOiBtaW5pbWFsLXVpfX1cblx0XHRAbWVkaWEgKGRpc3BsYXktbW9kZTogYnJvd3Nlcikge2JvZHkgey0tZGlzcGxheS1tb2RlOiBicm93c2VyfX1cblx0XHRAbWVkaWEgKGNvbG9yLWdhbXV0OiBzcmdiKSB7Ym9keSB7LS1jb2xvci1nYW11dDogc3JnYn19XG5cdFx0QG1lZGlhIChjb2xvci1nYW11dDogcDMpIHtib2R5IHstLWNvbG9yLWdhbXV0OiBwM319XG5cdFx0QG1lZGlhIChjb2xvci1nYW11dDogcmVjMjAyMCkge2JvZHkgey0tY29sb3ItZ2FtdXQ6IHJlYzIwMjB9fVxuXHRcdEBtZWRpYSAob3JpZW50YXRpb246IGxhbmRzY2FwZSkge2JvZHkgey0tb3JpZW50YXRpb246IGxhbmRzY2FwZX19XG5cdFx0QG1lZGlhIChvcmllbnRhdGlvbjogcG9ydHJhaXQpIHtib2R5IHstLW9yaWVudGF0aW9uOiBwb3J0cmFpdH19XG5cdFx0PC9zdHlsZT5cblx0XHRgO2NvbnN0IHU9Z2V0Q29tcHV0ZWRTdHlsZShvKSxnPXsicHJlZmVycy1yZWR1Y2VkLW1vdGlvbiI6dS5nZXRQcm9wZXJ0eVZhbHVlKCItLXByZWZlcnMtcmVkdWNlZC1tb3Rpb24iKS50cmltKCl8fHZvaWQgMCwicHJlZmVycy1jb2xvci1zY2hlbWUiOnUuZ2V0UHJvcGVydHlWYWx1ZSgiLS1wcmVmZXJzLWNvbG9yLXNjaGVtZSIpLnRyaW0oKXx8dm9pZCAwLG1vbm9jaHJvbWU6dS5nZXRQcm9wZXJ0eVZhbHVlKCItLW1vbm9jaHJvbWUiKS50cmltKCl8fHZvaWQgMCwiaW52ZXJ0ZWQtY29sb3JzIjp1LmdldFByb3BlcnR5VmFsdWUoIi0taW52ZXJ0ZWQtY29sb3JzIikudHJpbSgpfHx2b2lkIDAsImZvcmNlZC1jb2xvcnMiOnUuZ2V0UHJvcGVydHlWYWx1ZSgiLS1mb3JjZWQtY29sb3JzIikudHJpbSgpfHx2b2lkIDAsImFueS1ob3ZlciI6dS5nZXRQcm9wZXJ0eVZhbHVlKCItLWFueS1ob3ZlciIpLnRyaW0oKXx8dm9pZCAwLGhvdmVyOnUuZ2V0UHJvcGVydHlWYWx1ZSgiLS1ob3ZlciIpLnRyaW0oKXx8dm9pZCAwLCJhbnktcG9pbnRlciI6dS5nZXRQcm9wZXJ0eVZhbHVlKCItLWFueS1wb2ludGVyIikudHJpbSgpfHx2b2lkIDAscG9pbnRlcjp1LmdldFByb3BlcnR5VmFsdWUoIi0tcG9pbnRlciIpLnRyaW0oKXx8dm9pZCAwLCJkZXZpY2UtYXNwZWN0LXJhdGlvIjp1LmdldFByb3BlcnR5VmFsdWUoIi0tZGV2aWNlLWFzcGVjdC1yYXRpbyIpLnRyaW0oKXx8dm9pZCAwLCJkZXZpY2Utc2NyZWVuIjp1LmdldFByb3BlcnR5VmFsdWUoIi0tZGV2aWNlLXNjcmVlbiIpLnRyaW0oKXx8dm9pZCAwLCJkaXNwbGF5LW1vZGUiOnUuZ2V0UHJvcGVydHlWYWx1ZSgiLS1kaXNwbGF5LW1vZGUiKS50cmltKCl8fHZvaWQgMCwiY29sb3ItZ2FtdXQiOnUuZ2V0UHJvcGVydHlWYWx1ZSgiLS1jb2xvci1nYW11dCIpLnRyaW0oKXx8dm9pZCAwLG9yaWVudGF0aW9uOnUuZ2V0UHJvcGVydHlWYWx1ZSgiLS1vcmllbnRhdGlvbiIpLnRyaW0oKXx8dm9pZCAwfSxwPSgoe2JvZHk6ZSx3aWR0aDpuLGhlaWdodDphfSk9PntsZXQgbz10KHtib2R5OmUsdHlwZToid2lkdGgiLHJhbmdlU3RhcnQ6bixyYW5nZUxlbjoxfSkscj10KHtib2R5OmUsdHlwZToiaGVpZ2h0IixyYW5nZVN0YXJ0OmEscmFuZ2VMZW46MX0pO2lmKG8mJnIpcmV0dXJue3dpZHRoOm4saGVpZ2h0OmF9O2NvbnN0IGk9MWUzO3JldHVyblsuLi5BcnJheSgxMCldLmZpbmQoKChuLGEpPT4ob3x8KG89dCh7Ym9keTplLHR5cGU6IndpZHRoIixyYW5nZVN0YXJ0OmEqaSxyYW5nZUxlbjppfSkpLHJ8fChyPXQoe2JvZHk6ZSx0eXBlOiJoZWlnaHQiLHJhbmdlU3RhcnQ6YSppLHJhbmdlTGVuOml9KSksbyYmcikpKSx7d2lkdGg6K28saGVpZ2h0OityfX0pKHtib2R5Om8sd2lkdGg6cixoZWlnaHQ6c30pO3JldHVybiBFKHt0aW1lOm4uc3RvcCgpLHRlc3Q6ImNzcyBtZWRpYSIscGFzc2VkOiEwfSkse21lZGlhQ1NTOmcsbWF0Y2hNZWRpYUNTUzptLHNjcmVlblF1ZXJ5OnB9fWNhdGNoKGUpe3JldHVybiBFKHt0ZXN0OiJjc3MgbWVkaWEiLHBhc3NlZDohMX0pLHZvaWQgUihlKX19ZnVuY3Rpb24gSWUoKXt0cnl7Y29uc3QgZT13KCk7ZS5zdGFydCgpO2NvbnN0IHQ9W107Zm9yKGNvbnN0IGUgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KXQucHVzaChlKTtyZXR1cm4gRSh7dGltZTplLnN0b3AoKSx0ZXN0OiJodG1sIGVsZW1lbnQiLHBhc3NlZDohMH0pLHtrZXlzOnR9fWNhdGNoKGUpe3JldHVybiBFKHt0ZXN0OiJodG1sIGVsZW1lbnQiLHBhc3NlZDohMX0pLHZvaWQgUihlKX19YXN5bmMgZnVuY3Rpb24gTGUoKXt0cnl7Y29uc3QgZT13KCk7YXdhaXQgayhlKTtjb25zdCB0PWU9Pih7Ym90dG9tOmUuYm90dG9tLGhlaWdodDplLmhlaWdodCxsZWZ0OmUubGVmdCxyaWdodDplLnJpZ2h0LHdpZHRoOmUud2lkdGgsdG9wOmUudG9wLHg6ZS54LHk6ZS55fSk7bGV0IG89YWVbIkVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMiXXx8YWVbIkVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0Il18fGFlWyJSYW5nZS5nZXRDbGllbnRSZWN0cyJdfHxhZVsiUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0Il18fGFlWyJTdHJpbmcuZnJvbUNvZGVQb2ludCJdfHwhMTtjb25zdCByPVkmJlkuZG9jdW1lbnQmJlkuZG9jdW1lbnQuYm9keT9ZLmRvY3VtZW50OmRvY3VtZW50LGk9ZT0+e2xldCB0O3JldHVybiBhZVsiRWxlbWVudC5nZXRDbGllbnRSZWN0cyJdP2FlWyJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCJdP2FlWyJSYW5nZS5nZXRDbGllbnRSZWN0cyJdPyh0PXIuY3JlYXRlUmFuZ2UoKSx0LnNlbGVjdE5vZGUoZSksdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk6KHQ9ci5jcmVhdGVSYW5nZSgpLHQuc2VsZWN0Tm9kZShlKSx0LmdldENsaWVudFJlY3RzKClbMF0pOmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk6ZS5nZXRDbGllbnRSZWN0cygpWzBdfSxzPWAke2tlfS1jbGllbnQtcmVjdHMtZGl2YCxjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO2Muc2V0QXR0cmlidXRlKCJpZCIscyksci5ib2R5LmFwcGVuZENoaWxkKGMpLEMoYyxUYAoJCTxkaXYgaWQ9IiR7c30iPgoJCQk8c3R5bGU+CgkJCS5yZWN0LWdob3N0LAoJCQkucmVjdC1rbm93biB7CgkJCQl0b3A6IDA7CgkJCQlsZWZ0OiAwOwoJCQkJcG9zaXRpb246IGFic29sdXRlOwoJCQkJdmlzaWJpbGl0eTogaGlkZGVuOwoJCQl9CgkJCS5yZWN0LWtub3duIHsKCQkJCXdpZHRoOiAxMDBweDsKCQkJCWhlaWdodDogMTAwcHg7CgkJCQl0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7CgkJCX0KCQkJLnJlY3QtZ2hvc3QgewoJCQkJd2lkdGg6IDA7CgkJCQloZWlnaHQ6IDA7CgkJCX0KCQkJPC9zdHlsZT4KCQkJPGRpdiBjbGFzcz0icmVjdC1rbm93biI+PC9kaXY+CgkJCTxkaXYgY2xhc3M9InJlY3QtZ2hvc3QiPjwvZGl2PgoJCQk8ZGl2IHN0eWxlPSJwZXJzcGVjdGl2ZToxMDBweDt3aWR0aDoxMDAwLjA5OSU7IiBpZD0icmVjdC1jb250YWluZXIiPgoJCQkJPHN0eWxlPgoJCQkJLnJlY3RzIHsKCQkJCQl3aWR0aDogMTAwMCU7CgkJCQkJaGVpZ2h0OiAxMDAwJTsKCQkJCQltYXgtd2lkdGg6IDEwMDAlOwoJCQkJfQoJCQkJLmFic29sdXRlIHsKCQkJCQlwb3NpdGlvbjogYWJzb2x1dGU7CgkJCQl9CgkJCQkjY1JlY3QxIHsKCQkJCQlib3JkZXI6IHNvbGlkIDIuNzE1cHg7CgkJCQkJYm9yZGVyLWNvbG9yOiAjRjcyNTg1OwoJCQkJCXBhZGRpbmc6IDMuOThweDsKCQkJCQltYXJnaW4tbGVmdDogMTIuMTJweDsKCQkJCX0KCQkJCSNjUmVjdDIgewoJCQkJCWJvcmRlcjogc29saWQgMnB4OwoJCQkJCWJvcmRlci1jb2xvcjogIzcyMDlCNzsKCQkJCQlmb250LXNpemU6IDMwcHg7CgkJCQkJbWFyZ2luLXRvcDogMjBweDsKCQkJCQlwYWRkaW5nOiAzLjk4cHg7CgkJCQkJdHJhbnNmb3JtOiBza2V3WSgyMy4xNzUzMjE4ZGVnKSByb3RhdGUzZCgxMC4wMDA5OSwgOTAsIDAuMTAwMDAwMDAwMDAwMDA5LCA2MDAwMDAwMDAwMDAwOC4wMDAwMDAwOWRlZyk7CgkJCQl9CgkJCQkjY1JlY3QzIHsKCQkJCQlib3JkZXI6IHNvbGlkIDIuODlweDsKCQkJCQlib3JkZXItY29sb3I6ICMzQTBDQTM7CgkJCQkJZm9udC1zaXplOiA0NXB4OwoJCQkJCXRyYW5zZm9ybTogc2tld1koLTIzLjE3NTMyMThkZWcpIHNjYWxlKDEwOTkuMDAwMDAwMDA5OSwgMS44OSkgbWF0cml4KDEuMTEsIDIuMDAwMSwgLTEuMDAwMSwgMS4wMDksIDE1MCwgOTQuNCk7CgkJCQkJbWFyZ2luLXRvcDogNTBweDsKCQkJCX0KCQkJCSNjUmVjdDQgewoJCQkJCWJvcmRlcjogc29saWQgMnB4OwoJCQkJCWJvcmRlci1jb2xvcjogIzQzNjFFRTsKCQkJCQl0cmFuc2Zvcm06IG1hdHJpeCgxLjExLCAyLjAwMDEsIC0xLjAwMDEsIDEuMDA5LCAxNTAsIDk0LjQpOwoJCQkJCW1hcmdpbi10b3A6IDExLjEzMzFweDsKCQkJCQltYXJnaW4tbGVmdDogMTIuMTIxMnB4OwoJCQkJCXBhZGRpbmc6IDQuNDU0NXB4OwoJCQkJCWxlZnQ6IDIzOS40MTQxcHg7CgkJCQkJdG9wOiA4LjUwNTBweDsKCQkJCX0KCQkJCSNjUmVjdDUgewoJCQkJCWJvcmRlcjogc29saWQgMnB4OwoJCQkJCWJvcmRlci1jb2xvcjogIzRDQzlGMDsKCQkJCQltYXJnaW4tbGVmdDogNDIuMzk1cHQ7CgkJCQl9CgkJCQkjY1JlY3Q2IHsKCQkJCQlib3JkZXI6IHNvbGlkIDJweDsKCQkJCQlib3JkZXItY29sb3I6ICNGNzI1ODU7CgkJCQkJdHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSgxMjg5MHB4KSB0cmFuc2xhdGVaKDEwMS41cHgpOwoJCQkJCXBhZGRpbmc6IDEycHg7CgkJCQl9CgkJCQkjY1JlY3Q3IHsKCQkJCQltYXJnaW4tdG9wOiAtMzUwLjU1MnB4OwoJCQkJCW1hcmdpbi1sZWZ0OiAwLjkwOTlyZW07CgkJCQkJYm9yZGVyOiBzb2xpZCAycHg7CgkJCQkJYm9yZGVyLWNvbG9yOiAjNDM2MUVFOwoJCQkJfQoJCQkJI2NSZWN0OCB7CgkJCQkJbWFyZ2luLXRvcDogLTE1MC41NTJweDsKCQkJCQltYXJnaW4tbGVmdDogMTUuOTA5OXJlbTsKCQkJCQlib3JkZXI6IHNvbGlkIDJweDsKCQkJCQlib3JkZXItY29sb3I6ICMzQTBDQTM7CgkJCQl9CgkJCQkjY1JlY3Q5IHsKCQkJCQltYXJnaW4tdG9wOiAtMTEwLjU1MnB4OwoJCQkJCW1hcmdpbi1sZWZ0OiAxNS45MDk5cmVtOwoJCQkJCWJvcmRlcjogc29saWQgMnB4OwoJCQkJCWJvcmRlci1jb2xvcjogIzcyMDlCNzsKCQkJCX0KCQkJCSNjUmVjdDEwIHsKCQkJCQltYXJnaW4tdG9wOiAtMzE1LjU1MnB4OwoJCQkJCW1hcmdpbi1sZWZ0OiAxNS45MDk5cmVtOwoJCQkJCWJvcmRlcjogc29saWQgMnB4OwoJCQkJCWJvcmRlci1jb2xvcjogI0Y3MjU4NTsKCQkJCX0KCQkJCSNjUmVjdDExIHsKCQkJCQl3aWR0aDogMTBweDsKCQkJCQloZWlnaHQ6IDEwcHg7CgkJCQkJbWFyZ2luLWxlZnQ6IDE1LjAwMDAwMDkwOTlyZW07CgkJCQkJYm9yZGVyOiBzb2xpZCAycHg7CgkJCQkJYm9yZGVyLWNvbG9yOiAjRjcyNTg1OwoJCQkJfQoJCQkJI2NSZWN0MTIgewoJCQkJCXdpZHRoOiAxMHB4OwoJCQkJCWhlaWdodDogMTBweDsKCQkJCQltYXJnaW4tbGVmdDogMTUuMDAwMDAwOTA5OXJlbTsKCQkJCQlib3JkZXI6IHNvbGlkIDJweDsKCQkJCQlib3JkZXItY29sb3I6ICNGNzI1ODU7CgkJCQl9CgkJCQkjcmVjdC1jb250YWluZXIgLnNoaWZ0LWRvbS1yZWN0IHsKCQkJCQl0b3A6IDFweCAhaW1wb3J0YW50OwoJCQkJCWxlZnQ6IDFweCAhaW1wb3J0YW50OwoJCQkJfQoJCQkJPC9zdHlsZT4KCQkJCTxkaXYgaWQ9ImNSZWN0MSIgY2xhc3M9InJlY3RzIj48L2Rpdj4KCQkJCTxkaXYgaWQ9ImNSZWN0MiIgY2xhc3M9InJlY3RzIj48L2Rpdj4KCQkJCTxkaXYgaWQ9ImNSZWN0MyIgY2xhc3M9InJlY3RzIj48L2Rpdj4KCQkJCTxkaXYgaWQ9ImNSZWN0NCIgY2xhc3M9InJlY3RzIGFic29sdXRlIj48L2Rpdj4KCQkJCTxkaXYgaWQ9ImNSZWN0NSIgY2xhc3M9InJlY3RzIj48L2Rpdj4KCQkJCTxkaXYgaWQ9ImNSZWN0NiIgY2xhc3M9InJlY3RzIj48L2Rpdj4KCQkJCTxkaXYgaWQ9ImNSZWN0NyIgY2xhc3M9InJlY3RzIGFic29sdXRlIj48L2Rpdj4KCQkJCTxkaXYgaWQ9ImNSZWN0OCIgY2xhc3M9InJlY3RzIGFic29sdXRlIj48L2Rpdj4KCQkJCTxkaXYgaWQ9ImNSZWN0OSIgY2xhc3M9InJlY3RzIGFic29sdXRlIj48L2Rpdj4KCQkJCTxkaXYgaWQ9ImNSZWN0MTAiIGNsYXNzPSJyZWN0cyBhYnNvbHV0ZSI+PC9kaXY+CgkJCQk8ZGl2IGlkPSJjUmVjdDExIiBjbGFzcz0icmVjdHMiPjwvZGl2PgoJCQkJPGRpdiBpZD0iY1JlY3QxMiIgY2xhc3M9InJlY3RzIj48L2Rpdj4KCQkJCTxkaXYgaWQ9ImVtb2ppIiBjbGFzcz0iZW1vamlzIj48L2Rpdj4KCQkJPC9kaXY+CgkJCTxkaXYgaWQ9ImVtb2ppLWNvbnRhaW5lciI+CgkJCQk8c3R5bGU+CgkJCQkuZG9tcmVjdC1lbW9qaSB7CgkJCQkJZm9udC1mYW1pbHk6ICR7QX07CgkJCQkJZm9udC1zaXplOiAyMDBweCAhaW1wb3J0YW50OwoJCQkJCWhlaWdodDogYXV0bzsKCQkJCQlwb3NpdGlvbjogYWJzb2x1dGUgIWltcG9ydGFudDsKCQkJCQl0cmFuc2Zvcm06IHNjYWxlKDEuMDAwOTk5KTsKCQkJCX0KCQkJCTwvc3R5bGU+CgkJCQkke3YubWFwKChlPT5gPGRpdiBjbGFzcz0iZG9tcmVjdC1lbW9qaSI+JHtlfTwvZGl2PmApKS5qb2luKCIiKX0KCQkJPC9kaXY+CgkJPC9kaXY+CgkJYCk7Y29uc3QgbD1uZXcgU2V0O2F3YWl0IGsoZSk7Y29uc3QgZD1bLi4uci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCJkb21yZWN0LWVtb2ppIildLnJlZHVjZSgoKGUsdCxuKT0+e2NvbnN0IGE9dltuXSx7aGVpZ2h0Om8sd2lkdGg6cn09aSh0KSxzPWAke3J9LCR7b31gO3JldHVybiBsLmhhcyhzKXx8KGwuYWRkKHMpLGUuYWRkKGEpKSxlfSksbmV3IFNldCksbT0xZS01KlsuLi5sXS5tYXAoKGU9PmUuc3BsaXQoIiwiKS5yZWR1Y2UoKChlLHQpPT5lKygrdHx8MCkpLDApKSkucmVkdWNlKCgoZSx0KT0+ZSt0KSwwKSx1PWRvY3VtZW50LmNyZWF0ZVJhbmdlKCksZz1yLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoInJlY3RzIikscD1bLi4uZ10ubWFwKChlPT50KGUuZ2V0Q2xpZW50UmVjdHMoKVswXSkpKSxoPVsuLi5nXS5tYXAoKGU9PnQoZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpKSxiPVsuLi5nXS5tYXAoKGU9Pih1LnNlbGVjdE5vZGUoZSksdCh1LmdldENsaWVudFJlY3RzKClbMF0pKSkpLGY9Wy4uLmddLm1hcCgoZT0+KHUuc2VsZWN0Tm9kZShlKSx0KGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpKSkpLFM9Wy4uLmddWzNdLHt0b3A6eX09cFszXTtTLmNsYXNzTGlzdC5hZGQoInNoaWZ0LWRvbS1yZWN0Iik7Y29uc3R7dG9wOkR9PXQoUy5nZXRDbGllbnRSZWN0cygpWzBdKTtTLmNsYXNzTGlzdC5yZW1vdmUoInNoaWZ0LWRvbS1yZWN0Iik7Y29uc3R7dG9wOk19PXQoUy5nZXRDbGllbnRSZWN0cygpWzBdKTt5LUQhPU0tRCYmKG89ITAsTygiRWxlbWVudC5nZXRDbGllbnRSZWN0cyIsImZhaWxlZCB1bnNoaWZ0IGNhbGN1bGF0aW9uIikpO2xldCB4PSExO3AuZm9yRWFjaCgoZT0+e2NvbnN0e3JpZ2h0OnQsbGVmdDpuLHdpZHRoOmEsYm90dG9tOnIsdG9wOmksaGVpZ2h0OnMseDpjLHk6bH09ZTt0LW49PWEmJnItaT09cyYmdC1jPT1hJiZyLWw9PXN8fChvPSEwLHg9ITApfSkpLHgmJk8oIkVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMiLCJmYWlsZWQgbWF0aCBjYWxjdWxhdGlvbiIpO2NvbnN0e3JpZ2h0OlIsbGVmdDpOfT1wWzEwXSx7cmlnaHQ6SSxsZWZ0Okx9PXBbMTFdO1I9PUkmJk49PUx8fChPKCJFbGVtZW50LmdldENsaWVudFJlY3RzIiwiZXF1YWwgZWxlbWVudHMgbWlzbWF0Y2giKSxvPSEwKTtjb25zdCBQPVsuLi5yLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoInJlY3Qta25vd24iKV1bMF0sQj10KFAuZ2V0Q2xpZW50UmVjdHMoKVswXSksSD13ZShCKTtpZihuKXsoeyI5ZDkyMTVjYyI6ITAsIjQ3ZGVkMzIyIjohMCxkMGVjZWFhODohMH0pW0hdfHwoTygiRWxlbWVudC5nZXRDbGllbnRSZWN0cyIsInVua25vd24gcm90YXRlIGRpbWVuc2lvbnMiKSxvPSEwKX1lbHNlIGlmKGEpeyh7ZTM4NDUzZjA6ITB9KVtIXXx8KE8oIkVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMiLCJ1bmtub3duIHJvdGF0ZSBkaW1lbnNpb25zIiksbz0hMCl9Y29uc3QgRj1bLi4uci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCJyZWN0LWdob3N0IildWzBdLEc9dChGLmdldENsaWVudFJlY3RzKClbMF0pO3JldHVybiBPYmplY3Qua2V5cyhHKS5zb21lKChlPT4wIT09R1tlXSkpJiYoTygiRWxlbWVudC5nZXRDbGllbnRSZWN0cyIsInVua25vd24gZ2hvc3QgZGltZW5zaW9ucyIpLG89ITApLHIuYm9keS5yZW1vdmVDaGlsZChyLmdldEVsZW1lbnRCeUlkKHMpKSxFKHt0aW1lOmUuc3RvcCgpLHRlc3Q6InJlY3RzIixwYXNzZWQ6ITB9KSx7ZWxlbWVudENsaWVudFJlY3RzOnAsZWxlbWVudEJvdW5kaW5nQ2xpZW50UmVjdDpoLHJhbmdlQ2xpZW50UmVjdHM6YixyYW5nZUJvdW5kaW5nQ2xpZW50UmVjdDpmLGVtb2ppU2V0OlsuLi5kXSxkb21yZWN0U3lzdGVtU3VtOm0sbGllZDpvfX1jYXRjaChlKXtyZXR1cm4gRSh7dGVzdDoicmVjdHMiLHBhc3NlZDohMX0pLHZvaWQgUihlKX19ZnVuY3Rpb24gUGUoKXt0cnl7Y29uc3QgZT13KCk7ZS5zdGFydCgpO2NvbnN0IHQ9ZnVuY3Rpb24oZSl7Y29uc3QgdD1bXTtsZXQgbjtjb25zdCBhPWUubGVuZ3RoO2ZvcihuPTA7bjxhO24rKyl0cnl7ZVtuXSgpfWNhdGNoKGUpe3QucHVzaChlLm1lc3NhZ2UpfXJldHVybiB0fShbKCk9Pm5ldyBGdW5jdGlvbignYWxlcnQoIiknKSgpLCgpPT5uZXcgRnVuY3Rpb24oImNvbnN0IGZvbztmb28uYmFyIikoKSwoKT0+bmV3IEZ1bmN0aW9uKCJudWxsLmJhciIpKCksKCk9Pm5ldyBGdW5jdGlvbigiYWJjLnh5eiA9IDEyMyIpKCksKCk9Pm5ldyBGdW5jdGlvbigiY29uc3QgZm9vO2Zvby5iYXIiKSgpLCgpPT5uZXcgRnVuY3Rpb24oIigxKS50b1N0cmluZygxMDAwKSIpKCksKCk9Pm5ldyBGdW5jdGlvbigiWy4uLnVuZGVmaW5lZF0ubGVuZ3RoIikoKSwoKT0+bmV3IEZ1bmN0aW9uKCJ2YXIgeCA9IG5ldyBBcnJheSgtMSkiKSgpLCgpPT5uZXcgRnVuY3Rpb24oImNvbnN0IGE9MTsgY29uc3QgYT0yOyIpKCldKTtyZXR1cm4gRSh7dGltZTplLnN0b3AoKSx0ZXN0OiJjb25zb2xlIGVycm9ycyIscGFzc2VkOiEwfSkse2Vycm9yczp0fX1jYXRjaChlKXtyZXR1cm4gRSh7dGVzdDoiY29uc29sZSBlcnJvcnMiLHBhc3NlZDohMX0pLHZvaWQgUihlKX19Y29uc3QgT2U9bj8iQ2hyb21lIjphPyJGaXJlZm94IjoiIixCZT1lPT5lLnNvcnQoKChlLHQpPT4vXGQrLy5leGVjKGUpWzBdLS9cZCsvLmV4ZWModClbMF0pKS5yZXZlcnNlKCksSGU9KGUsdCxuPTApPT57Y29uc3QgYT17Q2hyb21lOnt2ZXJzaW9uOjEwOSx3aW5kb3dLZXlzOiJPYmplY3QsIEZ1bmN0aW9uLCBBcnJheSwgTnVtYmVyLCBwYXJzZUZsb2F0LCBwYXJzZUludCwgSW5maW5pdHksIE5hTiwgdW5kZWZpbmVkLCBCb29sZWFuLCBTdHJpbmcsIFN5bWJvbCwgRGF0ZSwgUHJvbWlzZSwgUmVnRXhwLCBFcnJvciwgQWdncmVnYXRlRXJyb3IsIEV2YWxFcnJvciwgUmFuZ2VFcnJvciwgUmVmZXJlbmNlRXJyb3IsIFN5bnRheEVycm9yLCBUeXBlRXJyb3IsIFVSSUVycm9yLCBnbG9iYWxUaGlzLCBKU09OLCBNYXRoLCBJbnRsLCBBcnJheUJ1ZmZlciwgVWludDhBcnJheSwgSW50OEFycmF5LCBVaW50MTZBcnJheSwgSW50MTZBcnJheSwgVWludDMyQXJyYXksIEludDMyQXJyYXksIEZsb2F0MzJBcnJheSwgRmxvYXQ2NEFycmF5LCBVaW50OENsYW1wZWRBcnJheSwgQmlnVWludDY0QXJyYXksIEJpZ0ludDY0QXJyYXksIERhdGFWaWV3LCBNYXAsIEJpZ0ludCwgU2V0LCBXZWFrTWFwLCBXZWFrU2V0LCBQcm94eSwgUmVmbGVjdCwgRmluYWxpemF0aW9uUmVnaXN0cnksIFdlYWtSZWYsIGRlY29kZVVSSSwgZGVjb2RlVVJJQ29tcG9uZW50LCBlbmNvZGVVUkksIGVuY29kZVVSSUNvbXBvbmVudCwgZXNjYXBlLCB1bmVzY2FwZSwgZXZhbCwgaXNGaW5pdGUsIGlzTmFOLCBjb25zb2xlLCBPcHRpb24sIEltYWdlLCBBdWRpbywgd2Via2l0VVJMLCB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbiwgd2Via2l0TWVkaWFTdHJlYW0sIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIsIFdlYktpdENTU01hdHJpeCwgWFNMVFByb2Nlc3NvciwgWFBhdGhSZXN1bHQsIFhQYXRoRXhwcmVzc2lvbiwgWFBhdGhFdmFsdWF0b3IsIFhNTFNlcmlhbGl6ZXIsIFhNTEh0dHBSZXF1ZXN0VXBsb2FkLCBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LCBYTUxIdHRwUmVxdWVzdCwgWE1MRG9jdW1lbnQsIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciwgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciwgV3JpdGFibGVTdHJlYW0sIFdvcmtlciwgV2luZG93LCBXaGVlbEV2ZW50LCBXZWJTb2NrZXQsIFdlYkdMVmVydGV4QXJyYXlPYmplY3QsIFdlYkdMVW5pZm9ybUxvY2F0aW9uLCBXZWJHTFRyYW5zZm9ybUZlZWRiYWNrLCBXZWJHTFRleHR1cmUsIFdlYkdMU3luYywgV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXQsIFdlYkdMU2hhZGVyLCBXZWJHTFNhbXBsZXIsIFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgV2ViR0xSZW5kZXJidWZmZXIsIFdlYkdMUXVlcnksIFdlYkdMUHJvZ3JhbSwgV2ViR0xGcmFtZWJ1ZmZlciwgV2ViR0xDb250ZXh0RXZlbnQsIFdlYkdMQnVmZmVyLCBXZWJHTEFjdGl2ZUluZm8sIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsIFdhdmVTaGFwZXJOb2RlLCBWaXN1YWxWaWV3cG9ydCwgVmlydHVhbEtleWJvYXJkR2VvbWV0cnlDaGFuZ2VFdmVudCwgVmFsaWRpdHlTdGF0ZSwgVlRUQ3VlLCBVc2VyQWN0aXZhdGlvbiwgVVJMU2VhcmNoUGFyYW1zLCBVUkxQYXR0ZXJuLCBVUkwsIFVJRXZlbnQsIFRydXN0ZWRUeXBlUG9saWN5RmFjdG9yeSwgVHJ1c3RlZFR5cGVQb2xpY3ksIFRydXN0ZWRTY3JpcHRVUkwsIFRydXN0ZWRTY3JpcHQsIFRydXN0ZWRIVE1MLCBUcmVlV2Fsa2VyLCBUcmFuc2l0aW9uRXZlbnQsIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLCBUcmFuc2Zvcm1TdHJlYW0sIFRyYWNrRXZlbnQsIFRvdWNoTGlzdCwgVG91Y2hFdmVudCwgVG91Y2gsIFRpbWVSYW5nZXMsIFRleHRUcmFja0xpc3QsIFRleHRUcmFja0N1ZUxpc3QsIFRleHRUcmFja0N1ZSwgVGV4dFRyYWNrLCBUZXh0TWV0cmljcywgVGV4dEV2ZW50LCBUZXh0RW5jb2RlclN0cmVhbSwgVGV4dEVuY29kZXIsIFRleHREZWNvZGVyU3RyZWFtLCBUZXh0RGVjb2RlciwgVGV4dCwgVGFza1NpZ25hbCwgVGFza1ByaW9yaXR5Q2hhbmdlRXZlbnQsIFRhc2tDb250cm9sbGVyLCBUYXNrQXR0cmlidXRpb25UaW1pbmcsIFN5bmNNYW5hZ2VyLCBTdWJtaXRFdmVudCwgU3R5bGVTaGVldExpc3QsIFN0eWxlU2hlZXQsIFN0eWxlUHJvcGVydHlNYXBSZWFkT25seSwgU3R5bGVQcm9wZXJ0eU1hcCwgU3RvcmFnZUV2ZW50LCBTdG9yYWdlLCBTdGVyZW9QYW5uZXJOb2RlLCBTdGF0aWNSYW5nZSwgU2hhZG93Um9vdCwgU2VsZWN0aW9uLCBTZWN1cml0eVBvbGljeVZpb2xhdGlvbkV2ZW50LCBTY3JpcHRQcm9jZXNzb3JOb2RlLCBTY3JlZW5PcmllbnRhdGlvbiwgU2NyZWVuLCBTY2hlZHVsaW5nLCBTY2hlZHVsZXIsIFNWR1ZpZXdFbGVtZW50LCBTVkdVc2VFbGVtZW50LCBTVkdVbml0VHlwZXMsIFNWR1RyYW5zZm9ybUxpc3QsIFNWR1RyYW5zZm9ybSwgU1ZHVGl0bGVFbGVtZW50LCBTVkdUZXh0UG9zaXRpb25pbmdFbGVtZW50LCBTVkdUZXh0UGF0aEVsZW1lbnQsIFNWR1RleHRFbGVtZW50LCBTVkdUZXh0Q29udGVudEVsZW1lbnQsIFNWR1RTcGFuRWxlbWVudCwgU1ZHU3ltYm9sRWxlbWVudCwgU1ZHU3dpdGNoRWxlbWVudCwgU1ZHU3R5bGVFbGVtZW50LCBTVkdTdHJpbmdMaXN0LCBTVkdTdG9wRWxlbWVudCwgU1ZHU2V0RWxlbWVudCwgU1ZHU2NyaXB0RWxlbWVudCwgU1ZHU1ZHRWxlbWVudCwgU1ZHUmVjdEVsZW1lbnQsIFNWR1JlY3QsIFNWR1JhZGlhbEdyYWRpZW50RWxlbWVudCwgU1ZHUHJlc2VydmVBc3BlY3RSYXRpbywgU1ZHUG9seWxpbmVFbGVtZW50LCBTVkdQb2x5Z29uRWxlbWVudCwgU1ZHUG9pbnRMaXN0LCBTVkdQb2ludCwgU1ZHUGF0dGVybkVsZW1lbnQsIFNWR1BhdGhFbGVtZW50LCBTVkdOdW1iZXJMaXN0LCBTVkdOdW1iZXIsIFNWR01ldGFkYXRhRWxlbWVudCwgU1ZHTWF0cml4LCBTVkdNYXNrRWxlbWVudCwgU1ZHTWFya2VyRWxlbWVudCwgU1ZHTVBhdGhFbGVtZW50LCBTVkdMaW5lYXJHcmFkaWVudEVsZW1lbnQsIFNWR0xpbmVFbGVtZW50LCBTVkdMZW5ndGhMaXN0LCBTVkdMZW5ndGgsIFNWR0ltYWdlRWxlbWVudCwgU1ZHR3JhcGhpY3NFbGVtZW50LCBTVkdHcmFkaWVudEVsZW1lbnQsIFNWR0dlb21ldHJ5RWxlbWVudCwgU1ZHR0VsZW1lbnQsIFNWR0ZvcmVpZ25PYmplY3RFbGVtZW50LCBTVkdGaWx0ZXJFbGVtZW50LCBTVkdGRVR1cmJ1bGVuY2VFbGVtZW50LCBTVkdGRVRpbGVFbGVtZW50LCBTVkdGRVNwb3RMaWdodEVsZW1lbnQsIFNWR0ZFU3BlY3VsYXJMaWdodGluZ0VsZW1lbnQsIFNWR0ZFUG9pbnRMaWdodEVsZW1lbnQsIFNWR0ZFT2Zmc2V0RWxlbWVudCwgU1ZHRkVNb3JwaG9sb2d5RWxlbWVudCwgU1ZHRkVNZXJnZU5vZGVFbGVtZW50LCBTVkdGRU1lcmdlRWxlbWVudCwgU1ZHRkVJbWFnZUVsZW1lbnQsIFNWR0ZFR2F1c3NpYW5CbHVyRWxlbWVudCwgU1ZHRkVGdW5jUkVsZW1lbnQsIFNWR0ZFRnVuY0dFbGVtZW50LCBTVkdGRUZ1bmNCRWxlbWVudCwgU1ZHRkVGdW5jQUVsZW1lbnQsIFNWR0ZFRmxvb2RFbGVtZW50LCBTVkdGRURyb3BTaGFkb3dFbGVtZW50LCBTVkdGRURpc3RhbnRMaWdodEVsZW1lbnQsIFNWR0ZFRGlzcGxhY2VtZW50TWFwRWxlbWVudCwgU1ZHRkVEaWZmdXNlTGlnaHRpbmdFbGVtZW50LCBTVkdGRUNvbnZvbHZlTWF0cml4RWxlbWVudCwgU1ZHRkVDb21wb3NpdGVFbGVtZW50LCBTVkdGRUNvbXBvbmVudFRyYW5zZmVyRWxlbWVudCwgU1ZHRkVDb2xvck1hdHJpeEVsZW1lbnQsIFNWR0ZFQmxlbmRFbGVtZW50LCBTVkdFbGxpcHNlRWxlbWVudCwgU1ZHRWxlbWVudCwgU1ZHRGVzY0VsZW1lbnQsIFNWR0RlZnNFbGVtZW50LCBTVkdDb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9uRWxlbWVudCwgU1ZHQ2xpcFBhdGhFbGVtZW50LCBTVkdDaXJjbGVFbGVtZW50LCBTVkdBbmltYXRpb25FbGVtZW50LCBTVkdBbmltYXRlZFRyYW5zZm9ybUxpc3QsIFNWR0FuaW1hdGVkU3RyaW5nLCBTVkdBbmltYXRlZFJlY3QsIFNWR0FuaW1hdGVkUHJlc2VydmVBc3BlY3RSYXRpbywgU1ZHQW5pbWF0ZWROdW1iZXJMaXN0LCBTVkdBbmltYXRlZE51bWJlciwgU1ZHQW5pbWF0ZWRMZW5ndGhMaXN0LCBTVkdBbmltYXRlZExlbmd0aCwgU1ZHQW5pbWF0ZWRJbnRlZ2VyLCBTVkdBbmltYXRlZEVudW1lcmF0aW9uLCBTVkdBbmltYXRlZEJvb2xlYW4sIFNWR0FuaW1hdGVkQW5nbGUsIFNWR0FuaW1hdGVUcmFuc2Zvcm1FbGVtZW50LCBTVkdBbmltYXRlTW90aW9uRWxlbWVudCwgU1ZHQW5pbWF0ZUVsZW1lbnQsIFNWR0FuZ2xlLCBTVkdBRWxlbWVudCwgUmVzcG9uc2UsIFJlc2l6ZU9ic2VydmVyU2l6ZSwgUmVzaXplT2JzZXJ2ZXJFbnRyeSwgUmVzaXplT2JzZXJ2ZXIsIFJlcXVlc3QsIFJlcG9ydGluZ09ic2VydmVyLCBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIsIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QsIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciwgUmVhZGFibGVTdHJlYW0sIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsIFJhbmdlLCBSYWRpb05vZGVMaXN0LCBSVENUcmFja0V2ZW50LCBSVENTdGF0c1JlcG9ydCwgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLCBSVENTY3RwVHJhbnNwb3J0LCBSVENSdHBUcmFuc2NlaXZlciwgUlRDUnRwU2VuZGVyLCBSVENSdHBSZWNlaXZlciwgUlRDUGVlckNvbm5lY3Rpb25JY2VFdmVudCwgUlRDUGVlckNvbm5lY3Rpb25JY2VFcnJvckV2ZW50LCBSVENQZWVyQ29ubmVjdGlvbiwgUlRDSWNlVHJhbnNwb3J0LCBSVENJY2VDYW5kaWRhdGUsIFJUQ0Vycm9yRXZlbnQsIFJUQ0Vycm9yLCBSVENFbmNvZGVkVmlkZW9GcmFtZSwgUlRDRW5jb2RlZEF1ZGlvRnJhbWUsIFJUQ0R0bHNUcmFuc3BvcnQsIFJUQ0RhdGFDaGFubmVsRXZlbnQsIFJUQ0RhdGFDaGFubmVsLCBSVENEVE1GVG9uZUNoYW5nZUV2ZW50LCBSVENEVE1GU2VuZGVyLCBSVENDZXJ0aWZpY2F0ZSwgUHJvbWlzZVJlamVjdGlvbkV2ZW50LCBQcm9ncmVzc0V2ZW50LCBQcm9maWxlciwgUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBQb3BTdGF0ZUV2ZW50LCBQb2ludGVyRXZlbnQsIFBsdWdpbkFycmF5LCBQbHVnaW4sIFBlcmlvZGljV2F2ZSwgUGVyZm9ybWFuY2VUaW1pbmcsIFBlcmZvcm1hbmNlU2VydmVyVGltaW5nLCBQZXJmb3JtYW5jZVJlc291cmNlVGltaW5nLCBQZXJmb3JtYW5jZVBhaW50VGltaW5nLCBQZXJmb3JtYW5jZU9ic2VydmVyRW50cnlMaXN0LCBQZXJmb3JtYW5jZU9ic2VydmVyLCBQZXJmb3JtYW5jZU5hdmlnYXRpb25UaW1pbmcsIFBlcmZvcm1hbmNlTmF2aWdhdGlvbiwgUGVyZm9ybWFuY2VNZWFzdXJlLCBQZXJmb3JtYW5jZU1hcmssIFBlcmZvcm1hbmNlTG9uZ1Rhc2tUaW1pbmcsIFBlcmZvcm1hbmNlRXZlbnRUaW1pbmcsIFBlcmZvcm1hbmNlRW50cnksIFBlcmZvcm1hbmNlRWxlbWVudFRpbWluZywgUGVyZm9ybWFuY2UsIFBhdGgyRCwgUGFubmVyTm9kZSwgUGFnZVRyYW5zaXRpb25FdmVudCwgT3ZlcmNvbnN0cmFpbmVkRXJyb3IsIE9zY2lsbGF0b3JOb2RlLCBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIE9mZnNjcmVlbkNhbnZhcywgT2ZmbGluZUF1ZGlvQ29udGV4dCwgT2ZmbGluZUF1ZGlvQ29tcGxldGlvbkV2ZW50LCBOb2RlTGlzdCwgTm9kZUl0ZXJhdG9yLCBOb2RlRmlsdGVyLCBOb2RlLCBOZXR3b3JrSW5mb3JtYXRpb24sIE5hdmlnYXRvciwgTmFtZWROb2RlTWFwLCBNdXRhdGlvblJlY29yZCwgTXV0YXRpb25PYnNlcnZlciwgTXV0YXRpb25FdmVudCwgTW91c2VFdmVudCwgTWltZVR5cGVBcnJheSwgTWltZVR5cGUsIE1lc3NhZ2VQb3J0LCBNZXNzYWdlRXZlbnQsIE1lc3NhZ2VDaGFubmVsLCBNZWRpYVN0cmVhbVRyYWNrUHJvY2Vzc29yLCBNZWRpYVN0cmVhbVRyYWNrRXZlbnQsIE1lZGlhU3RyZWFtRXZlbnQsIE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLCBNZWRpYVN0cmVhbUF1ZGlvRGVzdGluYXRpb25Ob2RlLCBNZWRpYVN0cmVhbSwgTWVkaWFSZWNvcmRlciwgTWVkaWFRdWVyeUxpc3RFdmVudCwgTWVkaWFRdWVyeUxpc3QsIE1lZGlhTGlzdCwgTWVkaWFFcnJvciwgTWVkaWFFbmNyeXB0ZWRFdmVudCwgTWVkaWFFbGVtZW50QXVkaW9Tb3VyY2VOb2RlLCBNZWRpYUNhcGFiaWxpdGllcywgTG9jYXRpb24sIExheW91dFNoaWZ0QXR0cmlidXRpb24sIExheW91dFNoaWZ0LCBMYXJnZXN0Q29udGVudGZ1bFBhaW50LCBLZXlmcmFtZUVmZmVjdCwgS2V5Ym9hcmRFdmVudCwgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSwgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsIElucHV0RXZlbnQsIElucHV0RGV2aWNlSW5mbywgSW5wdXREZXZpY2VDYXBhYmlsaXRpZXMsIEltYWdlRGF0YSwgSW1hZ2VDYXB0dXJlLCBJbWFnZUJpdG1hcFJlbmRlcmluZ0NvbnRleHQsIEltYWdlQml0bWFwLCBJZGxlRGVhZGxpbmUsIElJUkZpbHRlck5vZGUsIElEQlZlcnNpb25DaGFuZ2VFdmVudCwgSURCVHJhbnNhY3Rpb24sIElEQlJlcXVlc3QsIElEQk9wZW5EQlJlcXVlc3QsIElEQk9iamVjdFN0b3JlLCBJREJLZXlSYW5nZSwgSURCSW5kZXgsIElEQkZhY3RvcnksIElEQkRhdGFiYXNlLCBJREJDdXJzb3JXaXRoVmFsdWUsIElEQkN1cnNvciwgSGlzdG9yeSwgSGVhZGVycywgSGFzaENoYW5nZUV2ZW50LCBIVE1MVmlkZW9FbGVtZW50LCBIVE1MVW5rbm93bkVsZW1lbnQsIEhUTUxVTGlzdEVsZW1lbnQsIEhUTUxUcmFja0VsZW1lbnQsIEhUTUxUaXRsZUVsZW1lbnQsIEhUTUxUaW1lRWxlbWVudCwgSFRNTFRleHRBcmVhRWxlbWVudCwgSFRNTFRlbXBsYXRlRWxlbWVudCwgSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQsIEhUTUxUYWJsZVJvd0VsZW1lbnQsIEhUTUxUYWJsZUVsZW1lbnQsIEhUTUxUYWJsZUNvbEVsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50LCBIVE1MVGFibGVDYXB0aW9uRWxlbWVudCwgSFRNTFN0eWxlRWxlbWVudCwgSFRNTFNwYW5FbGVtZW50LCBIVE1MU291cmNlRWxlbWVudCwgSFRNTFNsb3RFbGVtZW50LCBIVE1MU2VsZWN0RWxlbWVudCwgSFRNTFNjcmlwdEVsZW1lbnQsIEhUTUxRdW90ZUVsZW1lbnQsIEhUTUxQcm9ncmVzc0VsZW1lbnQsIEhUTUxQcmVFbGVtZW50LCBIVE1MUGljdHVyZUVsZW1lbnQsIEhUTUxQYXJhbUVsZW1lbnQsIEhUTUxQYXJhZ3JhcGhFbGVtZW50LCBIVE1MT3V0cHV0RWxlbWVudCwgSFRNTE9wdGlvbnNDb2xsZWN0aW9uLCBIVE1MT3B0aW9uRWxlbWVudCwgSFRNTE9wdEdyb3VwRWxlbWVudCwgSFRNTE9iamVjdEVsZW1lbnQsIEhUTUxPTGlzdEVsZW1lbnQsIEhUTUxNb2RFbGVtZW50LCBIVE1MTWV0ZXJFbGVtZW50LCBIVE1MTWV0YUVsZW1lbnQsIEhUTUxNZW51RWxlbWVudCwgSFRNTE1lZGlhRWxlbWVudCwgSFRNTE1hcnF1ZWVFbGVtZW50LCBIVE1MTWFwRWxlbWVudCwgSFRNTExpbmtFbGVtZW50LCBIVE1MTGVnZW5kRWxlbWVudCwgSFRNTExhYmVsRWxlbWVudCwgSFRNTExJRWxlbWVudCwgSFRNTElucHV0RWxlbWVudCwgSFRNTEltYWdlRWxlbWVudCwgSFRNTElGcmFtZUVsZW1lbnQsIEhUTUxIdG1sRWxlbWVudCwgSFRNTEhlYWRpbmdFbGVtZW50LCBIVE1MSGVhZEVsZW1lbnQsIEhUTUxIUkVsZW1lbnQsIEhUTUxGcmFtZVNldEVsZW1lbnQsIEhUTUxGcmFtZUVsZW1lbnQsIEhUTUxGb3JtRWxlbWVudCwgSFRNTEZvcm1Db250cm9sc0NvbGxlY3Rpb24sIEhUTUxGb250RWxlbWVudCwgSFRNTEZpZWxkU2V0RWxlbWVudCwgSFRNTEVtYmVkRWxlbWVudCwgSFRNTEVsZW1lbnQsIEhUTUxEb2N1bWVudCwgSFRNTERpdkVsZW1lbnQsIEhUTUxEaXJlY3RvcnlFbGVtZW50LCBIVE1MRGlhbG9nRWxlbWVudCwgSFRNTERldGFpbHNFbGVtZW50LCBIVE1MRGF0YUxpc3RFbGVtZW50LCBIVE1MRGF0YUVsZW1lbnQsIEhUTUxETGlzdEVsZW1lbnQsIEhUTUxDb2xsZWN0aW9uLCBIVE1MQ2FudmFzRWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnQsIEhUTUxCb2R5RWxlbWVudCwgSFRNTEJhc2VFbGVtZW50LCBIVE1MQlJFbGVtZW50LCBIVE1MQXVkaW9FbGVtZW50LCBIVE1MQXJlYUVsZW1lbnQsIEhUTUxBbmNob3JFbGVtZW50LCBIVE1MQWxsQ29sbGVjdGlvbiwgR2VvbG9jYXRpb25Qb3NpdGlvbkVycm9yLCBHZW9sb2NhdGlvblBvc2l0aW9uLCBHZW9sb2NhdGlvbkNvb3JkaW5hdGVzLCBHZW9sb2NhdGlvbiwgR2FtZXBhZEhhcHRpY0FjdHVhdG9yLCBHYW1lcGFkRXZlbnQsIEdhbWVwYWRCdXR0b24sIEdhbWVwYWQsIEdhaW5Ob2RlLCBGb3JtRGF0YUV2ZW50LCBGb3JtRGF0YSwgRm9udEZhY2VTZXRMb2FkRXZlbnQsIEZvbnRGYWNlLCBGb2N1c0V2ZW50LCBGaWxlUmVhZGVyLCBGaWxlTGlzdCwgRmlsZSwgRmVhdHVyZVBvbGljeSwgRXh0ZXJuYWwsIEV2ZW50VGFyZ2V0LCBFdmVudFNvdXJjZSwgRXZlbnRDb3VudHMsIEV2ZW50LCBFcnJvckV2ZW50LCBFbGVtZW50SW50ZXJuYWxzLCBFbGVtZW50LCBEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBEcmFnRXZlbnQsIERvY3VtZW50VHlwZSwgRG9jdW1lbnRGcmFnbWVudCwgRG9jdW1lbnQsIERlbGF5Tm9kZSwgRGVjb21wcmVzc2lvblN0cmVhbSwgRGF0YVRyYW5zZmVySXRlbUxpc3QsIERhdGFUcmFuc2Zlckl0ZW0sIERhdGFUcmFuc2ZlciwgRE9NVG9rZW5MaXN0LCBET01TdHJpbmdNYXAsIERPTVN0cmluZ0xpc3QsIERPTVJlY3RSZWFkT25seSwgRE9NUmVjdExpc3QsIERPTVJlY3QsIERPTVF1YWQsIERPTVBvaW50UmVhZE9ubHksIERPTVBvaW50LCBET01QYXJzZXIsIERPTU1hdHJpeFJlYWRPbmx5LCBET01NYXRyaXgsIERPTUltcGxlbWVudGF0aW9uLCBET01FeGNlcHRpb24sIERPTUVycm9yLCBDdXN0b21TdGF0ZVNldCwgQ3VzdG9tRXZlbnQsIEN1c3RvbUVsZW1lbnRSZWdpc3RyeSwgQ3J5cHRvLCBDb3VudFF1ZXVpbmdTdHJhdGVneSwgQ29udm9sdmVyTm9kZSwgQ29uc3RhbnRTb3VyY2VOb2RlLCBDb21wcmVzc2lvblN0cmVhbSwgQ29tcG9zaXRpb25FdmVudCwgQ29tbWVudCwgQ2xvc2VFdmVudCwgQ2xpcGJvYXJkRXZlbnQsIENoYXJhY3RlckRhdGEsIENoYW5uZWxTcGxpdHRlck5vZGUsIENoYW5uZWxNZXJnZXJOb2RlLCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIENhbnZhc1BhdHRlcm4sIENhbnZhc0dyYWRpZW50LCBDYW52YXNGaWx0ZXIsIENhbnZhc0NhcHR1cmVNZWRpYVN0cmVhbVRyYWNrLCBDU1NWYXJpYWJsZVJlZmVyZW5jZVZhbHVlLCBDU1NVbnBhcnNlZFZhbHVlLCBDU1NVbml0VmFsdWUsIENTU1RyYW5zbGF0ZSwgQ1NTVHJhbnNmb3JtVmFsdWUsIENTU1RyYW5zZm9ybUNvbXBvbmVudCwgQ1NTU3VwcG9ydHNSdWxlLCBDU1NTdHlsZVZhbHVlLCBDU1NTdHlsZVNoZWV0LCBDU1NTdHlsZVJ1bGUsIENTU1N0eWxlRGVjbGFyYXRpb24sIENTU1NrZXdZLCBDU1NTa2V3WCwgQ1NTU2tldywgQ1NTU2NhbGUsIENTU1J1bGVMaXN0LCBDU1NSdWxlLCBDU1NSb3RhdGUsIENTU1Byb3BlcnR5UnVsZSwgQ1NTUG9zaXRpb25WYWx1ZSwgQ1NTUGVyc3BlY3RpdmUsIENTU1BhZ2VSdWxlLCBDU1NOdW1lcmljVmFsdWUsIENTU051bWVyaWNBcnJheSwgQ1NTTmFtZXNwYWNlUnVsZSwgQ1NTTWVkaWFSdWxlLCBDU1NNYXRyaXhDb21wb25lbnQsIENTU01hdGhWYWx1ZSwgQ1NTTWF0aFN1bSwgQ1NTTWF0aFByb2R1Y3QsIENTU01hdGhOZWdhdGUsIENTU01hdGhNaW4sIENTU01hdGhNYXgsIENTU01hdGhJbnZlcnQsIENTU01hdGhDbGFtcCwgQ1NTTGF5ZXJTdGF0ZW1lbnRSdWxlLCBDU1NMYXllckJsb2NrUnVsZSwgQ1NTS2V5d29yZFZhbHVlLCBDU1NLZXlmcmFtZXNSdWxlLCBDU1NLZXlmcmFtZVJ1bGUsIENTU0ltcG9ydFJ1bGUsIENTU0ltYWdlVmFsdWUsIENTU0dyb3VwaW5nUnVsZSwgQ1NTRm9udEZhY2VSdWxlLCBDU1NDb3VudGVyU3R5bGVSdWxlLCBDU1NDb25kaXRpb25SdWxlLCBDU1MsIENEQVRBU2VjdGlvbiwgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSwgQnJvYWRjYXN0Q2hhbm5lbCwgQmxvYkV2ZW50LCBCbG9iLCBCaXF1YWRGaWx0ZXJOb2RlLCBCZWZvcmVVbmxvYWRFdmVudCwgQmVmb3JlSW5zdGFsbFByb21wdEV2ZW50LCBCYXNlQXVkaW9Db250ZXh0LCBCYXJQcm9wLCBBdWRpb1dvcmtsZXROb2RlLCBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUsIEF1ZGlvUHJvY2Vzc2luZ0V2ZW50LCBBdWRpb1BhcmFtTWFwLCBBdWRpb1BhcmFtLCBBdWRpb05vZGUsIEF1ZGlvTGlzdGVuZXIsIEF1ZGlvRGVzdGluYXRpb25Ob2RlLCBBdWRpb0NvbnRleHQsIEF1ZGlvQnVmZmVyU291cmNlTm9kZSwgQXVkaW9CdWZmZXIsIEF0dHIsIEFuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FZmZlY3QsIEFuaW1hdGlvbiwgQW5hbHlzZXJOb2RlLCBBYnN0cmFjdFJhbmdlLCBBYm9ydFNpZ25hbCwgQWJvcnRDb250cm9sbGVyLCB3aW5kb3csIHNlbGYsIGRvY3VtZW50LCBuYW1lLCBsb2NhdGlvbiwgY3VzdG9tRWxlbWVudHMsIGhpc3RvcnksIGxvY2F0aW9uYmFyLCBtZW51YmFyLCBwZXJzb25hbGJhciwgc2Nyb2xsYmFycywgc3RhdHVzYmFyLCB0b29sYmFyLCBzdGF0dXMsIGNsb3NlZCwgZnJhbWVzLCBsZW5ndGgsIHRvcCwgb3BlbmVyLCBwYXJlbnQsIGZyYW1lRWxlbWVudCwgbmF2aWdhdG9yLCBvcmlnaW4sIGV4dGVybmFsLCBzY3JlZW4sIGlubmVyV2lkdGgsIGlubmVySGVpZ2h0LCBzY3JvbGxYLCBwYWdlWE9mZnNldCwgc2Nyb2xsWSwgcGFnZVlPZmZzZXQsIHZpc3VhbFZpZXdwb3J0LCBzY3JlZW5YLCBzY3JlZW5ZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCwgZGV2aWNlUGl4ZWxSYXRpbywgZXZlbnQsIGNsaWVudEluZm9ybWF0aW9uLCBvZmZzY3JlZW5CdWZmZXJpbmcsIHNjcmVlbkxlZnQsIHNjcmVlblRvcCwgc3R5bGVNZWRpYSwgb25zZWFyY2gsIGlzU2VjdXJlQ29udGV4dCwgdHJ1c3RlZFR5cGVzLCBwZXJmb3JtYW5jZSwgb25hcHBpbnN0YWxsZWQsIG9uYmVmb3JlaW5zdGFsbHByb21wdCwgY3J5cHRvLCBpbmRleGVkREIsIHNlc3Npb25TdG9yYWdlLCBsb2NhbFN0b3JhZ2UsIG9uYmVmb3JleHJzZWxlY3QsIG9uYWJvcnQsIG9uYmVmb3JlaW5wdXQsIG9uYmx1ciwgb25jYW5jZWwsIG9uY2FucGxheSwgb25jYW5wbGF5dGhyb3VnaCwgb25jaGFuZ2UsIG9uY2xpY2ssIG9uY2xvc2UsIG9uY29udGV4dGxvc3QsIG9uY29udGV4dG1lbnUsIG9uY29udGV4dHJlc3RvcmVkLCBvbmN1ZWNoYW5nZSwgb25kYmxjbGljaywgb25kcmFnLCBvbmRyYWdlbmQsIG9uZHJhZ2VudGVyLCBvbmRyYWdsZWF2ZSwgb25kcmFnb3Zlciwgb25kcmFnc3RhcnQsIG9uZHJvcCwgb25kdXJhdGlvbmNoYW5nZSwgb25lbXB0aWVkLCBvbmVuZGVkLCBvbmVycm9yLCBvbmZvY3VzLCBvbmZvcm1kYXRhLCBvbmlucHV0LCBvbmludmFsaWQsIG9ua2V5ZG93biwgb25rZXlwcmVzcywgb25rZXl1cCwgb25sb2FkLCBvbmxvYWRlZGRhdGEsIG9ubG9hZGVkbWV0YWRhdGEsIG9ubG9hZHN0YXJ0LCBvbm1vdXNlZG93biwgb25tb3VzZWVudGVyLCBvbm1vdXNlbGVhdmUsIG9ubW91c2Vtb3ZlLCBvbm1vdXNlb3V0LCBvbm1vdXNlb3Zlciwgb25tb3VzZXVwLCBvbm1vdXNld2hlZWwsIG9ucGF1c2UsIG9ucGxheSwgb25wbGF5aW5nLCBvbnByb2dyZXNzLCBvbnJhdGVjaGFuZ2UsIG9ucmVzZXQsIG9ucmVzaXplLCBvbnNjcm9sbCwgb25zZWN1cml0eXBvbGljeXZpb2xhdGlvbiwgb25zZWVrZWQsIG9uc2Vla2luZywgb25zZWxlY3QsIG9uc2xvdGNoYW5nZSwgb25zdGFsbGVkLCBvbnN1Ym1pdCwgb25zdXNwZW5kLCBvbnRpbWV1cGRhdGUsIG9udG9nZ2xlLCBvbnZvbHVtZWNoYW5nZSwgb253YWl0aW5nLCBvbndlYmtpdGFuaW1hdGlvbmVuZCwgb253ZWJraXRhbmltYXRpb25pdGVyYXRpb24sIG9ud2Via2l0YW5pbWF0aW9uc3RhcnQsIG9ud2Via2l0dHJhbnNpdGlvbmVuZCwgb253aGVlbCwgb25hdXhjbGljaywgb25nb3Rwb2ludGVyY2FwdHVyZSwgb25sb3N0cG9pbnRlcmNhcHR1cmUsIG9ucG9pbnRlcmRvd24sIG9ucG9pbnRlcm1vdmUsIG9ucG9pbnRlcnJhd3VwZGF0ZSwgb25wb2ludGVydXAsIG9ucG9pbnRlcmNhbmNlbCwgb25wb2ludGVyb3Zlciwgb25wb2ludGVyb3V0LCBvbnBvaW50ZXJlbnRlciwgb25wb2ludGVybGVhdmUsIG9uc2VsZWN0c3RhcnQsIG9uc2VsZWN0aW9uY2hhbmdlLCBvbmFuaW1hdGlvbmVuZCwgb25hbmltYXRpb25pdGVyYXRpb24sIG9uYW5pbWF0aW9uc3RhcnQsIG9udHJhbnNpdGlvbnJ1biwgb250cmFuc2l0aW9uc3RhcnQsIG9udHJhbnNpdGlvbmVuZCwgb250cmFuc2l0aW9uY2FuY2VsLCBvbmFmdGVycHJpbnQsIG9uYmVmb3JlcHJpbnQsIG9uYmVmb3JldW5sb2FkLCBvbmhhc2hjaGFuZ2UsIG9ubGFuZ3VhZ2VjaGFuZ2UsIG9ubWVzc2FnZSwgb25tZXNzYWdlZXJyb3IsIG9ub2ZmbGluZSwgb25vbmxpbmUsIG9ucGFnZWhpZGUsIG9ucGFnZXNob3csIG9ucG9wc3RhdGUsIG9ucmVqZWN0aW9uaGFuZGxlZCwgb25zdG9yYWdlLCBvbnVuaGFuZGxlZHJlamVjdGlvbiwgb251bmxvYWQsIGNyb3NzT3JpZ2luSXNvbGF0ZWQsIHNjaGVkdWxlciwgYWxlcnQsIGF0b2IsIGJsdXIsIGJ0b2EsIGNhbmNlbEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxJZGxlQ2FsbGJhY2ssIGNhcHR1cmVFdmVudHMsIGNsZWFySW50ZXJ2YWwsIGNsZWFyVGltZW91dCwgY2xvc2UsIGNvbmZpcm0sIGNyZWF0ZUltYWdlQml0bWFwLCBmZXRjaCwgZmluZCwgZm9jdXMsIGdldENvbXB1dGVkU3R5bGUsIGdldFNlbGVjdGlvbiwgbWF0Y2hNZWRpYSwgbW92ZUJ5LCBtb3ZlVG8sIG9wZW4sIHBvc3RNZXNzYWdlLCBwcmludCwgcHJvbXB0LCBxdWV1ZU1pY3JvdGFzaywgcmVsZWFzZUV2ZW50cywgcmVwb3J0RXJyb3IsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgcmVxdWVzdElkbGVDYWxsYmFjaywgcmVzaXplQnksIHJlc2l6ZVRvLCBzY3JvbGwsIHNjcm9sbEJ5LCBzY3JvbGxUbywgc2V0SW50ZXJ2YWwsIHNldFRpbWVvdXQsIHN0b3AsIHN0cnVjdHVyZWRDbG9uZSwgd2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUsIHdlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSwgQXRvbWljcywgY2hyb21lLCBXZWJBc3NlbWJseSwgY2FjaGVzLCBjb29raWVTdG9yZSwgb25kZXZpY2Vtb3Rpb24sIG9uZGV2aWNlb3JpZW50YXRpb24sIG9uZGV2aWNlb3JpZW50YXRpb25hYnNvbHV0ZSwgbGF1bmNoUXVldWUsIG9uYmVmb3JlbWF0Y2gsIEFic29sdXRlT3JpZW50YXRpb25TZW5zb3IsIEFjY2VsZXJvbWV0ZXIsIEF1ZGlvV29ya2xldCwgQmF0dGVyeU1hbmFnZXIsIENhY2hlLCBDYWNoZVN0b3JhZ2UsIENsaXBib2FyZCwgQ2xpcGJvYXJkSXRlbSwgQ29va2llQ2hhbmdlRXZlbnQsIENvb2tpZVN0b3JlLCBDb29raWVTdG9yZU1hbmFnZXIsIENyZWRlbnRpYWwsIENyZWRlbnRpYWxzQ29udGFpbmVyLCBDcnlwdG9LZXksIERldmljZU1vdGlvbkV2ZW50LCBEZXZpY2VNb3Rpb25FdmVudEFjY2VsZXJhdGlvbiwgRGV2aWNlTW90aW9uRXZlbnRSb3RhdGlvblJhdGUsIERldmljZU9yaWVudGF0aW9uRXZlbnQsIEZlZGVyYXRlZENyZWRlbnRpYWwsIEdyYXZpdHlTZW5zb3IsIEd5cm9zY29wZSwgS2V5Ym9hcmQsIEtleWJvYXJkTGF5b3V0TWFwLCBMaW5lYXJBY2NlbGVyYXRpb25TZW5zb3IsIExvY2ssIExvY2tNYW5hZ2VyLCBNSURJQWNjZXNzLCBNSURJQ29ubmVjdGlvbkV2ZW50LCBNSURJSW5wdXQsIE1JRElJbnB1dE1hcCwgTUlESU1lc3NhZ2VFdmVudCwgTUlESU91dHB1dCwgTUlESU91dHB1dE1hcCwgTUlESVBvcnQsIE1lZGlhRGV2aWNlSW5mbywgTWVkaWFEZXZpY2VzLCBNZWRpYUtleU1lc3NhZ2VFdmVudCwgTWVkaWFLZXlTZXNzaW9uLCBNZWRpYUtleVN0YXR1c01hcCwgTWVkaWFLZXlTeXN0ZW1BY2Nlc3MsIE1lZGlhS2V5cywgTmF2aWdhdGlvblByZWxvYWRNYW5hZ2VyLCBOYXZpZ2F0b3JNYW5hZ2VkRGF0YSwgT3JpZW50YXRpb25TZW5zb3IsIFBhc3N3b3JkQ3JlZGVudGlhbCwgUmVsYXRpdmVPcmllbnRhdGlvblNlbnNvciwgU2NyZWVuRGV0YWlsZWQsIFNjcmVlbkRldGFpbHMsIFNlbnNvciwgU2Vuc29yRXJyb3JFdmVudCwgU2VydmljZVdvcmtlciwgU2VydmljZVdvcmtlckNvbnRhaW5lciwgU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbiwgU3RvcmFnZU1hbmFnZXIsIFN1YnRsZUNyeXB0bywgVmlydHVhbEtleWJvYXJkLCBXZWJUcmFuc3BvcnQsIFdlYlRyYW5zcG9ydEJpZGlyZWN0aW9uYWxTdHJlYW0sIFdlYlRyYW5zcG9ydERhdGFncmFtRHVwbGV4U3RyZWFtLCBXZWJUcmFuc3BvcnRFcnJvciwgV29ya2xldCwgWFJET01PdmVybGF5U3RhdGUsIFhSTGF5ZXIsIFhSV2ViR0xCaW5kaW5nLCBBdWRpb0RhdGEsIEVuY29kZWRBdWRpb0NodW5rLCBFbmNvZGVkVmlkZW9DaHVuaywgSW1hZ2VUcmFjaywgSW1hZ2VUcmFja0xpc3QsIFZpZGVvQ29sb3JTcGFjZSwgVmlkZW9GcmFtZSwgQXVkaW9EZWNvZGVyLCBBdWRpb0VuY29kZXIsIEltYWdlRGVjb2RlciwgVmlkZW9EZWNvZGVyLCBWaWRlb0VuY29kZXIsIEF1dGhlbnRpY2F0b3JBc3NlcnRpb25SZXNwb25zZSwgQXV0aGVudGljYXRvckF0dGVzdGF0aW9uUmVzcG9uc2UsIEF1dGhlbnRpY2F0b3JSZXNwb25zZSwgUHVibGljS2V5Q3JlZGVudGlhbCwgQmx1ZXRvb3RoLCBCbHVldG9vdGhDaGFyYWN0ZXJpc3RpY1Byb3BlcnRpZXMsIEJsdWV0b290aERldmljZSwgQmx1ZXRvb3RoUmVtb3RlR0FUVENoYXJhY3RlcmlzdGljLCBCbHVldG9vdGhSZW1vdGVHQVRURGVzY3JpcHRvciwgQmx1ZXRvb3RoUmVtb3RlR0FUVFNlcnZlciwgQmx1ZXRvb3RoUmVtb3RlR0FUVFNlcnZpY2UsIENhcHR1cmVDb250cm9sbGVyLCBFeWVEcm9wcGVyLCBGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlLCBGaWxlU3lzdGVtRmlsZUhhbmRsZSwgRmlsZVN5c3RlbUhhbmRsZSwgRmlsZVN5c3RlbVdyaXRhYmxlRmlsZVN0cmVhbSwgRm9udERhdGEsIEZyYWdtZW50RGlyZWN0aXZlLCBISUQsIEhJRENvbm5lY3Rpb25FdmVudCwgSElERGV2aWNlLCBISURJbnB1dFJlcG9ydEV2ZW50LCBJZGVudGl0eUNyZWRlbnRpYWwsIElkbGVEZXRlY3RvciwgTGF1bmNoUGFyYW1zLCBMYXVuY2hRdWV1ZSwgT1RQQ3JlZGVudGlhbCwgUGF5bWVudEFkZHJlc3MsIFBheW1lbnRSZXF1ZXN0LCBQYXltZW50UmVzcG9uc2UsIFBheW1lbnRNZXRob2RDaGFuZ2VFdmVudCwgUHJlc2VudGF0aW9uLCBQcmVzZW50YXRpb25BdmFpbGFiaWxpdHksIFByZXNlbnRhdGlvbkNvbm5lY3Rpb24sIFByZXNlbnRhdGlvbkNvbm5lY3Rpb25BdmFpbGFibGVFdmVudCwgUHJlc2VudGF0aW9uQ29ubmVjdGlvbkNsb3NlRXZlbnQsIFByZXNlbnRhdGlvbkNvbm5lY3Rpb25MaXN0LCBQcmVzZW50YXRpb25SZWNlaXZlciwgUHJlc2VudGF0aW9uUmVxdWVzdCwgU2FuaXRpemVyLCBTZXJpYWwsIFNlcmlhbFBvcnQsIFVTQiwgVVNCQWx0ZXJuYXRlSW50ZXJmYWNlLCBVU0JDb25maWd1cmF0aW9uLCBVU0JDb25uZWN0aW9uRXZlbnQsIFVTQkRldmljZSwgVVNCRW5kcG9pbnQsIFVTQkluVHJhbnNmZXJSZXN1bHQsIFVTQkludGVyZmFjZSwgVVNCSXNvY2hyb25vdXNJblRyYW5zZmVyUGFja2V0LCBVU0JJc29jaHJvbm91c0luVHJhbnNmZXJSZXN1bHQsIFVTQklzb2Nocm9ub3VzT3V0VHJhbnNmZXJQYWNrZXQsIFVTQklzb2Nocm9ub3VzT3V0VHJhbnNmZXJSZXN1bHQsIFVTQk91dFRyYW5zZmVyUmVzdWx0LCBXYWtlTG9jaywgV2FrZUxvY2tTZW50aW5lbCwgV2luZG93Q29udHJvbHNPdmVybGF5LCBXaW5kb3dDb250cm9sc092ZXJsYXlHZW9tZXRyeUNoYW5nZUV2ZW50LCBYUkFuY2hvciwgWFJBbmNob3JTZXQsIFhSQm91bmRlZFJlZmVyZW5jZVNwYWNlLCBYUkZyYW1lLCBYUklucHV0U291cmNlLCBYUklucHV0U291cmNlQXJyYXksIFhSSW5wdXRTb3VyY2VFdmVudCwgWFJJbnB1dFNvdXJjZXNDaGFuZ2VFdmVudCwgWFJQb3NlLCBYUlJlZmVyZW5jZVNwYWNlLCBYUlJlZmVyZW5jZVNwYWNlRXZlbnQsIFhSUmVuZGVyU3RhdGUsIFhSUmlnaWRUcmFuc2Zvcm0sIFhSU2Vzc2lvbiwgWFJTZXNzaW9uRXZlbnQsIFhSU3BhY2UsIFhSU3lzdGVtLCBYUlZpZXcsIFhSVmlld2VyUG9zZSwgWFJWaWV3cG9ydCwgWFJXZWJHTExheWVyLCBYUkNQVURlcHRoSW5mb3JtYXRpb24sIFhSRGVwdGhJbmZvcm1hdGlvbiwgWFJXZWJHTERlcHRoSW5mb3JtYXRpb24sIFhSQ2FtZXJhLCBYUkhpdFRlc3RSZXN1bHQsIFhSSGl0VGVzdFNvdXJjZSwgWFJSYXksIFhSVHJhbnNpZW50SW5wdXRIaXRUZXN0UmVzdWx0LCBYUlRyYW5zaWVudElucHV0SGl0VGVzdFNvdXJjZSwgWFJMaWdodEVzdGltYXRlLCBYUkxpZ2h0UHJvYmUsIGdldFNjcmVlbkRldGFpbHMsIHF1ZXJ5TG9jYWxGb250cywgc2hvd0RpcmVjdG9yeVBpY2tlciwgc2hvd09wZW5GaWxlUGlja2VyLCBzaG93U2F2ZUZpbGVQaWNrZXIsIG9yaWdpbkFnZW50Q2x1c3RlciwgbmF2aWdhdGlvbiwgd2Via2l0U3RvcmFnZUluZm8sIHNwZWVjaFN5bnRoZXNpcywgb25jb250ZW50dmlzaWJpbGl0eWF1dG9zdGF0ZWNoYW5nZSwgQW5pbWF0aW9uUGxheWJhY2tFdmVudCwgQW5pbWF0aW9uVGltZWxpbmUsIENTU0FuaW1hdGlvbiwgQ1NTVHJhbnNpdGlvbiwgRG9jdW1lbnRUaW1lbGluZSwgQmFja2dyb3VuZEZldGNoTWFuYWdlciwgQmFja2dyb3VuZEZldGNoUmVjb3JkLCBCYWNrZ3JvdW5kRmV0Y2hSZWdpc3RyYXRpb24sIEJsdWV0b290aFVVSUQsIEJyb3dzZXJDYXB0dXJlTWVkaWFTdHJlYW1UcmFjaywgQ3JvcFRhcmdldCwgQ1NTQ29udGFpbmVyUnVsZSwgQ1NTRm9udFBhbGV0dGVWYWx1ZXNSdWxlLCBDb250ZW50VmlzaWJpbGl0eUF1dG9TdGF0ZUNoYW5nZUV2ZW50LCBEZWxlZ2F0ZWRJbmtUcmFpbFByZXNlbnRlciwgSW5rLCBIaWdobGlnaHQsIEhpZ2hsaWdodFJlZ2lzdHJ5LCBNYXRoTUxFbGVtZW50LCBNZWRpYU1ldGFkYXRhLCBNZWRpYVNlc3Npb24sIE1lZGlhU291cmNlLCBTb3VyY2VCdWZmZXIsIFNvdXJjZUJ1ZmZlckxpc3QsIE1lZGlhU291cmNlSGFuZGxlLCBNZWRpYVN0cmVhbVRyYWNrLCBNZWRpYVN0cmVhbVRyYWNrR2VuZXJhdG9yLCBOYXZpZ2F0ZUV2ZW50LCBOYXZpZ2F0aW9uLCBOYXZpZ2F0aW9uQ3VycmVudEVudHJ5Q2hhbmdlRXZlbnQsIE5hdmlnYXRpb25EZXN0aW5hdGlvbiwgTmF2aWdhdGlvbkhpc3RvcnlFbnRyeSwgTmF2aWdhdGlvblRyYW5zaXRpb24sIE5hdmlnYXRvclVBRGF0YSwgTm90aWZpY2F0aW9uLCBQYXltZW50SW5zdHJ1bWVudHMsIFBheW1lbnRNYW5hZ2VyLCBQYXltZW50UmVxdWVzdFVwZGF0ZUV2ZW50LCBQZXJpb2RpY1N5bmNNYW5hZ2VyLCBQZXJtaXNzaW9uU3RhdHVzLCBQZXJtaXNzaW9ucywgUGljdHVyZUluUGljdHVyZUV2ZW50LCBQaWN0dXJlSW5QaWN0dXJlV2luZG93LCBQdXNoTWFuYWdlciwgUHVzaFN1YnNjcmlwdGlvbiwgUHVzaFN1YnNjcmlwdGlvbk9wdGlvbnMsIFJlbW90ZVBsYXliYWNrLCBTaGFyZWRXb3JrZXIsIFNwZWVjaFN5bnRoZXNpc0Vycm9yRXZlbnQsIFNwZWVjaFN5bnRoZXNpc0V2ZW50LCBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UsIFZpZGVvUGxheWJhY2tRdWFsaXR5LCB3ZWJraXRTcGVlY2hHcmFtbWFyLCB3ZWJraXRTcGVlY2hHcmFtbWFyTGlzdCwgd2Via2l0U3BlZWNoUmVjb2duaXRpb24sIHdlYmtpdFNwZWVjaFJlY29nbml0aW9uRXJyb3IsIHdlYmtpdFNwZWVjaFJlY29nbml0aW9uRXZlbnQsIG9wZW5EYXRhYmFzZSwgd2Via2l0UmVxdWVzdEZpbGVTeXN0ZW0sIHdlYmtpdFJlc29sdmVMb2NhbEZpbGVTeXN0ZW1VUkwiLGNzc0tleXM6ImNzc1RleHQsIGxlbmd0aCwgcGFyZW50UnVsZSwgY3NzRmxvYXQsIGdldFByb3BlcnR5UHJpb3JpdHksIGdldFByb3BlcnR5VmFsdWUsIGl0ZW0sIHJlbW92ZVByb3BlcnR5LCBzZXRQcm9wZXJ0eSwgY29uc3RydWN0b3IsIGFjY2VudC1jb2xvciwgYWxpZ24tY29udGVudCwgYWxpZ24taXRlbXMsIGFsaWduLXNlbGYsIGFsaWdubWVudC1iYXNlbGluZSwgYW5pbWF0aW9uLWRlbGF5LCBhbmltYXRpb24tZGlyZWN0aW9uLCBhbmltYXRpb24tZHVyYXRpb24sIGFuaW1hdGlvbi1maWxsLW1vZGUsIGFuaW1hdGlvbi1pdGVyYXRpb24tY291bnQsIGFuaW1hdGlvbi1uYW1lLCBhbmltYXRpb24tcGxheS1zdGF0ZSwgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbiwgYXBwLXJlZ2lvbiwgYXBwZWFyYW5jZSwgYmFja2Ryb3AtZmlsdGVyLCBiYWNrZmFjZS12aXNpYmlsaXR5LCBiYWNrZ3JvdW5kLWF0dGFjaG1lbnQsIGJhY2tncm91bmQtYmxlbmQtbW9kZSwgYmFja2dyb3VuZC1jbGlwLCBiYWNrZ3JvdW5kLWNvbG9yLCBiYWNrZ3JvdW5kLWltYWdlLCBiYWNrZ3JvdW5kLW9yaWdpbiwgYmFja2dyb3VuZC1wb3NpdGlvbiwgYmFja2dyb3VuZC1yZXBlYXQsIGJhY2tncm91bmQtc2l6ZSwgYmFzZWxpbmUtc2hpZnQsIGJsb2NrLXNpemUsIGJvcmRlci1ibG9jay1lbmQtY29sb3IsIGJvcmRlci1ibG9jay1lbmQtc3R5bGUsIGJvcmRlci1ibG9jay1lbmQtd2lkdGgsIGJvcmRlci1ibG9jay1zdGFydC1jb2xvciwgYm9yZGVyLWJsb2NrLXN0YXJ0LXN0eWxlLCBib3JkZXItYmxvY2stc3RhcnQtd2lkdGgsIGJvcmRlci1ib3R0b20tY29sb3IsIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMsIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzLCBib3JkZXItYm90dG9tLXN0eWxlLCBib3JkZXItYm90dG9tLXdpZHRoLCBib3JkZXItY29sbGFwc2UsIGJvcmRlci1lbmQtZW5kLXJhZGl1cywgYm9yZGVyLWVuZC1zdGFydC1yYWRpdXMsIGJvcmRlci1pbWFnZS1vdXRzZXQsIGJvcmRlci1pbWFnZS1yZXBlYXQsIGJvcmRlci1pbWFnZS1zbGljZSwgYm9yZGVyLWltYWdlLXNvdXJjZSwgYm9yZGVyLWltYWdlLXdpZHRoLCBib3JkZXItaW5saW5lLWVuZC1jb2xvciwgYm9yZGVyLWlubGluZS1lbmQtc3R5bGUsIGJvcmRlci1pbmxpbmUtZW5kLXdpZHRoLCBib3JkZXItaW5saW5lLXN0YXJ0LWNvbG9yLCBib3JkZXItaW5saW5lLXN0YXJ0LXN0eWxlLCBib3JkZXItaW5saW5lLXN0YXJ0LXdpZHRoLCBib3JkZXItbGVmdC1jb2xvciwgYm9yZGVyLWxlZnQtc3R5bGUsIGJvcmRlci1sZWZ0LXdpZHRoLCBib3JkZXItcmlnaHQtY29sb3IsIGJvcmRlci1yaWdodC1zdHlsZSwgYm9yZGVyLXJpZ2h0LXdpZHRoLCBib3JkZXItc3RhcnQtZW5kLXJhZGl1cywgYm9yZGVyLXN0YXJ0LXN0YXJ0LXJhZGl1cywgYm9yZGVyLXRvcC1jb2xvciwgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cywgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMsIGJvcmRlci10b3Atc3R5bGUsIGJvcmRlci10b3Atd2lkdGgsIGJvdHRvbSwgYm94LXNoYWRvdywgYm94LXNpemluZywgYnJlYWstYWZ0ZXIsIGJyZWFrLWJlZm9yZSwgYnJlYWstaW5zaWRlLCBidWZmZXJlZC1yZW5kZXJpbmcsIGNhcHRpb24tc2lkZSwgY2FyZXQtY29sb3IsIGNsZWFyLCBjbGlwLCBjbGlwLXBhdGgsIGNsaXAtcnVsZSwgY29sb3IsIGNvbG9yLWludGVycG9sYXRpb24sIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycywgY29sb3ItcmVuZGVyaW5nLCBjb2x1bW4tY291bnQsIGNvbHVtbi1nYXAsIGNvbHVtbi1ydWxlLWNvbG9yLCBjb2x1bW4tcnVsZS1zdHlsZSwgY29sdW1uLXJ1bGUtd2lkdGgsIGNvbHVtbi1zcGFuLCBjb2x1bW4td2lkdGgsIGNvbnRhaW4taW50cmluc2ljLWJsb2NrLXNpemUsIGNvbnRhaW4taW50cmluc2ljLWhlaWdodCwgY29udGFpbi1pbnRyaW5zaWMtaW5saW5lLXNpemUsIGNvbnRhaW4taW50cmluc2ljLXNpemUsIGNvbnRhaW4taW50cmluc2ljLXdpZHRoLCBjb250YWluZXItbmFtZSwgY29udGFpbmVyLXR5cGUsIGNvbnRlbnQsIGN1cnNvciwgY3gsIGN5LCBkLCBkaXJlY3Rpb24sIGRpc3BsYXksIGRvbWluYW50LWJhc2VsaW5lLCBlbXB0eS1jZWxscywgZmlsbCwgZmlsbC1vcGFjaXR5LCBmaWxsLXJ1bGUsIGZpbHRlciwgZmxleC1iYXNpcywgZmxleC1kaXJlY3Rpb24sIGZsZXgtZ3JvdywgZmxleC1zaHJpbmssIGZsZXgtd3JhcCwgZmxvYXQsIGZsb29kLWNvbG9yLCBmbG9vZC1vcGFjaXR5LCBmb250LWZhbWlseSwgZm9udC1rZXJuaW5nLCBmb250LW9wdGljYWwtc2l6aW5nLCBmb250LXBhbGV0dGUsIGZvbnQtc2l6ZSwgZm9udC1zdHJldGNoLCBmb250LXN0eWxlLCBmb250LXN5bnRoZXNpcy1zbWFsbC1jYXBzLCBmb250LXN5bnRoZXNpcy1zdHlsZSwgZm9udC1zeW50aGVzaXMtd2VpZ2h0LCBmb250LXZhcmlhbnQsIGZvbnQtdmFyaWFudC1jYXBzLCBmb250LXZhcmlhbnQtZWFzdC1hc2lhbiwgZm9udC12YXJpYW50LWxpZ2F0dXJlcywgZm9udC12YXJpYW50LW51bWVyaWMsIGZvbnQtd2VpZ2h0LCBncmlkLWF1dG8tY29sdW1ucywgZ3JpZC1hdXRvLWZsb3csIGdyaWQtYXV0by1yb3dzLCBncmlkLWNvbHVtbi1lbmQsIGdyaWQtY29sdW1uLXN0YXJ0LCBncmlkLXJvdy1lbmQsIGdyaWQtcm93LXN0YXJ0LCBncmlkLXRlbXBsYXRlLWFyZWFzLCBncmlkLXRlbXBsYXRlLWNvbHVtbnMsIGdyaWQtdGVtcGxhdGUtcm93cywgaGVpZ2h0LCBoeXBoZW5hdGUtY2hhcmFjdGVyLCBoeXBoZW5hdGUtbGltaXQtY2hhcnMsIGh5cGhlbnMsIGltYWdlLW9yaWVudGF0aW9uLCBpbWFnZS1yZW5kZXJpbmcsIGlubGluZS1zaXplLCBpbnNldC1ibG9jay1lbmQsIGluc2V0LWJsb2NrLXN0YXJ0LCBpbnNldC1pbmxpbmUtZW5kLCBpbnNldC1pbmxpbmUtc3RhcnQsIGlzb2xhdGlvbiwganVzdGlmeS1jb250ZW50LCBqdXN0aWZ5LWl0ZW1zLCBqdXN0aWZ5LXNlbGYsIGxlZnQsIGxldHRlci1zcGFjaW5nLCBsaWdodGluZy1jb2xvciwgbGluZS1icmVhaywgbGluZS1oZWlnaHQsIGxpc3Qtc3R5bGUtaW1hZ2UsIGxpc3Qtc3R5bGUtcG9zaXRpb24sIGxpc3Qtc3R5bGUtdHlwZSwgbWFyZ2luLWJsb2NrLWVuZCwgbWFyZ2luLWJsb2NrLXN0YXJ0LCBtYXJnaW4tYm90dG9tLCBtYXJnaW4taW5saW5lLWVuZCwgbWFyZ2luLWlubGluZS1zdGFydCwgbWFyZ2luLWxlZnQsIG1hcmdpbi1yaWdodCwgbWFyZ2luLXRvcCwgbWFya2VyLWVuZCwgbWFya2VyLW1pZCwgbWFya2VyLXN0YXJ0LCBtYXNrLXR5cGUsIG1hdGgtZGVwdGgsIG1hdGgtc2hpZnQsIG1hdGgtc3R5bGUsIG1heC1ibG9jay1zaXplLCBtYXgtaGVpZ2h0LCBtYXgtaW5saW5lLXNpemUsIG1heC13aWR0aCwgbWluLWJsb2NrLXNpemUsIG1pbi1oZWlnaHQsIG1pbi1pbmxpbmUtc2l6ZSwgbWluLXdpZHRoLCBtaXgtYmxlbmQtbW9kZSwgb2JqZWN0LWZpdCwgb2JqZWN0LXBvc2l0aW9uLCBvYmplY3Qtdmlldy1ib3gsIG9mZnNldC1kaXN0YW5jZSwgb2Zmc2V0LXBhdGgsIG9mZnNldC1yb3RhdGUsIG9wYWNpdHksIG9yZGVyLCBvcnBoYW5zLCBvdXRsaW5lLWNvbG9yLCBvdXRsaW5lLW9mZnNldCwgb3V0bGluZS1zdHlsZSwgb3V0bGluZS13aWR0aCwgb3ZlcmZsb3ctYW5jaG9yLCBvdmVyZmxvdy1jbGlwLW1hcmdpbiwgb3ZlcmZsb3ctd3JhcCwgb3ZlcmZsb3cteCwgb3ZlcmZsb3cteSwgb3ZlcnNjcm9sbC1iZWhhdmlvci1ibG9jaywgb3ZlcnNjcm9sbC1iZWhhdmlvci1pbmxpbmUsIHBhZGRpbmctYmxvY2stZW5kLCBwYWRkaW5nLWJsb2NrLXN0YXJ0LCBwYWRkaW5nLWJvdHRvbSwgcGFkZGluZy1pbmxpbmUtZW5kLCBwYWRkaW5nLWlubGluZS1zdGFydCwgcGFkZGluZy1sZWZ0LCBwYWRkaW5nLXJpZ2h0LCBwYWRkaW5nLXRvcCwgcGFpbnQtb3JkZXIsIHBlcnNwZWN0aXZlLCBwZXJzcGVjdGl2ZS1vcmlnaW4sIHBvaW50ZXItZXZlbnRzLCBwb3NpdGlvbiwgciwgcmVzaXplLCByaWdodCwgcm90YXRlLCByb3ctZ2FwLCBydWJ5LXBvc2l0aW9uLCByeCwgcnksIHNjYWxlLCBzY3JvbGwtYmVoYXZpb3IsIHNjcm9sbC1tYXJnaW4tYmxvY2stZW5kLCBzY3JvbGwtbWFyZ2luLWJsb2NrLXN0YXJ0LCBzY3JvbGwtbWFyZ2luLWlubGluZS1lbmQsIHNjcm9sbC1tYXJnaW4taW5saW5lLXN0YXJ0LCBzY3JvbGwtcGFkZGluZy1ibG9jay1lbmQsIHNjcm9sbC1wYWRkaW5nLWJsb2NrLXN0YXJ0LCBzY3JvbGwtcGFkZGluZy1pbmxpbmUtZW5kLCBzY3JvbGwtcGFkZGluZy1pbmxpbmUtc3RhcnQsIHNjcm9sbGJhci1ndXR0ZXIsIHNoYXBlLWltYWdlLXRocmVzaG9sZCwgc2hhcGUtbWFyZ2luLCBzaGFwZS1vdXRzaWRlLCBzaGFwZS1yZW5kZXJpbmcsIHNwZWFrLCBzdG9wLWNvbG9yLCBzdG9wLW9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlLWRhc2hhcnJheSwgc3Ryb2tlLWRhc2hvZmZzZXQsIHN0cm9rZS1saW5lY2FwLCBzdHJva2UtbGluZWpvaW4sIHN0cm9rZS1taXRlcmxpbWl0LCBzdHJva2Utb3BhY2l0eSwgc3Ryb2tlLXdpZHRoLCB0YWItc2l6ZSwgdGFibGUtbGF5b3V0LCB0ZXh0LWFsaWduLCB0ZXh0LWFsaWduLWxhc3QsIHRleHQtYW5jaG9yLCB0ZXh0LWRlY29yYXRpb24sIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWxpbmUsIHRleHQtZGVjb3JhdGlvbi1za2lwLWluaywgdGV4dC1kZWNvcmF0aW9uLXN0eWxlLCB0ZXh0LWVtcGhhc2lzLWNvbG9yLCB0ZXh0LWVtcGhhc2lzLXBvc2l0aW9uLCB0ZXh0LWVtcGhhc2lzLXN0eWxlLCB0ZXh0LWluZGVudCwgdGV4dC1vdmVyZmxvdywgdGV4dC1yZW5kZXJpbmcsIHRleHQtc2hhZG93LCB0ZXh0LXNpemUtYWRqdXN0LCB0ZXh0LXRyYW5zZm9ybSwgdGV4dC11bmRlcmxpbmUtcG9zaXRpb24sIHRvcCwgdG91Y2gtYWN0aW9uLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybS1vcmlnaW4sIHRyYW5zZm9ybS1zdHlsZSwgdHJhbnNpdGlvbi1kZWxheSwgdHJhbnNpdGlvbi1kdXJhdGlvbiwgdHJhbnNpdGlvbi1wcm9wZXJ0eSwgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24sIHRyYW5zbGF0ZSwgdW5pY29kZS1iaWRpLCB1c2VyLXNlbGVjdCwgdmVjdG9yLWVmZmVjdCwgdmVydGljYWwtYWxpZ24sIHZpc2liaWxpdHksIHdoaXRlLXNwYWNlLCB3aWRvd3MsIHdpZHRoLCB3aWxsLWNoYW5nZSwgd29yZC1icmVhaywgd29yZC1zcGFjaW5nLCB3cml0aW5nLW1vZGUsIHgsIHksIHotaW5kZXgsIHpvb20sIC13ZWJraXQtYm9yZGVyLWhvcml6b250YWwtc3BhY2luZywgLXdlYmtpdC1ib3JkZXItaW1hZ2UsIC13ZWJraXQtYm9yZGVyLXZlcnRpY2FsLXNwYWNpbmcsIC13ZWJraXQtYm94LWFsaWduLCAtd2Via2l0LWJveC1kZWNvcmF0aW9uLWJyZWFrLCAtd2Via2l0LWJveC1kaXJlY3Rpb24sIC13ZWJraXQtYm94LWZsZXgsIC13ZWJraXQtYm94LW9yZGluYWwtZ3JvdXAsIC13ZWJraXQtYm94LW9yaWVudCwgLXdlYmtpdC1ib3gtcGFjaywgLXdlYmtpdC1ib3gtcmVmbGVjdCwgLXdlYmtpdC1mb250LXNtb290aGluZywgLXdlYmtpdC1oaWdobGlnaHQsIC13ZWJraXQtbGluZS1icmVhaywgLXdlYmtpdC1saW5lLWNsYW1wLCAtd2Via2l0LWxvY2FsZSwgLXdlYmtpdC1tYXNrLWJveC1pbWFnZSwgLXdlYmtpdC1tYXNrLWJveC1pbWFnZS1vdXRzZXQsIC13ZWJraXQtbWFzay1ib3gtaW1hZ2UtcmVwZWF0LCAtd2Via2l0LW1hc2stYm94LWltYWdlLXNsaWNlLCAtd2Via2l0LW1hc2stYm94LWltYWdlLXNvdXJjZSwgLXdlYmtpdC1tYXNrLWJveC1pbWFnZS13aWR0aCwgLXdlYmtpdC1tYXNrLWNsaXAsIC13ZWJraXQtbWFzay1jb21wb3NpdGUsIC13ZWJraXQtbWFzay1pbWFnZSwgLXdlYmtpdC1tYXNrLW9yaWdpbiwgLXdlYmtpdC1tYXNrLXBvc2l0aW9uLCAtd2Via2l0LW1hc2stcmVwZWF0LCAtd2Via2l0LW1hc2stc2l6ZSwgLXdlYmtpdC1wcmludC1jb2xvci1hZGp1c3QsIC13ZWJraXQtcnRsLW9yZGVyaW5nLCAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3IsIC13ZWJraXQtdGV4dC1jb21iaW5lLCAtd2Via2l0LXRleHQtZGVjb3JhdGlvbnMtaW4tZWZmZWN0LCAtd2Via2l0LXRleHQtZmlsbC1jb2xvciwgLXdlYmtpdC10ZXh0LW9yaWVudGF0aW9uLCAtd2Via2l0LXRleHQtc2VjdXJpdHksIC13ZWJraXQtdGV4dC1zdHJva2UtY29sb3IsIC13ZWJraXQtdGV4dC1zdHJva2Utd2lkdGgsIC13ZWJraXQtdXNlci1kcmFnLCAtd2Via2l0LXVzZXItbW9kaWZ5LCAtd2Via2l0LXdyaXRpbmctbW9kZSwgYWNjZW50Q29sb3IsIGFkZGl0aXZlU3ltYm9scywgYWxpZ25Db250ZW50LCBhbGlnbkl0ZW1zLCBhbGlnblNlbGYsIGFsaWdubWVudEJhc2VsaW5lLCBhbGwsIGFuaW1hdGlvbiwgYW5pbWF0aW9uRGVsYXksIGFuaW1hdGlvbkRpcmVjdGlvbiwgYW5pbWF0aW9uRHVyYXRpb24sIGFuaW1hdGlvbkZpbGxNb2RlLCBhbmltYXRpb25JdGVyYXRpb25Db3VudCwgYW5pbWF0aW9uTmFtZSwgYW5pbWF0aW9uUGxheVN0YXRlLCBhbmltYXRpb25UaW1pbmdGdW5jdGlvbiwgYXBwUmVnaW9uLCBhc2NlbnRPdmVycmlkZSwgYXNwZWN0UmF0aW8sIGJhY2tkcm9wRmlsdGVyLCBiYWNrZmFjZVZpc2liaWxpdHksIGJhY2tncm91bmQsIGJhY2tncm91bmRBdHRhY2htZW50LCBiYWNrZ3JvdW5kQmxlbmRNb2RlLCBiYWNrZ3JvdW5kQ2xpcCwgYmFja2dyb3VuZENvbG9yLCBiYWNrZ3JvdW5kSW1hZ2UsIGJhY2tncm91bmRPcmlnaW4sIGJhY2tncm91bmRQb3NpdGlvbiwgYmFja2dyb3VuZFBvc2l0aW9uWCwgYmFja2dyb3VuZFBvc2l0aW9uWSwgYmFja2dyb3VuZFJlcGVhdCwgYmFja2dyb3VuZFJlcGVhdFgsIGJhY2tncm91bmRSZXBlYXRZLCBiYWNrZ3JvdW5kU2l6ZSwgYmFzZVBhbGV0dGUsIGJhc2VsaW5lU2hpZnQsIGJsb2NrU2l6ZSwgYm9yZGVyLCBib3JkZXJCbG9jaywgYm9yZGVyQmxvY2tDb2xvciwgYm9yZGVyQmxvY2tFbmQsIGJvcmRlckJsb2NrRW5kQ29sb3IsIGJvcmRlckJsb2NrRW5kU3R5bGUsIGJvcmRlckJsb2NrRW5kV2lkdGgsIGJvcmRlckJsb2NrU3RhcnQsIGJvcmRlckJsb2NrU3RhcnRDb2xvciwgYm9yZGVyQmxvY2tTdGFydFN0eWxlLCBib3JkZXJCbG9ja1N0YXJ0V2lkdGgsIGJvcmRlckJsb2NrU3R5bGUsIGJvcmRlckJsb2NrV2lkdGgsIGJvcmRlckJvdHRvbSwgYm9yZGVyQm90dG9tQ29sb3IsIGJvcmRlckJvdHRvbUxlZnRSYWRpdXMsIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLCBib3JkZXJCb3R0b21TdHlsZSwgYm9yZGVyQm90dG9tV2lkdGgsIGJvcmRlckNvbGxhcHNlLCBib3JkZXJDb2xvciwgYm9yZGVyRW5kRW5kUmFkaXVzLCBib3JkZXJFbmRTdGFydFJhZGl1cywgYm9yZGVySW1hZ2UsIGJvcmRlckltYWdlT3V0c2V0LCBib3JkZXJJbWFnZVJlcGVhdCwgYm9yZGVySW1hZ2VTbGljZSwgYm9yZGVySW1hZ2VTb3VyY2UsIGJvcmRlckltYWdlV2lkdGgsIGJvcmRlcklubGluZSwgYm9yZGVySW5saW5lQ29sb3IsIGJvcmRlcklubGluZUVuZCwgYm9yZGVySW5saW5lRW5kQ29sb3IsIGJvcmRlcklubGluZUVuZFN0eWxlLCBib3JkZXJJbmxpbmVFbmRXaWR0aCwgYm9yZGVySW5saW5lU3RhcnQsIGJvcmRlcklubGluZVN0YXJ0Q29sb3IsIGJvcmRlcklubGluZVN0YXJ0U3R5bGUsIGJvcmRlcklubGluZVN0YXJ0V2lkdGgsIGJvcmRlcklubGluZVN0eWxlLCBib3JkZXJJbmxpbmVXaWR0aCwgYm9yZGVyTGVmdCwgYm9yZGVyTGVmdENvbG9yLCBib3JkZXJMZWZ0U3R5bGUsIGJvcmRlckxlZnRXaWR0aCwgYm9yZGVyUmFkaXVzLCBib3JkZXJSaWdodCwgYm9yZGVyUmlnaHRDb2xvciwgYm9yZGVyUmlnaHRTdHlsZSwgYm9yZGVyUmlnaHRXaWR0aCwgYm9yZGVyU3BhY2luZywgYm9yZGVyU3RhcnRFbmRSYWRpdXMsIGJvcmRlclN0YXJ0U3RhcnRSYWRpdXMsIGJvcmRlclN0eWxlLCBib3JkZXJUb3AsIGJvcmRlclRvcENvbG9yLCBib3JkZXJUb3BMZWZ0UmFkaXVzLCBib3JkZXJUb3BSaWdodFJhZGl1cywgYm9yZGVyVG9wU3R5bGUsIGJvcmRlclRvcFdpZHRoLCBib3JkZXJXaWR0aCwgYm94U2hhZG93LCBib3hTaXppbmcsIGJyZWFrQWZ0ZXIsIGJyZWFrQmVmb3JlLCBicmVha0luc2lkZSwgYnVmZmVyZWRSZW5kZXJpbmcsIGNhcHRpb25TaWRlLCBjYXJldENvbG9yLCBjbGlwUGF0aCwgY2xpcFJ1bGUsIGNvbG9ySW50ZXJwb2xhdGlvbiwgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycywgY29sb3JSZW5kZXJpbmcsIGNvbG9yU2NoZW1lLCBjb2x1bW5Db3VudCwgY29sdW1uRmlsbCwgY29sdW1uR2FwLCBjb2x1bW5SdWxlLCBjb2x1bW5SdWxlQ29sb3IsIGNvbHVtblJ1bGVTdHlsZSwgY29sdW1uUnVsZVdpZHRoLCBjb2x1bW5TcGFuLCBjb2x1bW5XaWR0aCwgY29sdW1ucywgY29udGFpbiwgY29udGFpbkludHJpbnNpY0Jsb2NrU2l6ZSwgY29udGFpbkludHJpbnNpY0hlaWdodCwgY29udGFpbkludHJpbnNpY0lubGluZVNpemUsIGNvbnRhaW5JbnRyaW5zaWNTaXplLCBjb250YWluSW50cmluc2ljV2lkdGgsIGNvbnRhaW5lciwgY29udGFpbmVyTmFtZSwgY29udGFpbmVyVHlwZSwgY29udGVudFZpc2liaWxpdHksIGNvdW50ZXJJbmNyZW1lbnQsIGNvdW50ZXJSZXNldCwgY291bnRlclNldCwgZGVzY2VudE92ZXJyaWRlLCBkb21pbmFudEJhc2VsaW5lLCBlbXB0eUNlbGxzLCBmYWxsYmFjaywgZmlsbE9wYWNpdHksIGZpbGxSdWxlLCBmbGV4LCBmbGV4QmFzaXMsIGZsZXhEaXJlY3Rpb24sIGZsZXhGbG93LCBmbGV4R3JvdywgZmxleFNocmluaywgZmxleFdyYXAsIGZsb29kQ29sb3IsIGZsb29kT3BhY2l0eSwgZm9udCwgZm9udERpc3BsYXksIGZvbnRGYW1pbHksIGZvbnRGZWF0dXJlU2V0dGluZ3MsIGZvbnRLZXJuaW5nLCBmb250T3B0aWNhbFNpemluZywgZm9udFBhbGV0dGUsIGZvbnRTaXplLCBmb250U3RyZXRjaCwgZm9udFN0eWxlLCBmb250U3ludGhlc2lzLCBmb250U3ludGhlc2lzU21hbGxDYXBzLCBmb250U3ludGhlc2lzU3R5bGUsIGZvbnRTeW50aGVzaXNXZWlnaHQsIGZvbnRWYXJpYW50LCBmb250VmFyaWFudENhcHMsIGZvbnRWYXJpYW50RWFzdEFzaWFuLCBmb250VmFyaWFudExpZ2F0dXJlcywgZm9udFZhcmlhbnROdW1lcmljLCBmb250VmFyaWF0aW9uU2V0dGluZ3MsIGZvbnRXZWlnaHQsIGZvcmNlZENvbG9yQWRqdXN0LCBnYXAsIGdyaWQsIGdyaWRBcmVhLCBncmlkQXV0b0NvbHVtbnMsIGdyaWRBdXRvRmxvdywgZ3JpZEF1dG9Sb3dzLCBncmlkQ29sdW1uLCBncmlkQ29sdW1uRW5kLCBncmlkQ29sdW1uR2FwLCBncmlkQ29sdW1uU3RhcnQsIGdyaWRHYXAsIGdyaWRSb3csIGdyaWRSb3dFbmQsIGdyaWRSb3dHYXAsIGdyaWRSb3dTdGFydCwgZ3JpZFRlbXBsYXRlLCBncmlkVGVtcGxhdGVBcmVhcywgZ3JpZFRlbXBsYXRlQ29sdW1ucywgZ3JpZFRlbXBsYXRlUm93cywgaHlwaGVuYXRlQ2hhcmFjdGVyLCBoeXBoZW5hdGVMaW1pdENoYXJzLCBpbWFnZU9yaWVudGF0aW9uLCBpbWFnZVJlbmRlcmluZywgaW5oZXJpdHMsIGluaXRpYWxWYWx1ZSwgaW5saW5lU2l6ZSwgaW5zZXQsIGluc2V0QmxvY2ssIGluc2V0QmxvY2tFbmQsIGluc2V0QmxvY2tTdGFydCwgaW5zZXRJbmxpbmUsIGluc2V0SW5saW5lRW5kLCBpbnNldElubGluZVN0YXJ0LCBqdXN0aWZ5Q29udGVudCwganVzdGlmeUl0ZW1zLCBqdXN0aWZ5U2VsZiwgbGV0dGVyU3BhY2luZywgbGlnaHRpbmdDb2xvciwgbGluZUJyZWFrLCBsaW5lR2FwT3ZlcnJpZGUsIGxpbmVIZWlnaHQsIGxpc3RTdHlsZSwgbGlzdFN0eWxlSW1hZ2UsIGxpc3RTdHlsZVBvc2l0aW9uLCBsaXN0U3R5bGVUeXBlLCBtYXJnaW4sIG1hcmdpbkJsb2NrLCBtYXJnaW5CbG9ja0VuZCwgbWFyZ2luQmxvY2tTdGFydCwgbWFyZ2luQm90dG9tLCBtYXJnaW5JbmxpbmUsIG1hcmdpbklubGluZUVuZCwgbWFyZ2luSW5saW5lU3RhcnQsIG1hcmdpbkxlZnQsIG1hcmdpblJpZ2h0LCBtYXJnaW5Ub3AsIG1hcmtlciwgbWFya2VyRW5kLCBtYXJrZXJNaWQsIG1hcmtlclN0YXJ0LCBtYXNrLCBtYXNrVHlwZSwgbWF0aERlcHRoLCBtYXRoU2hpZnQsIG1hdGhTdHlsZSwgbWF4QmxvY2tTaXplLCBtYXhIZWlnaHQsIG1heElubGluZVNpemUsIG1heFdpZHRoLCBtaW5CbG9ja1NpemUsIG1pbkhlaWdodCwgbWluSW5saW5lU2l6ZSwgbWluV2lkdGgsIG1peEJsZW5kTW9kZSwgbmVnYXRpdmUsIG9iamVjdEZpdCwgb2JqZWN0UG9zaXRpb24sIG9iamVjdFZpZXdCb3gsIG9mZnNldCwgb2Zmc2V0RGlzdGFuY2UsIG9mZnNldFBhdGgsIG9mZnNldFJvdGF0ZSwgb3V0bGluZSwgb3V0bGluZUNvbG9yLCBvdXRsaW5lT2Zmc2V0LCBvdXRsaW5lU3R5bGUsIG91dGxpbmVXaWR0aCwgb3ZlcmZsb3csIG92ZXJmbG93QW5jaG9yLCBvdmVyZmxvd0NsaXBNYXJnaW4sIG92ZXJmbG93V3JhcCwgb3ZlcmZsb3dYLCBvdmVyZmxvd1ksIG92ZXJyaWRlQ29sb3JzLCBvdmVyc2Nyb2xsQmVoYXZpb3IsIG92ZXJzY3JvbGxCZWhhdmlvckJsb2NrLCBvdmVyc2Nyb2xsQmVoYXZpb3JJbmxpbmUsIG92ZXJzY3JvbGxCZWhhdmlvclgsIG92ZXJzY3JvbGxCZWhhdmlvclksIHBhZCwgcGFkZGluZywgcGFkZGluZ0Jsb2NrLCBwYWRkaW5nQmxvY2tFbmQsIHBhZGRpbmdCbG9ja1N0YXJ0LCBwYWRkaW5nQm90dG9tLCBwYWRkaW5nSW5saW5lLCBwYWRkaW5nSW5saW5lRW5kLCBwYWRkaW5nSW5saW5lU3RhcnQsIHBhZGRpbmdMZWZ0LCBwYWRkaW5nUmlnaHQsIHBhZGRpbmdUb3AsIHBhZ2UsIHBhZ2VCcmVha0FmdGVyLCBwYWdlQnJlYWtCZWZvcmUsIHBhZ2VCcmVha0luc2lkZSwgcGFnZU9yaWVudGF0aW9uLCBwYWludE9yZGVyLCBwZXJzcGVjdGl2ZU9yaWdpbiwgcGxhY2VDb250ZW50LCBwbGFjZUl0ZW1zLCBwbGFjZVNlbGYsIHBvaW50ZXJFdmVudHMsIHByZWZpeCwgcXVvdGVzLCByYW5nZSwgcm93R2FwLCBydWJ5UG9zaXRpb24sIHNjcm9sbEJlaGF2aW9yLCBzY3JvbGxNYXJnaW4sIHNjcm9sbE1hcmdpbkJsb2NrLCBzY3JvbGxNYXJnaW5CbG9ja0VuZCwgc2Nyb2xsTWFyZ2luQmxvY2tTdGFydCwgc2Nyb2xsTWFyZ2luQm90dG9tLCBzY3JvbGxNYXJnaW5JbmxpbmUsIHNjcm9sbE1hcmdpbklubGluZUVuZCwgc2Nyb2xsTWFyZ2luSW5saW5lU3RhcnQsIHNjcm9sbE1hcmdpbkxlZnQsIHNjcm9sbE1hcmdpblJpZ2h0LCBzY3JvbGxNYXJnaW5Ub3AsIHNjcm9sbFBhZGRpbmcsIHNjcm9sbFBhZGRpbmdCbG9jaywgc2Nyb2xsUGFkZGluZ0Jsb2NrRW5kLCBzY3JvbGxQYWRkaW5nQmxvY2tTdGFydCwgc2Nyb2xsUGFkZGluZ0JvdHRvbSwgc2Nyb2xsUGFkZGluZ0lubGluZSwgc2Nyb2xsUGFkZGluZ0lubGluZUVuZCwgc2Nyb2xsUGFkZGluZ0lubGluZVN0YXJ0LCBzY3JvbGxQYWRkaW5nTGVmdCwgc2Nyb2xsUGFkZGluZ1JpZ2h0LCBzY3JvbGxQYWRkaW5nVG9wLCBzY3JvbGxTbmFwQWxpZ24sIHNjcm9sbFNuYXBTdG9wLCBzY3JvbGxTbmFwVHlwZSwgc2Nyb2xsYmFyR3V0dGVyLCBzaGFwZUltYWdlVGhyZXNob2xkLCBzaGFwZU1hcmdpbiwgc2hhcGVPdXRzaWRlLCBzaGFwZVJlbmRlcmluZywgc2l6ZSwgc2l6ZUFkanVzdCwgc3BlYWtBcywgc3JjLCBzdG9wQ29sb3IsIHN0b3BPcGFjaXR5LCBzdHJva2VEYXNoYXJyYXksIHN0cm9rZURhc2hvZmZzZXQsIHN0cm9rZUxpbmVjYXAsIHN0cm9rZUxpbmVqb2luLCBzdHJva2VNaXRlcmxpbWl0LCBzdHJva2VPcGFjaXR5LCBzdHJva2VXaWR0aCwgc3VmZml4LCBzeW1ib2xzLCBzeW50YXgsIHN5c3RlbSwgdGFiU2l6ZSwgdGFibGVMYXlvdXQsIHRleHRBbGlnbiwgdGV4dEFsaWduTGFzdCwgdGV4dEFuY2hvciwgdGV4dENvbWJpbmVVcHJpZ2h0LCB0ZXh0RGVjb3JhdGlvbiwgdGV4dERlY29yYXRpb25Db2xvciwgdGV4dERlY29yYXRpb25MaW5lLCB0ZXh0RGVjb3JhdGlvblNraXBJbmssIHRleHREZWNvcmF0aW9uU3R5bGUsIHRleHREZWNvcmF0aW9uVGhpY2tuZXNzLCB0ZXh0RW1waGFzaXMsIHRleHRFbXBoYXNpc0NvbG9yLCB0ZXh0RW1waGFzaXNQb3NpdGlvbiwgdGV4dEVtcGhhc2lzU3R5bGUsIHRleHRJbmRlbnQsIHRleHRPcmllbnRhdGlvbiwgdGV4dE92ZXJmbG93LCB0ZXh0UmVuZGVyaW5nLCB0ZXh0U2hhZG93LCB0ZXh0U2l6ZUFkanVzdCwgdGV4dFRyYW5zZm9ybSwgdGV4dFVuZGVybGluZU9mZnNldCwgdGV4dFVuZGVybGluZVBvc2l0aW9uLCB0b3VjaEFjdGlvbiwgdHJhbnNmb3JtQm94LCB0cmFuc2Zvcm1PcmlnaW4sIHRyYW5zZm9ybVN0eWxlLCB0cmFuc2l0aW9uLCB0cmFuc2l0aW9uRGVsYXksIHRyYW5zaXRpb25EdXJhdGlvbiwgdHJhbnNpdGlvblByb3BlcnR5LCB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24sIHVuaWNvZGVCaWRpLCB1bmljb2RlUmFuZ2UsIHVzZXJTZWxlY3QsIHZlY3RvckVmZmVjdCwgdmVydGljYWxBbGlnbiwgd2Via2l0QWxpZ25Db250ZW50LCB3ZWJraXRBbGlnbkl0ZW1zLCB3ZWJraXRBbGlnblNlbGYsIHdlYmtpdEFuaW1hdGlvbiwgd2Via2l0QW5pbWF0aW9uRGVsYXksIHdlYmtpdEFuaW1hdGlvbkRpcmVjdGlvbiwgd2Via2l0QW5pbWF0aW9uRHVyYXRpb24sIHdlYmtpdEFuaW1hdGlvbkZpbGxNb2RlLCB3ZWJraXRBbmltYXRpb25JdGVyYXRpb25Db3VudCwgd2Via2l0QW5pbWF0aW9uTmFtZSwgd2Via2l0QW5pbWF0aW9uUGxheVN0YXRlLCB3ZWJraXRBbmltYXRpb25UaW1pbmdGdW5jdGlvbiwgd2Via2l0QXBwUmVnaW9uLCB3ZWJraXRBcHBlYXJhbmNlLCB3ZWJraXRCYWNrZmFjZVZpc2liaWxpdHksIHdlYmtpdEJhY2tncm91bmRDbGlwLCB3ZWJraXRCYWNrZ3JvdW5kT3JpZ2luLCB3ZWJraXRCYWNrZ3JvdW5kU2l6ZSwgd2Via2l0Qm9yZGVyQWZ0ZXIsIHdlYmtpdEJvcmRlckFmdGVyQ29sb3IsIHdlYmtpdEJvcmRlckFmdGVyU3R5bGUsIHdlYmtpdEJvcmRlckFmdGVyV2lkdGgsIHdlYmtpdEJvcmRlckJlZm9yZSwgd2Via2l0Qm9yZGVyQmVmb3JlQ29sb3IsIHdlYmtpdEJvcmRlckJlZm9yZVN0eWxlLCB3ZWJraXRCb3JkZXJCZWZvcmVXaWR0aCwgd2Via2l0Qm9yZGVyQm90dG9tTGVmdFJhZGl1cywgd2Via2l0Qm9yZGVyQm90dG9tUmlnaHRSYWRpdXMsIHdlYmtpdEJvcmRlckVuZCwgd2Via2l0Qm9yZGVyRW5kQ29sb3IsIHdlYmtpdEJvcmRlckVuZFN0eWxlLCB3ZWJraXRCb3JkZXJFbmRXaWR0aCwgd2Via2l0Qm9yZGVySG9yaXpvbnRhbFNwYWNpbmcsIHdlYmtpdEJvcmRlckltYWdlLCB3ZWJraXRCb3JkZXJSYWRpdXMsIHdlYmtpdEJvcmRlclN0YXJ0LCB3ZWJraXRCb3JkZXJTdGFydENvbG9yLCB3ZWJraXRCb3JkZXJTdGFydFN0eWxlLCB3ZWJraXRCb3JkZXJTdGFydFdpZHRoLCB3ZWJraXRCb3JkZXJUb3BMZWZ0UmFkaXVzLCB3ZWJraXRCb3JkZXJUb3BSaWdodFJhZGl1cywgd2Via2l0Qm9yZGVyVmVydGljYWxTcGFjaW5nLCB3ZWJraXRCb3hBbGlnbiwgd2Via2l0Qm94RGVjb3JhdGlvbkJyZWFrLCB3ZWJraXRCb3hEaXJlY3Rpb24sIHdlYmtpdEJveEZsZXgsIHdlYmtpdEJveE9yZGluYWxHcm91cCwgd2Via2l0Qm94T3JpZW50LCB3ZWJraXRCb3hQYWNrLCB3ZWJraXRCb3hSZWZsZWN0LCB3ZWJraXRCb3hTaGFkb3csIHdlYmtpdEJveFNpemluZywgd2Via2l0Q2xpcFBhdGgsIHdlYmtpdENvbHVtbkJyZWFrQWZ0ZXIsIHdlYmtpdENvbHVtbkJyZWFrQmVmb3JlLCB3ZWJraXRDb2x1bW5CcmVha0luc2lkZSwgd2Via2l0Q29sdW1uQ291bnQsIHdlYmtpdENvbHVtbkdhcCwgd2Via2l0Q29sdW1uUnVsZSwgd2Via2l0Q29sdW1uUnVsZUNvbG9yLCB3ZWJraXRDb2x1bW5SdWxlU3R5bGUsIHdlYmtpdENvbHVtblJ1bGVXaWR0aCwgd2Via2l0Q29sdW1uU3Bhbiwgd2Via2l0Q29sdW1uV2lkdGgsIHdlYmtpdENvbHVtbnMsIHdlYmtpdEZpbHRlciwgd2Via2l0RmxleCwgd2Via2l0RmxleEJhc2lzLCB3ZWJraXRGbGV4RGlyZWN0aW9uLCB3ZWJraXRGbGV4Rmxvdywgd2Via2l0RmxleEdyb3csIHdlYmtpdEZsZXhTaHJpbmssIHdlYmtpdEZsZXhXcmFwLCB3ZWJraXRGb250RmVhdHVyZVNldHRpbmdzLCB3ZWJraXRGb250U21vb3RoaW5nLCB3ZWJraXRIaWdobGlnaHQsIHdlYmtpdEh5cGhlbmF0ZUNoYXJhY3Rlciwgd2Via2l0SnVzdGlmeUNvbnRlbnQsIHdlYmtpdExpbmVCcmVhaywgd2Via2l0TGluZUNsYW1wLCB3ZWJraXRMb2NhbGUsIHdlYmtpdExvZ2ljYWxIZWlnaHQsIHdlYmtpdExvZ2ljYWxXaWR0aCwgd2Via2l0TWFyZ2luQWZ0ZXIsIHdlYmtpdE1hcmdpbkJlZm9yZSwgd2Via2l0TWFyZ2luRW5kLCB3ZWJraXRNYXJnaW5TdGFydCwgd2Via2l0TWFzaywgd2Via2l0TWFza0JveEltYWdlLCB3ZWJraXRNYXNrQm94SW1hZ2VPdXRzZXQsIHdlYmtpdE1hc2tCb3hJbWFnZVJlcGVhdCwgd2Via2l0TWFza0JveEltYWdlU2xpY2UsIHdlYmtpdE1hc2tCb3hJbWFnZVNvdXJjZSwgd2Via2l0TWFza0JveEltYWdlV2lkdGgsIHdlYmtpdE1hc2tDbGlwLCB3ZWJraXRNYXNrQ29tcG9zaXRlLCB3ZWJraXRNYXNrSW1hZ2UsIHdlYmtpdE1hc2tPcmlnaW4sIHdlYmtpdE1hc2tQb3NpdGlvbiwgd2Via2l0TWFza1Bvc2l0aW9uWCwgd2Via2l0TWFza1Bvc2l0aW9uWSwgd2Via2l0TWFza1JlcGVhdCwgd2Via2l0TWFza1JlcGVhdFgsIHdlYmtpdE1hc2tSZXBlYXRZLCB3ZWJraXRNYXNrU2l6ZSwgd2Via2l0TWF4TG9naWNhbEhlaWdodCwgd2Via2l0TWF4TG9naWNhbFdpZHRoLCB3ZWJraXRNaW5Mb2dpY2FsSGVpZ2h0LCB3ZWJraXRNaW5Mb2dpY2FsV2lkdGgsIHdlYmtpdE9wYWNpdHksIHdlYmtpdE9yZGVyLCB3ZWJraXRQYWRkaW5nQWZ0ZXIsIHdlYmtpdFBhZGRpbmdCZWZvcmUsIHdlYmtpdFBhZGRpbmdFbmQsIHdlYmtpdFBhZGRpbmdTdGFydCwgd2Via2l0UGVyc3BlY3RpdmUsIHdlYmtpdFBlcnNwZWN0aXZlT3JpZ2luLCB3ZWJraXRQZXJzcGVjdGl2ZU9yaWdpblgsIHdlYmtpdFBlcnNwZWN0aXZlT3JpZ2luWSwgd2Via2l0UHJpbnRDb2xvckFkanVzdCwgd2Via2l0UnRsT3JkZXJpbmcsIHdlYmtpdFJ1YnlQb3NpdGlvbiwgd2Via2l0U2hhcGVJbWFnZVRocmVzaG9sZCwgd2Via2l0U2hhcGVNYXJnaW4sIHdlYmtpdFNoYXBlT3V0c2lkZSwgd2Via2l0VGFwSGlnaGxpZ2h0Q29sb3IsIHdlYmtpdFRleHRDb21iaW5lLCB3ZWJraXRUZXh0RGVjb3JhdGlvbnNJbkVmZmVjdCwgd2Via2l0VGV4dEVtcGhhc2lzLCB3ZWJraXRUZXh0RW1waGFzaXNDb2xvciwgd2Via2l0VGV4dEVtcGhhc2lzUG9zaXRpb24sIHdlYmtpdFRleHRFbXBoYXNpc1N0eWxlLCB3ZWJraXRUZXh0RmlsbENvbG9yLCB3ZWJraXRUZXh0T3JpZW50YXRpb24sIHdlYmtpdFRleHRTZWN1cml0eSwgd2Via2l0VGV4dFNpemVBZGp1c3QsIHdlYmtpdFRleHRTdHJva2UsIHdlYmtpdFRleHRTdHJva2VDb2xvciwgd2Via2l0VGV4dFN0cm9rZVdpZHRoLCB3ZWJraXRUcmFuc2Zvcm0sIHdlYmtpdFRyYW5zZm9ybU9yaWdpbiwgd2Via2l0VHJhbnNmb3JtT3JpZ2luWCwgd2Via2l0VHJhbnNmb3JtT3JpZ2luWSwgd2Via2l0VHJhbnNmb3JtT3JpZ2luWiwgd2Via2l0VHJhbnNmb3JtU3R5bGUsIHdlYmtpdFRyYW5zaXRpb24sIHdlYmtpdFRyYW5zaXRpb25EZWxheSwgd2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uLCB3ZWJraXRUcmFuc2l0aW9uUHJvcGVydHksIHdlYmtpdFRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiwgd2Via2l0VXNlckRyYWcsIHdlYmtpdFVzZXJNb2RpZnksIHdlYmtpdFVzZXJTZWxlY3QsIHdlYmtpdFdyaXRpbmdNb2RlLCB3aGl0ZVNwYWNlLCB3aWxsQ2hhbmdlLCB3b3JkQnJlYWssIHdvcmRTcGFjaW5nLCB3b3JkV3JhcCwgd3JpdGluZ01vZGUsIHpJbmRleCwgYWRkaXRpdmUtc3ltYm9scywgYXNjZW50LW92ZXJyaWRlLCBhc3BlY3QtcmF0aW8sIGJhY2tncm91bmQtcG9zaXRpb24teCwgYmFja2dyb3VuZC1wb3NpdGlvbi15LCBiYWNrZ3JvdW5kLXJlcGVhdC14LCBiYWNrZ3JvdW5kLXJlcGVhdC15LCBiYXNlLXBhbGV0dGUsIGJvcmRlci1ibG9jaywgYm9yZGVyLWJsb2NrLWNvbG9yLCBib3JkZXItYmxvY2stZW5kLCBib3JkZXItYmxvY2stc3RhcnQsIGJvcmRlci1ibG9jay1zdHlsZSwgYm9yZGVyLWJsb2NrLXdpZHRoLCBib3JkZXItYm90dG9tLCBib3JkZXItY29sb3IsIGJvcmRlci1pbWFnZSwgYm9yZGVyLWlubGluZSwgYm9yZGVyLWlubGluZS1jb2xvciwgYm9yZGVyLWlubGluZS1lbmQsIGJvcmRlci1pbmxpbmUtc3RhcnQsIGJvcmRlci1pbmxpbmUtc3R5bGUsIGJvcmRlci1pbmxpbmUtd2lkdGgsIGJvcmRlci1sZWZ0LCBib3JkZXItcmFkaXVzLCBib3JkZXItcmlnaHQsIGJvcmRlci1zcGFjaW5nLCBib3JkZXItc3R5bGUsIGJvcmRlci10b3AsIGJvcmRlci13aWR0aCwgY29sb3Itc2NoZW1lLCBjb2x1bW4tZmlsbCwgY29sdW1uLXJ1bGUsIGNvbnRlbnQtdmlzaWJpbGl0eSwgY291bnRlci1pbmNyZW1lbnQsIGNvdW50ZXItcmVzZXQsIGNvdW50ZXItc2V0LCBkZXNjZW50LW92ZXJyaWRlLCBmbGV4LWZsb3csIGZvbnQtZGlzcGxheSwgZm9udC1mZWF0dXJlLXNldHRpbmdzLCBmb250LXN5bnRoZXNpcywgZm9udC12YXJpYXRpb24tc2V0dGluZ3MsIGZvcmNlZC1jb2xvci1hZGp1c3QsIGdyaWQtYXJlYSwgZ3JpZC1jb2x1bW4sIGdyaWQtY29sdW1uLWdhcCwgZ3JpZC1nYXAsIGdyaWQtcm93LCBncmlkLXJvdy1nYXAsIGdyaWQtdGVtcGxhdGUsIGluaXRpYWwtdmFsdWUsIGluc2V0LWJsb2NrLCBpbnNldC1pbmxpbmUsIGxpbmUtZ2FwLW92ZXJyaWRlLCBsaXN0LXN0eWxlLCBtYXJnaW4tYmxvY2ssIG1hcmdpbi1pbmxpbmUsIG92ZXJyaWRlLWNvbG9ycywgb3ZlcnNjcm9sbC1iZWhhdmlvciwgb3ZlcnNjcm9sbC1iZWhhdmlvci14LCBvdmVyc2Nyb2xsLWJlaGF2aW9yLXksIHBhZGRpbmctYmxvY2ssIHBhZGRpbmctaW5saW5lLCBwYWdlLWJyZWFrLWFmdGVyLCBwYWdlLWJyZWFrLWJlZm9yZSwgcGFnZS1icmVhay1pbnNpZGUsIHBhZ2Utb3JpZW50YXRpb24sIHBsYWNlLWNvbnRlbnQsIHBsYWNlLWl0ZW1zLCBwbGFjZS1zZWxmLCBzY3JvbGwtbWFyZ2luLCBzY3JvbGwtbWFyZ2luLWJsb2NrLCBzY3JvbGwtbWFyZ2luLWJvdHRvbSwgc2Nyb2xsLW1hcmdpbi1pbmxpbmUsIHNjcm9sbC1tYXJnaW4tbGVmdCwgc2Nyb2xsLW1hcmdpbi1yaWdodCwgc2Nyb2xsLW1hcmdpbi10b3AsIHNjcm9sbC1wYWRkaW5nLCBzY3JvbGwtcGFkZGluZy1ibG9jaywgc2Nyb2xsLXBhZGRpbmctYm90dG9tLCBzY3JvbGwtcGFkZGluZy1pbmxpbmUsIHNjcm9sbC1wYWRkaW5nLWxlZnQsIHNjcm9sbC1wYWRkaW5nLXJpZ2h0LCBzY3JvbGwtcGFkZGluZy10b3AsIHNjcm9sbC1zbmFwLWFsaWduLCBzY3JvbGwtc25hcC1zdG9wLCBzY3JvbGwtc25hcC10eXBlLCBzaXplLWFkanVzdCwgc3BlYWstYXMsIHRleHQtY29tYmluZS11cHJpZ2h0LCB0ZXh0LWRlY29yYXRpb24tdGhpY2tuZXNzLCB0ZXh0LWVtcGhhc2lzLCB0ZXh0LW9yaWVudGF0aW9uLCB0ZXh0LXVuZGVybGluZS1vZmZzZXQsIHRyYW5zZm9ybS1ib3gsIHVuaWNvZGUtcmFuZ2UsIC13ZWJraXQtYWxpZ24tY29udGVudCwgLXdlYmtpdC1hbGlnbi1pdGVtcywgLXdlYmtpdC1hbGlnbi1zZWxmLCAtd2Via2l0LWFuaW1hdGlvbiwgLXdlYmtpdC1hbmltYXRpb24tZGVsYXksIC13ZWJraXQtYW5pbWF0aW9uLWRpcmVjdGlvbiwgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb24sIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZSwgLXdlYmtpdC1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50LCAtd2Via2l0LWFuaW1hdGlvbi1uYW1lLCAtd2Via2l0LWFuaW1hdGlvbi1wbGF5LXN0YXRlLCAtd2Via2l0LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24sIC13ZWJraXQtYXBwLXJlZ2lvbiwgLXdlYmtpdC1hcHBlYXJhbmNlLCAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHksIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwLCAtd2Via2l0LWJhY2tncm91bmQtb3JpZ2luLCAtd2Via2l0LWJhY2tncm91bmQtc2l6ZSwgLXdlYmtpdC1ib3JkZXItYWZ0ZXIsIC13ZWJraXQtYm9yZGVyLWFmdGVyLWNvbG9yLCAtd2Via2l0LWJvcmRlci1hZnRlci1zdHlsZSwgLXdlYmtpdC1ib3JkZXItYWZ0ZXItd2lkdGgsIC13ZWJraXQtYm9yZGVyLWJlZm9yZSwgLXdlYmtpdC1ib3JkZXItYmVmb3JlLWNvbG9yLCAtd2Via2l0LWJvcmRlci1iZWZvcmUtc3R5bGUsIC13ZWJraXQtYm9yZGVyLWJlZm9yZS13aWR0aCwgLXdlYmtpdC1ib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzLCAtd2Via2l0LWJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzLCAtd2Via2l0LWJvcmRlci1lbmQsIC13ZWJraXQtYm9yZGVyLWVuZC1jb2xvciwgLXdlYmtpdC1ib3JkZXItZW5kLXN0eWxlLCAtd2Via2l0LWJvcmRlci1lbmQtd2lkdGgsIC13ZWJraXQtYm9yZGVyLXJhZGl1cywgLXdlYmtpdC1ib3JkZXItc3RhcnQsIC13ZWJraXQtYm9yZGVyLXN0YXJ0LWNvbG9yLCAtd2Via2l0LWJvcmRlci1zdGFydC1zdHlsZSwgLXdlYmtpdC1ib3JkZXItc3RhcnQtd2lkdGgsIC13ZWJraXQtYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cywgLXdlYmtpdC1ib3JkZXItdG9wLXJpZ2h0LXJhZGl1cywgLXdlYmtpdC1ib3gtc2hhZG93LCAtd2Via2l0LWJveC1zaXppbmcsIC13ZWJraXQtY2xpcC1wYXRoLCAtd2Via2l0LWNvbHVtbi1icmVhay1hZnRlciwgLXdlYmtpdC1jb2x1bW4tYnJlYWstYmVmb3JlLCAtd2Via2l0LWNvbHVtbi1icmVhay1pbnNpZGUsIC13ZWJraXQtY29sdW1uLWNvdW50LCAtd2Via2l0LWNvbHVtbi1nYXAsIC13ZWJraXQtY29sdW1uLXJ1bGUsIC13ZWJraXQtY29sdW1uLXJ1bGUtY29sb3IsIC13ZWJraXQtY29sdW1uLXJ1bGUtc3R5bGUsIC13ZWJraXQtY29sdW1uLXJ1bGUtd2lkdGgsIC13ZWJraXQtY29sdW1uLXNwYW4sIC13ZWJraXQtY29sdW1uLXdpZHRoLCAtd2Via2l0LWNvbHVtbnMsIC13ZWJraXQtZmlsdGVyLCAtd2Via2l0LWZsZXgsIC13ZWJraXQtZmxleC1iYXNpcywgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbiwgLXdlYmtpdC1mbGV4LWZsb3csIC13ZWJraXQtZmxleC1ncm93LCAtd2Via2l0LWZsZXgtc2hyaW5rLCAtd2Via2l0LWZsZXgtd3JhcCwgLXdlYmtpdC1mb250LWZlYXR1cmUtc2V0dGluZ3MsIC13ZWJraXQtaHlwaGVuYXRlLWNoYXJhY3RlciwgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQsIC13ZWJraXQtbG9naWNhbC1oZWlnaHQsIC13ZWJraXQtbG9naWNhbC13aWR0aCwgLXdlYmtpdC1tYXJnaW4tYWZ0ZXIsIC13ZWJraXQtbWFyZ2luLWJlZm9yZSwgLXdlYmtpdC1tYXJnaW4tZW5kLCAtd2Via2l0LW1hcmdpbi1zdGFydCwgLXdlYmtpdC1tYXNrLCAtd2Via2l0LW1hc2stcG9zaXRpb24teCwgLXdlYmtpdC1tYXNrLXBvc2l0aW9uLXksIC13ZWJraXQtbWFzay1yZXBlYXQteCwgLXdlYmtpdC1tYXNrLXJlcGVhdC15LCAtd2Via2l0LW1heC1sb2dpY2FsLWhlaWdodCwgLXdlYmtpdC1tYXgtbG9naWNhbC13aWR0aCwgLXdlYmtpdC1taW4tbG9naWNhbC1oZWlnaHQsIC13ZWJraXQtbWluLWxvZ2ljYWwtd2lkdGgsIC13ZWJraXQtb3BhY2l0eSwgLXdlYmtpdC1vcmRlciwgLXdlYmtpdC1wYWRkaW5nLWFmdGVyLCAtd2Via2l0LXBhZGRpbmctYmVmb3JlLCAtd2Via2l0LXBhZGRpbmctZW5kLCAtd2Via2l0LXBhZGRpbmctc3RhcnQsIC13ZWJraXQtcGVyc3BlY3RpdmUsIC13ZWJraXQtcGVyc3BlY3RpdmUtb3JpZ2luLCAtd2Via2l0LXBlcnNwZWN0aXZlLW9yaWdpbi14LCAtd2Via2l0LXBlcnNwZWN0aXZlLW9yaWdpbi15LCAtd2Via2l0LXJ1YnktcG9zaXRpb24sIC13ZWJraXQtc2hhcGUtaW1hZ2UtdGhyZXNob2xkLCAtd2Via2l0LXNoYXBlLW1hcmdpbiwgLXdlYmtpdC1zaGFwZS1vdXRzaWRlLCAtd2Via2l0LXRleHQtZW1waGFzaXMsIC13ZWJraXQtdGV4dC1lbXBoYXNpcy1jb2xvciwgLXdlYmtpdC10ZXh0LWVtcGhhc2lzLXBvc2l0aW9uLCAtd2Via2l0LXRleHQtZW1waGFzaXMtc3R5bGUsIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdCwgLXdlYmtpdC10ZXh0LXN0cm9rZSwgLXdlYmtpdC10cmFuc2Zvcm0sIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbiwgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luLXgsIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbi15LCAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW4teiwgLXdlYmtpdC10cmFuc2Zvcm0tc3R5bGUsIC13ZWJraXQtdHJhbnNpdGlvbiwgLXdlYmtpdC10cmFuc2l0aW9uLWRlbGF5LCAtd2Via2l0LXRyYW5zaXRpb24tZHVyYXRpb24sIC13ZWJraXQtdHJhbnNpdGlvbi1wcm9wZXJ0eSwgLXdlYmtpdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiwgLXdlYmtpdC11c2VyLXNlbGVjdCwgd29yZC13cmFwIixqc0tleXM6Ik9iamVjdC5hc3NpZ24sIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgT2JqZWN0Lmhhc093biwgT2JqZWN0LmlzLCBPYmplY3QucHJldmVudEV4dGVuc2lvbnMsIE9iamVjdC5zZWFsLCBPYmplY3QuY3JlYXRlLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBPYmplY3QuZnJlZXplLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdC5zZXRQcm90b3R5cGVPZiwgT2JqZWN0LmlzRXh0ZW5zaWJsZSwgT2JqZWN0LmlzRnJvemVuLCBPYmplY3QuaXNTZWFsZWQsIE9iamVjdC5rZXlzLCBPYmplY3QuZW50cmllcywgT2JqZWN0LmZyb21FbnRyaWVzLCBPYmplY3QudmFsdWVzLCBPYmplY3QuX19kZWZpbmVHZXR0ZXJfXywgT2JqZWN0Ll9fZGVmaW5lU2V0dGVyX18sIE9iamVjdC5oYXNPd25Qcm9wZXJ0eSwgT2JqZWN0Ll9fbG9va3VwR2V0dGVyX18sIE9iamVjdC5fX2xvb2t1cFNldHRlcl9fLCBPYmplY3QuaXNQcm90b3R5cGVPZiwgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLCBPYmplY3QudG9TdHJpbmcsIE9iamVjdC52YWx1ZU9mLCBPYmplY3QuX19wcm90b19fLCBPYmplY3QudG9Mb2NhbGVTdHJpbmcsIEZ1bmN0aW9uLmFwcGx5LCBGdW5jdGlvbi5iaW5kLCBGdW5jdGlvbi5jYWxsLCBGdW5jdGlvbi50b1N0cmluZywgQm9vbGVhbi50b1N0cmluZywgQm9vbGVhbi52YWx1ZU9mLCBTeW1ib2wuZm9yLCBTeW1ib2wua2V5Rm9yLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgU3ltYm9sLmhhc0luc3RhbmNlLCBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlLCBTeW1ib2wuaXRlcmF0b3IsIFN5bWJvbC5tYXRjaCwgU3ltYm9sLm1hdGNoQWxsLCBTeW1ib2wucmVwbGFjZSwgU3ltYm9sLnNlYXJjaCwgU3ltYm9sLnNwZWNpZXMsIFN5bWJvbC5zcGxpdCwgU3ltYm9sLnRvUHJpbWl0aXZlLCBTeW1ib2wudG9TdHJpbmdUYWcsIFN5bWJvbC51bnNjb3BhYmxlcywgU3ltYm9sLnRvU3RyaW5nLCBTeW1ib2wudmFsdWVPZiwgU3ltYm9sLmRlc2NyaXB0aW9uLCBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSwgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0LCBFcnJvci5tZXNzYWdlLCBFcnJvci50b1N0cmluZywgTnVtYmVyLmlzRmluaXRlLCBOdW1iZXIuaXNJbnRlZ2VyLCBOdW1iZXIuaXNOYU4sIE51bWJlci5pc1NhZmVJbnRlZ2VyLCBOdW1iZXIucGFyc2VGbG9hdCwgTnVtYmVyLnBhcnNlSW50LCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUlOX1ZBTFVFLCBOdW1iZXIuTmFOLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLCBOdW1iZXIuRVBTSUxPTiwgTnVtYmVyLnRvRXhwb25lbnRpYWwsIE51bWJlci50b0ZpeGVkLCBOdW1iZXIudG9QcmVjaXNpb24sIE51bWJlci50b1N0cmluZywgTnVtYmVyLnZhbHVlT2YsIE51bWJlci50b0xvY2FsZVN0cmluZywgQmlnSW50LmFzVWludE4sIEJpZ0ludC5hc0ludE4sIEJpZ0ludC50b0xvY2FsZVN0cmluZywgQmlnSW50LnRvU3RyaW5nLCBCaWdJbnQudmFsdWVPZiwgTWF0aC5hYnMsIE1hdGguYWNvcywgTWF0aC5hY29zaCwgTWF0aC5hc2luLCBNYXRoLmFzaW5oLCBNYXRoLmF0YW4sIE1hdGguYXRhbmgsIE1hdGguYXRhbjIsIE1hdGguY2VpbCwgTWF0aC5jYnJ0LCBNYXRoLmV4cG0xLCBNYXRoLmNsejMyLCBNYXRoLmNvcywgTWF0aC5jb3NoLCBNYXRoLmV4cCwgTWF0aC5mbG9vciwgTWF0aC5mcm91bmQsIE1hdGguaHlwb3QsIE1hdGguaW11bCwgTWF0aC5sb2csIE1hdGgubG9nMXAsIE1hdGgubG9nMiwgTWF0aC5sb2cxMCwgTWF0aC5tYXgsIE1hdGgubWluLCBNYXRoLnBvdywgTWF0aC5yYW5kb20sIE1hdGgucm91bmQsIE1hdGguc2lnbiwgTWF0aC5zaW4sIE1hdGguc2luaCwgTWF0aC5zcXJ0LCBNYXRoLnRhbiwgTWF0aC50YW5oLCBNYXRoLnRydW5jLCBNYXRoLkUsIE1hdGguTE4xMCwgTWF0aC5MTjIsIE1hdGguTE9HMTBFLCBNYXRoLkxPRzJFLCBNYXRoLlBJLCBNYXRoLlNRUlQxXzIsIE1hdGguU1FSVDIsIERhdGUubm93LCBEYXRlLnBhcnNlLCBEYXRlLlVUQywgRGF0ZS50b1N0cmluZywgRGF0ZS50b0RhdGVTdHJpbmcsIERhdGUudG9UaW1lU3RyaW5nLCBEYXRlLnRvSVNPU3RyaW5nLCBEYXRlLnRvVVRDU3RyaW5nLCBEYXRlLnRvR01UU3RyaW5nLCBEYXRlLmdldERhdGUsIERhdGUuc2V0RGF0ZSwgRGF0ZS5nZXREYXksIERhdGUuZ2V0RnVsbFllYXIsIERhdGUuc2V0RnVsbFllYXIsIERhdGUuZ2V0SG91cnMsIERhdGUuc2V0SG91cnMsIERhdGUuZ2V0TWlsbGlzZWNvbmRzLCBEYXRlLnNldE1pbGxpc2Vjb25kcywgRGF0ZS5nZXRNaW51dGVzLCBEYXRlLnNldE1pbnV0ZXMsIERhdGUuZ2V0TW9udGgsIERhdGUuc2V0TW9udGgsIERhdGUuZ2V0U2Vjb25kcywgRGF0ZS5zZXRTZWNvbmRzLCBEYXRlLmdldFRpbWUsIERhdGUuc2V0VGltZSwgRGF0ZS5nZXRUaW1lem9uZU9mZnNldCwgRGF0ZS5nZXRVVENEYXRlLCBEYXRlLnNldFVUQ0RhdGUsIERhdGUuZ2V0VVRDRGF5LCBEYXRlLmdldFVUQ0Z1bGxZZWFyLCBEYXRlLnNldFVUQ0Z1bGxZZWFyLCBEYXRlLmdldFVUQ0hvdXJzLCBEYXRlLnNldFVUQ0hvdXJzLCBEYXRlLmdldFVUQ01pbGxpc2Vjb25kcywgRGF0ZS5zZXRVVENNaWxsaXNlY29uZHMsIERhdGUuZ2V0VVRDTWludXRlcywgRGF0ZS5zZXRVVENNaW51dGVzLCBEYXRlLmdldFVUQ01vbnRoLCBEYXRlLnNldFVUQ01vbnRoLCBEYXRlLmdldFVUQ1NlY29uZHMsIERhdGUuc2V0VVRDU2Vjb25kcywgRGF0ZS52YWx1ZU9mLCBEYXRlLmdldFllYXIsIERhdGUuc2V0WWVhciwgRGF0ZS50b0pTT04sIERhdGUudG9Mb2NhbGVTdHJpbmcsIERhdGUudG9Mb2NhbGVEYXRlU3RyaW5nLCBEYXRlLnRvTG9jYWxlVGltZVN0cmluZywgU3RyaW5nLmZyb21DaGFyQ29kZSwgU3RyaW5nLmZyb21Db2RlUG9pbnQsIFN0cmluZy5yYXcsIFN0cmluZy5hbmNob3IsIFN0cmluZy5hdCwgU3RyaW5nLmJpZywgU3RyaW5nLmJsaW5rLCBTdHJpbmcuYm9sZCwgU3RyaW5nLmNoYXJBdCwgU3RyaW5nLmNoYXJDb2RlQXQsIFN0cmluZy5jb2RlUG9pbnRBdCwgU3RyaW5nLmNvbmNhdCwgU3RyaW5nLmVuZHNXaXRoLCBTdHJpbmcuZm9udGNvbG9yLCBTdHJpbmcuZm9udHNpemUsIFN0cmluZy5maXhlZCwgU3RyaW5nLmluY2x1ZGVzLCBTdHJpbmcuaW5kZXhPZiwgU3RyaW5nLml0YWxpY3MsIFN0cmluZy5sYXN0SW5kZXhPZiwgU3RyaW5nLmxpbmssIFN0cmluZy5sb2NhbGVDb21wYXJlLCBTdHJpbmcubWF0Y2gsIFN0cmluZy5tYXRjaEFsbCwgU3RyaW5nLm5vcm1hbGl6ZSwgU3RyaW5nLnBhZEVuZCwgU3RyaW5nLnBhZFN0YXJ0LCBTdHJpbmcucmVwZWF0LCBTdHJpbmcucmVwbGFjZSwgU3RyaW5nLnJlcGxhY2VBbGwsIFN0cmluZy5zZWFyY2gsIFN0cmluZy5zbGljZSwgU3RyaW5nLnNtYWxsLCBTdHJpbmcuc3BsaXQsIFN0cmluZy5zdHJpa2UsIFN0cmluZy5zdWIsIFN0cmluZy5zdWJzdHIsIFN0cmluZy5zdWJzdHJpbmcsIFN0cmluZy5zdXAsIFN0cmluZy5zdGFydHNXaXRoLCBTdHJpbmcudG9TdHJpbmcsIFN0cmluZy50cmltLCBTdHJpbmcudHJpbVN0YXJ0LCBTdHJpbmcudHJpbUxlZnQsIFN0cmluZy50cmltRW5kLCBTdHJpbmcudHJpbVJpZ2h0LCBTdHJpbmcudG9Mb2NhbGVMb3dlckNhc2UsIFN0cmluZy50b0xvY2FsZVVwcGVyQ2FzZSwgU3RyaW5nLnRvTG93ZXJDYXNlLCBTdHJpbmcudG9VcHBlckNhc2UsIFN0cmluZy52YWx1ZU9mLCBSZWdFeHAuaW5wdXQsIFJlZ0V4cC4kXywgUmVnRXhwLmxhc3RNYXRjaCwgUmVnRXhwLiQmLCBSZWdFeHAubGFzdFBhcmVuLCBSZWdFeHAuJCssIFJlZ0V4cC5sZWZ0Q29udGV4dCwgUmVnRXhwLiRgLCBSZWdFeHAucmlnaHRDb250ZXh0LCBSZWdFeHAuJCcsIFJlZ0V4cC4kMSwgUmVnRXhwLiQyLCBSZWdFeHAuJDMsIFJlZ0V4cC4kNCwgUmVnRXhwLiQ1LCBSZWdFeHAuJDYsIFJlZ0V4cC4kNywgUmVnRXhwLiQ4LCBSZWdFeHAuJDksIFJlZ0V4cC5leGVjLCBSZWdFeHAuZG90QWxsLCBSZWdFeHAuZmxhZ3MsIFJlZ0V4cC5nbG9iYWwsIFJlZ0V4cC5oYXNJbmRpY2VzLCBSZWdFeHAuaWdub3JlQ2FzZSwgUmVnRXhwLm11bHRpbGluZSwgUmVnRXhwLnNvdXJjZSwgUmVnRXhwLnN0aWNreSwgUmVnRXhwLnVuaWNvZGUsIFJlZ0V4cC5jb21waWxlLCBSZWdFeHAudG9TdHJpbmcsIFJlZ0V4cC50ZXN0LCBBcnJheS5pc0FycmF5LCBBcnJheS5mcm9tLCBBcnJheS5vZiwgQXJyYXkuYXQsIEFycmF5LmNvbmNhdCwgQXJyYXkuY29weVdpdGhpbiwgQXJyYXkuZmlsbCwgQXJyYXkuZmluZCwgQXJyYXkuZmluZEluZGV4LCBBcnJheS5sYXN0SW5kZXhPZiwgQXJyYXkucG9wLCBBcnJheS5wdXNoLCBBcnJheS5yZXZlcnNlLCBBcnJheS5zaGlmdCwgQXJyYXkudW5zaGlmdCwgQXJyYXkuc2xpY2UsIEFycmF5LnNvcnQsIEFycmF5LnNwbGljZSwgQXJyYXkuaW5jbHVkZXMsIEFycmF5LmluZGV4T2YsIEFycmF5LmpvaW4sIEFycmF5LmtleXMsIEFycmF5LmVudHJpZXMsIEFycmF5LnZhbHVlcywgQXJyYXkuZm9yRWFjaCwgQXJyYXkuZmlsdGVyLCBBcnJheS5mbGF0LCBBcnJheS5mbGF0TWFwLCBBcnJheS5tYXAsIEFycmF5LmV2ZXJ5LCBBcnJheS5zb21lLCBBcnJheS5yZWR1Y2UsIEFycmF5LnJlZHVjZVJpZ2h0LCBBcnJheS50b0xvY2FsZVN0cmluZywgQXJyYXkudG9TdHJpbmcsIEFycmF5LmZpbmRMYXN0LCBBcnJheS5maW5kTGFzdEluZGV4LCBNYXAuZ2V0LCBNYXAuc2V0LCBNYXAuaGFzLCBNYXAuZGVsZXRlLCBNYXAuY2xlYXIsIE1hcC5lbnRyaWVzLCBNYXAuZm9yRWFjaCwgTWFwLmtleXMsIE1hcC5zaXplLCBNYXAudmFsdWVzLCBTZXQuaGFzLCBTZXQuYWRkLCBTZXQuZGVsZXRlLCBTZXQuY2xlYXIsIFNldC5lbnRyaWVzLCBTZXQuZm9yRWFjaCwgU2V0LnNpemUsIFNldC52YWx1ZXMsIFNldC5rZXlzLCBXZWFrTWFwLmRlbGV0ZSwgV2Vha01hcC5nZXQsIFdlYWtNYXAuc2V0LCBXZWFrTWFwLmhhcywgV2Vha1NldC5kZWxldGUsIFdlYWtTZXQuaGFzLCBXZWFrU2V0LmFkZCwgQXRvbWljcy5sb2FkLCBBdG9taWNzLnN0b3JlLCBBdG9taWNzLmFkZCwgQXRvbWljcy5zdWIsIEF0b21pY3MuYW5kLCBBdG9taWNzLm9yLCBBdG9taWNzLnhvciwgQXRvbWljcy5leGNoYW5nZSwgQXRvbWljcy5jb21wYXJlRXhjaGFuZ2UsIEF0b21pY3MuaXNMb2NrRnJlZSwgQXRvbWljcy53YWl0LCBBdG9taWNzLndhaXRBc3luYywgQXRvbWljcy5ub3RpZnksIEpTT04ucGFyc2UsIEpTT04uc3RyaW5naWZ5LCBQcm9taXNlLmFsbCwgUHJvbWlzZS5hbGxTZXR0bGVkLCBQcm9taXNlLmFueSwgUHJvbWlzZS5yYWNlLCBQcm9taXNlLnJlc29sdmUsIFByb21pc2UucmVqZWN0LCBQcm9taXNlLnRoZW4sIFByb21pc2UuY2F0Y2gsIFByb21pc2UuZmluYWxseSwgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSwgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSwgUmVmbGVjdC5hcHBseSwgUmVmbGVjdC5jb25zdHJ1Y3QsIFJlZmxlY3QuZ2V0LCBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwgUmVmbGVjdC5nZXRQcm90b3R5cGVPZiwgUmVmbGVjdC5oYXMsIFJlZmxlY3QuaXNFeHRlbnNpYmxlLCBSZWZsZWN0Lm93bktleXMsIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnMsIFJlZmxlY3Quc2V0LCBSZWZsZWN0LnNldFByb3RvdHlwZU9mLCBQcm94eS5yZXZvY2FibGUsIEludGwuZ2V0Q2Fub25pY2FsTG9jYWxlcywgSW50bC5zdXBwb3J0ZWRWYWx1ZXNPZiwgSW50bC5EYXRlVGltZUZvcm1hdCwgSW50bC5OdW1iZXJGb3JtYXQsIEludGwuQ29sbGF0b3IsIEludGwudjhCcmVha0l0ZXJhdG9yLCBJbnRsLlBsdXJhbFJ1bGVzLCBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdCwgSW50bC5MaXN0Rm9ybWF0LCBJbnRsLkxvY2FsZSwgSW50bC5EaXNwbGF5TmFtZXMsIEludGwuU2VnbWVudGVyLCBXZWJBc3NlbWJseS5jb21waWxlLCBXZWJBc3NlbWJseS52YWxpZGF0ZSwgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUsIFdlYkFzc2VtYmx5LmNvbXBpbGVTdHJlYW1pbmcsIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nLCBXZWJBc3NlbWJseS5Nb2R1bGUsIFdlYkFzc2VtYmx5Lkluc3RhbmNlLCBXZWJBc3NlbWJseS5UYWJsZSwgV2ViQXNzZW1ibHkuTWVtb3J5LCBXZWJBc3NlbWJseS5HbG9iYWwsIFdlYkFzc2VtYmx5LlRhZywgV2ViQXNzZW1ibHkuRXhjZXB0aW9uLCBXZWJBc3NlbWJseS5Db21waWxlRXJyb3IsIFdlYkFzc2VtYmx5LkxpbmtFcnJvciwgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yLCBEb2N1bWVudC5pbXBsZW1lbnRhdGlvbiwgRG9jdW1lbnQuVVJMLCBEb2N1bWVudC5kb2N1bWVudFVSSSwgRG9jdW1lbnQuY29tcGF0TW9kZSwgRG9jdW1lbnQuY2hhcmFjdGVyU2V0LCBEb2N1bWVudC5jaGFyc2V0LCBEb2N1bWVudC5pbnB1dEVuY29kaW5nLCBEb2N1bWVudC5jb250ZW50VHlwZSwgRG9jdW1lbnQuZG9jdHlwZSwgRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBEb2N1bWVudC54bWxFbmNvZGluZywgRG9jdW1lbnQueG1sVmVyc2lvbiwgRG9jdW1lbnQueG1sU3RhbmRhbG9uZSwgRG9jdW1lbnQuZG9tYWluLCBEb2N1bWVudC5yZWZlcnJlciwgRG9jdW1lbnQuY29va2llLCBEb2N1bWVudC5sYXN0TW9kaWZpZWQsIERvY3VtZW50LnJlYWR5U3RhdGUsIERvY3VtZW50LnRpdGxlLCBEb2N1bWVudC5kaXIsIERvY3VtZW50LmJvZHksIERvY3VtZW50LmhlYWQsIERvY3VtZW50LmltYWdlcywgRG9jdW1lbnQuZW1iZWRzLCBEb2N1bWVudC5wbHVnaW5zLCBEb2N1bWVudC5saW5rcywgRG9jdW1lbnQuZm9ybXMsIERvY3VtZW50LnNjcmlwdHMsIERvY3VtZW50LmN1cnJlbnRTY3JpcHQsIERvY3VtZW50LmRlZmF1bHRWaWV3LCBEb2N1bWVudC5kZXNpZ25Nb2RlLCBEb2N1bWVudC5vbnJlYWR5c3RhdGVjaGFuZ2UsIERvY3VtZW50LmFuY2hvcnMsIERvY3VtZW50LmFwcGxldHMsIERvY3VtZW50LmZnQ29sb3IsIERvY3VtZW50LmxpbmtDb2xvciwgRG9jdW1lbnQudmxpbmtDb2xvciwgRG9jdW1lbnQuYWxpbmtDb2xvciwgRG9jdW1lbnQuYmdDb2xvciwgRG9jdW1lbnQuYWxsLCBEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LCBEb2N1bWVudC5vbnBvaW50ZXJsb2NrY2hhbmdlLCBEb2N1bWVudC5vbnBvaW50ZXJsb2NrZXJyb3IsIERvY3VtZW50LmhpZGRlbiwgRG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlLCBEb2N1bWVudC53YXNEaXNjYXJkZWQsIERvY3VtZW50LmZlYXR1cmVQb2xpY3ksIERvY3VtZW50LndlYmtpdFZpc2liaWxpdHlTdGF0ZSwgRG9jdW1lbnQud2Via2l0SGlkZGVuLCBEb2N1bWVudC5vbmJlZm9yZWNvcHksIERvY3VtZW50Lm9uYmVmb3JlY3V0LCBEb2N1bWVudC5vbmJlZm9yZXBhc3RlLCBEb2N1bWVudC5vbmZyZWV6ZSwgRG9jdW1lbnQub25yZXN1bWUsIERvY3VtZW50Lm9uc2VhcmNoLCBEb2N1bWVudC5vbnZpc2liaWxpdHljaGFuZ2UsIERvY3VtZW50LmZ1bGxzY3JlZW5FbmFibGVkLCBEb2N1bWVudC5mdWxsc2NyZWVuLCBEb2N1bWVudC5vbmZ1bGxzY3JlZW5jaGFuZ2UsIERvY3VtZW50Lm9uZnVsbHNjcmVlbmVycm9yLCBEb2N1bWVudC53ZWJraXRJc0Z1bGxTY3JlZW4sIERvY3VtZW50LndlYmtpdEN1cnJlbnRGdWxsU2NyZWVuRWxlbWVudCwgRG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVuYWJsZWQsIERvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50LCBEb2N1bWVudC5vbndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsIERvY3VtZW50Lm9ud2Via2l0ZnVsbHNjcmVlbmVycm9yLCBEb2N1bWVudC5yb290RWxlbWVudCwgRG9jdW1lbnQub25iZWZvcmV4cnNlbGVjdCwgRG9jdW1lbnQub25hYm9ydCwgRG9jdW1lbnQub25iZWZvcmVpbnB1dCwgRG9jdW1lbnQub25ibHVyLCBEb2N1bWVudC5vbmNhbmNlbCwgRG9jdW1lbnQub25jYW5wbGF5LCBEb2N1bWVudC5vbmNhbnBsYXl0aHJvdWdoLCBEb2N1bWVudC5vbmNoYW5nZSwgRG9jdW1lbnQub25jbGljaywgRG9jdW1lbnQub25jbG9zZSwgRG9jdW1lbnQub25jb250ZXh0bG9zdCwgRG9jdW1lbnQub25jb250ZXh0bWVudSwgRG9jdW1lbnQub25jb250ZXh0cmVzdG9yZWQsIERvY3VtZW50Lm9uY3VlY2hhbmdlLCBEb2N1bWVudC5vbmRibGNsaWNrLCBEb2N1bWVudC5vbmRyYWcsIERvY3VtZW50Lm9uZHJhZ2VuZCwgRG9jdW1lbnQub25kcmFnZW50ZXIsIERvY3VtZW50Lm9uZHJhZ2xlYXZlLCBEb2N1bWVudC5vbmRyYWdvdmVyLCBEb2N1bWVudC5vbmRyYWdzdGFydCwgRG9jdW1lbnQub25kcm9wLCBEb2N1bWVudC5vbmR1cmF0aW9uY2hhbmdlLCBEb2N1bWVudC5vbmVtcHRpZWQsIERvY3VtZW50Lm9uZW5kZWQsIERvY3VtZW50Lm9uZXJyb3IsIERvY3VtZW50Lm9uZm9jdXMsIERvY3VtZW50Lm9uZm9ybWRhdGEsIERvY3VtZW50Lm9uaW5wdXQsIERvY3VtZW50Lm9uaW52YWxpZCwgRG9jdW1lbnQub25rZXlkb3duLCBEb2N1bWVudC5vbmtleXByZXNzLCBEb2N1bWVudC5vbmtleXVwLCBEb2N1bWVudC5vbmxvYWQsIERvY3VtZW50Lm9ubG9hZGVkZGF0YSwgRG9jdW1lbnQub25sb2FkZWRtZXRhZGF0YSwgRG9jdW1lbnQub25sb2Fkc3RhcnQsIERvY3VtZW50Lm9ubW91c2Vkb3duLCBEb2N1bWVudC5vbm1vdXNlZW50ZXIsIERvY3VtZW50Lm9ubW91c2VsZWF2ZSwgRG9jdW1lbnQub25tb3VzZW1vdmUsIERvY3VtZW50Lm9ubW91c2VvdXQsIERvY3VtZW50Lm9ubW91c2VvdmVyLCBEb2N1bWVudC5vbm1vdXNldXAsIERvY3VtZW50Lm9ubW91c2V3aGVlbCwgRG9jdW1lbnQub25wYXVzZSwgRG9jdW1lbnQub25wbGF5LCBEb2N1bWVudC5vbnBsYXlpbmcsIERvY3VtZW50Lm9ucHJvZ3Jlc3MsIERvY3VtZW50Lm9ucmF0ZWNoYW5nZSwgRG9jdW1lbnQub25yZXNldCwgRG9jdW1lbnQub25yZXNpemUsIERvY3VtZW50Lm9uc2Nyb2xsLCBEb2N1bWVudC5vbnNlY3VyaXR5cG9saWN5dmlvbGF0aW9uLCBEb2N1bWVudC5vbnNlZWtlZCwgRG9jdW1lbnQub25zZWVraW5nLCBEb2N1bWVudC5vbnNlbGVjdCwgRG9jdW1lbnQub25zbG90Y2hhbmdlLCBEb2N1bWVudC5vbnN0YWxsZWQsIERvY3VtZW50Lm9uc3VibWl0LCBEb2N1bWVudC5vbnN1c3BlbmQsIERvY3VtZW50Lm9udGltZXVwZGF0ZSwgRG9jdW1lbnQub250b2dnbGUsIERvY3VtZW50Lm9udm9sdW1lY2hhbmdlLCBEb2N1bWVudC5vbndhaXRpbmcsIERvY3VtZW50Lm9ud2Via2l0YW5pbWF0aW9uZW5kLCBEb2N1bWVudC5vbndlYmtpdGFuaW1hdGlvbml0ZXJhdGlvbiwgRG9jdW1lbnQub253ZWJraXRhbmltYXRpb25zdGFydCwgRG9jdW1lbnQub253ZWJraXR0cmFuc2l0aW9uZW5kLCBEb2N1bWVudC5vbndoZWVsLCBEb2N1bWVudC5vbmF1eGNsaWNrLCBEb2N1bWVudC5vbmdvdHBvaW50ZXJjYXB0dXJlLCBEb2N1bWVudC5vbmxvc3Rwb2ludGVyY2FwdHVyZSwgRG9jdW1lbnQub25wb2ludGVyZG93biwgRG9jdW1lbnQub25wb2ludGVybW92ZSwgRG9jdW1lbnQub25wb2ludGVycmF3dXBkYXRlLCBEb2N1bWVudC5vbnBvaW50ZXJ1cCwgRG9jdW1lbnQub25wb2ludGVyY2FuY2VsLCBEb2N1bWVudC5vbnBvaW50ZXJvdmVyLCBEb2N1bWVudC5vbnBvaW50ZXJvdXQsIERvY3VtZW50Lm9ucG9pbnRlcmVudGVyLCBEb2N1bWVudC5vbnBvaW50ZXJsZWF2ZSwgRG9jdW1lbnQub25zZWxlY3RzdGFydCwgRG9jdW1lbnQub25zZWxlY3Rpb25jaGFuZ2UsIERvY3VtZW50Lm9uYW5pbWF0aW9uZW5kLCBEb2N1bWVudC5vbmFuaW1hdGlvbml0ZXJhdGlvbiwgRG9jdW1lbnQub25hbmltYXRpb25zdGFydCwgRG9jdW1lbnQub250cmFuc2l0aW9ucnVuLCBEb2N1bWVudC5vbnRyYW5zaXRpb25zdGFydCwgRG9jdW1lbnQub250cmFuc2l0aW9uZW5kLCBEb2N1bWVudC5vbnRyYW5zaXRpb25jYW5jZWwsIERvY3VtZW50Lm9uY29weSwgRG9jdW1lbnQub25jdXQsIERvY3VtZW50Lm9ucGFzdGUsIERvY3VtZW50LmNoaWxkcmVuLCBEb2N1bWVudC5maXJzdEVsZW1lbnRDaGlsZCwgRG9jdW1lbnQubGFzdEVsZW1lbnRDaGlsZCwgRG9jdW1lbnQuY2hpbGRFbGVtZW50Q291bnQsIERvY3VtZW50LmFjdGl2ZUVsZW1lbnQsIERvY3VtZW50LnN0eWxlU2hlZXRzLCBEb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQsIERvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50LCBEb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMsIERvY3VtZW50LmZvbnRzLCBEb2N1bWVudC5hZG9wdE5vZGUsIERvY3VtZW50LmFwcGVuZCwgRG9jdW1lbnQuY2FwdHVyZUV2ZW50cywgRG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCwgRG9jdW1lbnQuY2xlYXIsIERvY3VtZW50LmNsb3NlLCBEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUsIERvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZU5TLCBEb2N1bWVudC5jcmVhdGVDREFUQVNlY3Rpb24sIERvY3VtZW50LmNyZWF0ZUNvbW1lbnQsIERvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQsIERvY3VtZW50LmNyZWF0ZUVsZW1lbnQsIERvY3VtZW50LmNyZWF0ZUVsZW1lbnROUywgRG9jdW1lbnQuY3JlYXRlRXZlbnQsIERvY3VtZW50LmNyZWF0ZUV4cHJlc3Npb24sIERvY3VtZW50LmNyZWF0ZU5TUmVzb2x2ZXIsIERvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvciwgRG9jdW1lbnQuY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBEb2N1bWVudC5jcmVhdGVSYW5nZSwgRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUsIERvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIsIERvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQsIERvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50LCBEb2N1bWVudC5ldmFsdWF0ZSwgRG9jdW1lbnQuZXhlY0NvbW1hbmQsIERvY3VtZW50LmV4aXRGdWxsc2NyZWVuLCBEb2N1bWVudC5leGl0UG9pbnRlckxvY2ssIERvY3VtZW50LmdldEVsZW1lbnRCeUlkLCBEb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lLCBEb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSwgRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUsIERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lTlMsIERvY3VtZW50LmdldFNlbGVjdGlvbiwgRG9jdW1lbnQuaGFzRm9jdXMsIERvY3VtZW50LmltcG9ydE5vZGUsIERvY3VtZW50Lm9wZW4sIERvY3VtZW50LnByZXBlbmQsIERvY3VtZW50LnF1ZXJ5Q29tbWFuZEVuYWJsZWQsIERvY3VtZW50LnF1ZXJ5Q29tbWFuZEluZGV0ZXJtLCBEb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZSwgRG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkLCBEb2N1bWVudC5xdWVyeUNvbW1hbmRWYWx1ZSwgRG9jdW1lbnQucXVlcnlTZWxlY3RvciwgRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCwgRG9jdW1lbnQucmVsZWFzZUV2ZW50cywgRG9jdW1lbnQucmVwbGFjZUNoaWxkcmVuLCBEb2N1bWVudC53ZWJraXRDYW5jZWxGdWxsU2NyZWVuLCBEb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbiwgRG9jdW1lbnQud3JpdGUsIERvY3VtZW50LndyaXRlbG4sIERvY3VtZW50LnByZXJlbmRlcmluZywgRG9jdW1lbnQub25wcmVyZW5kZXJpbmdjaGFuZ2UsIERvY3VtZW50LmZyYWdtZW50RGlyZWN0aXZlLCBEb2N1bWVudC5vbmJlZm9yZW1hdGNoLCBEb2N1bWVudC50aW1lbGluZSwgRG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVuYWJsZWQsIERvY3VtZW50LnBpY3R1cmVJblBpY3R1cmVFbGVtZW50LCBEb2N1bWVudC5vbmNvbnRlbnR2aXNpYmlsaXR5YXV0b3N0YXRlY2hhbmdlLCBEb2N1bWVudC5leGl0UGljdHVyZUluUGljdHVyZSwgRG9jdW1lbnQuZ2V0QW5pbWF0aW9ucywgRWxlbWVudC5uYW1lc3BhY2VVUkksIEVsZW1lbnQucHJlZml4LCBFbGVtZW50LmxvY2FsTmFtZSwgRWxlbWVudC50YWdOYW1lLCBFbGVtZW50LmlkLCBFbGVtZW50LmNsYXNzTmFtZSwgRWxlbWVudC5jbGFzc0xpc3QsIEVsZW1lbnQuc2xvdCwgRWxlbWVudC5hdHRyaWJ1dGVzLCBFbGVtZW50LnNoYWRvd1Jvb3QsIEVsZW1lbnQucGFydCwgRWxlbWVudC5hc3NpZ25lZFNsb3QsIEVsZW1lbnQuaW5uZXJIVE1MLCBFbGVtZW50Lm91dGVySFRNTCwgRWxlbWVudC5zY3JvbGxUb3AsIEVsZW1lbnQuc2Nyb2xsTGVmdCwgRWxlbWVudC5zY3JvbGxXaWR0aCwgRWxlbWVudC5zY3JvbGxIZWlnaHQsIEVsZW1lbnQuY2xpZW50VG9wLCBFbGVtZW50LmNsaWVudExlZnQsIEVsZW1lbnQuY2xpZW50V2lkdGgsIEVsZW1lbnQuY2xpZW50SGVpZ2h0LCBFbGVtZW50Lm9uYmVmb3JlY29weSwgRWxlbWVudC5vbmJlZm9yZWN1dCwgRWxlbWVudC5vbmJlZm9yZXBhc3RlLCBFbGVtZW50Lm9uc2VhcmNoLCBFbGVtZW50LmVsZW1lbnRUaW1pbmcsIEVsZW1lbnQub25mdWxsc2NyZWVuY2hhbmdlLCBFbGVtZW50Lm9uZnVsbHNjcmVlbmVycm9yLCBFbGVtZW50Lm9ud2Via2l0ZnVsbHNjcmVlbmNoYW5nZSwgRWxlbWVudC5vbndlYmtpdGZ1bGxzY3JlZW5lcnJvciwgRWxlbWVudC5yb2xlLCBFbGVtZW50LmFyaWFBdG9taWMsIEVsZW1lbnQuYXJpYUF1dG9Db21wbGV0ZSwgRWxlbWVudC5hcmlhQnVzeSwgRWxlbWVudC5hcmlhQnJhaWxsZUxhYmVsLCBFbGVtZW50LmFyaWFCcmFpbGxlUm9sZURlc2NyaXB0aW9uLCBFbGVtZW50LmFyaWFDaGVja2VkLCBFbGVtZW50LmFyaWFDb2xDb3VudCwgRWxlbWVudC5hcmlhQ29sSW5kZXgsIEVsZW1lbnQuYXJpYUNvbFNwYW4sIEVsZW1lbnQuYXJpYUN1cnJlbnQsIEVsZW1lbnQuYXJpYURlc2NyaXB0aW9uLCBFbGVtZW50LmFyaWFEaXNhYmxlZCwgRWxlbWVudC5hcmlhRXhwYW5kZWQsIEVsZW1lbnQuYXJpYUhhc1BvcHVwLCBFbGVtZW50LmFyaWFIaWRkZW4sIEVsZW1lbnQuYXJpYUludmFsaWQsIEVsZW1lbnQuYXJpYUtleVNob3J0Y3V0cywgRWxlbWVudC5hcmlhTGFiZWwsIEVsZW1lbnQuYXJpYUxldmVsLCBFbGVtZW50LmFyaWFMaXZlLCBFbGVtZW50LmFyaWFNb2RhbCwgRWxlbWVudC5hcmlhTXVsdGlMaW5lLCBFbGVtZW50LmFyaWFNdWx0aVNlbGVjdGFibGUsIEVsZW1lbnQuYXJpYU9yaWVudGF0aW9uLCBFbGVtZW50LmFyaWFQbGFjZWhvbGRlciwgRWxlbWVudC5hcmlhUG9zSW5TZXQsIEVsZW1lbnQuYXJpYVByZXNzZWQsIEVsZW1lbnQuYXJpYVJlYWRPbmx5LCBFbGVtZW50LmFyaWFSZWxldmFudCwgRWxlbWVudC5hcmlhUmVxdWlyZWQsIEVsZW1lbnQuYXJpYVJvbGVEZXNjcmlwdGlvbiwgRWxlbWVudC5hcmlhUm93Q291bnQsIEVsZW1lbnQuYXJpYVJvd0luZGV4LCBFbGVtZW50LmFyaWFSb3dTcGFuLCBFbGVtZW50LmFyaWFTZWxlY3RlZCwgRWxlbWVudC5hcmlhU2V0U2l6ZSwgRWxlbWVudC5hcmlhU29ydCwgRWxlbWVudC5hcmlhVmFsdWVNYXgsIEVsZW1lbnQuYXJpYVZhbHVlTWluLCBFbGVtZW50LmFyaWFWYWx1ZU5vdywgRWxlbWVudC5hcmlhVmFsdWVUZXh0LCBFbGVtZW50LmNoaWxkcmVuLCBFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLCBFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQsIEVsZW1lbnQuY2hpbGRFbGVtZW50Q291bnQsIEVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZywgRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcsIEVsZW1lbnQuYWZ0ZXIsIEVsZW1lbnQuYW5pbWF0ZSwgRWxlbWVudC5hcHBlbmQsIEVsZW1lbnQuYXR0YWNoU2hhZG93LCBFbGVtZW50LmJlZm9yZSwgRWxlbWVudC5jbG9zZXN0LCBFbGVtZW50LmNvbXB1dGVkU3R5bGVNYXAsIEVsZW1lbnQuZ2V0QXR0cmlidXRlLCBFbGVtZW50LmdldEF0dHJpYnV0ZU5TLCBFbGVtZW50LmdldEF0dHJpYnV0ZU5hbWVzLCBFbGVtZW50LmdldEF0dHJpYnV0ZU5vZGUsIEVsZW1lbnQuZ2V0QXR0cmlidXRlTm9kZU5TLCBFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCwgRWxlbWVudC5nZXRDbGllbnRSZWN0cywgRWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lLCBFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lLCBFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lTlMsIEVsZW1lbnQuZ2V0SW5uZXJIVE1MLCBFbGVtZW50Lmhhc0F0dHJpYnV0ZSwgRWxlbWVudC5oYXNBdHRyaWJ1dGVOUywgRWxlbWVudC5oYXNBdHRyaWJ1dGVzLCBFbGVtZW50Lmhhc1BvaW50ZXJDYXB0dXJlLCBFbGVtZW50Lmluc2VydEFkamFjZW50RWxlbWVudCwgRWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwsIEVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRUZXh0LCBFbGVtZW50Lm1hdGNoZXMsIEVsZW1lbnQucHJlcGVuZCwgRWxlbWVudC5xdWVyeVNlbGVjdG9yLCBFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwsIEVsZW1lbnQucmVsZWFzZVBvaW50ZXJDYXB0dXJlLCBFbGVtZW50LnJlbW92ZSwgRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUsIEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlTlMsIEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlTm9kZSwgRWxlbWVudC5yZXBsYWNlQ2hpbGRyZW4sIEVsZW1lbnQucmVwbGFjZVdpdGgsIEVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4sIEVsZW1lbnQucmVxdWVzdFBvaW50ZXJMb2NrLCBFbGVtZW50LnNjcm9sbCwgRWxlbWVudC5zY3JvbGxCeSwgRWxlbWVudC5zY3JvbGxJbnRvVmlldywgRWxlbWVudC5zY3JvbGxJbnRvVmlld0lmTmVlZGVkLCBFbGVtZW50LnNjcm9sbFRvLCBFbGVtZW50LnNldEF0dHJpYnV0ZSwgRWxlbWVudC5zZXRBdHRyaWJ1dGVOUywgRWxlbWVudC5zZXRBdHRyaWJ1dGVOb2RlLCBFbGVtZW50LnNldEF0dHJpYnV0ZU5vZGVOUywgRWxlbWVudC5zZXRQb2ludGVyQ2FwdHVyZSwgRWxlbWVudC50b2dnbGVBdHRyaWJ1dGUsIEVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yLCBFbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuLCBFbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuLCBFbGVtZW50LmNoZWNrVmlzaWJpbGl0eSwgRWxlbWVudC5nZXRBbmltYXRpb25zLCBFbGVtZW50LnNldEhUTUwifSxGaXJlZm94Ont2ZXJzaW9uOjEwOCx3aW5kb3dLZXlzOiJ1bmRlZmluZWQsIGdsb2JhbFRoaXMsIEFycmF5LCBCb29sZWFuLCBKU09OLCBEYXRlLCBNYXRoLCBOdW1iZXIsIFN0cmluZywgUmVnRXhwLCBFcnJvciwgSW50ZXJuYWxFcnJvciwgQWdncmVnYXRlRXJyb3IsIEV2YWxFcnJvciwgUmFuZ2VFcnJvciwgUmVmZXJlbmNlRXJyb3IsIFN5bnRheEVycm9yLCBUeXBlRXJyb3IsIFVSSUVycm9yLCBBcnJheUJ1ZmZlciwgSW50OEFycmF5LCBVaW50OEFycmF5LCBJbnQxNkFycmF5LCBVaW50MTZBcnJheSwgSW50MzJBcnJheSwgVWludDMyQXJyYXksIEZsb2F0MzJBcnJheSwgRmxvYXQ2NEFycmF5LCBVaW50OENsYW1wZWRBcnJheSwgQmlnSW50NjRBcnJheSwgQmlnVWludDY0QXJyYXksIEJpZ0ludCwgUHJveHksIFdlYWtNYXAsIFNldCwgRGF0YVZpZXcsIFN5bWJvbCwgSW50bCwgUmVmbGVjdCwgV2Vha1NldCwgQXRvbWljcywgUHJvbWlzZSwgV2ViQXNzZW1ibHksIEZpbmFsaXphdGlvblJlZ2lzdHJ5LCBXZWFrUmVmLCBOYU4sIEluZmluaXR5LCBpc05hTiwgaXNGaW5pdGUsIHBhcnNlRmxvYXQsIHBhcnNlSW50LCBlc2NhcGUsIHVuZXNjYXBlLCBkZWNvZGVVUkksIGVuY29kZVVSSSwgZGVjb2RlVVJJQ29tcG9uZW50LCBlbmNvZGVVUklDb21wb25lbnQsIFJlc2l6ZU9ic2VydmVyRW50cnksIEJyb2FkY2FzdENoYW5uZWwsIEFib3J0Q29udHJvbGxlciwgRE9NUmVjdExpc3QsIFNWR0FuaW1hdGVkRW51bWVyYXRpb24sIERPTVBvaW50UmVhZE9ubHksIFJUQ0R0bHNUcmFuc3BvcnQsIE1lZGlhU3RyZWFtVHJhY2tFdmVudCwgSFRNTE1lZGlhRWxlbWVudCwgTWVkaWFEZXZpY2VzLCBUZXh0TWV0cmljcywgTUlESUFjY2VzcywgR2FtZXBhZEJ1dHRvbiwgSUlSRmlsdGVyTm9kZSwgUmVzcG9uc2UsIFB1c2hTdWJzY3JpcHRpb24sIERvY3VtZW50VGltZWxpbmUsIFNWR0FuaW1hdGVkTnVtYmVyTGlzdCwgSFRNTEltYWdlRWxlbWVudCwgSFRNTEZvbnRFbGVtZW50LCBTb3VyY2VCdWZmZXJMaXN0LCBTVkdGaWx0ZXJFbGVtZW50LCBIVE1MUGljdHVyZUVsZW1lbnQsIENTU0dyb3VwaW5nUnVsZSwgSFRNTFNsb3RFbGVtZW50LCBEZXZpY2VPcmllbnRhdGlvbkV2ZW50LCBTVkdEZWZzRWxlbWVudCwgWFBhdGhSZXN1bHQsIFNWR0ZFRGlmZnVzZUxpZ2h0aW5nRWxlbWVudCwgVlRUQ3VlLCBOb2RlRmlsdGVyLCBXZWJHTFRleHR1cmUsIEdhaW5Ob2RlLCBUZXh0RGVjb2RlciwgR2FtZXBhZFBvc2UsIEZpbGVTeXN0ZW1GaWxlRW50cnksIFNWR1JhZGlhbEdyYWRpZW50RWxlbWVudCwgV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXQsIFNWR1NjcmlwdEVsZW1lbnQsIElEQk9wZW5EQlJlcXVlc3QsIEN1c3RvbUV2ZW50LCBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5LCBET01SZWN0UmVhZE9ubHksIERhdGFUcmFuc2Zlckl0ZW0sIE1JRElJbnB1dCwgVGV4dERlY29kZXJTdHJlYW0sIFNWR0NvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25FbGVtZW50LCBJbWFnZSwgTm90aWZpY2F0aW9uLCBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QsIEhUTUxIZWFkaW5nRWxlbWVudCwgRm9udEZhY2UsIE1JRElPdXRwdXRNYXAsIFNWR0ZFTWVyZ2VOb2RlRWxlbWVudCwgUG9wU3RhdGVFdmVudCwgSFRNTFRyYWNrRWxlbWVudCwgUGx1Z2luQXJyYXksIE1JRElQb3J0LCBGb2N1c0V2ZW50LCBTVkdBbmltYXRlVHJhbnNmb3JtRWxlbWVudCwgRGF0YVRyYW5zZmVyLCBIVE1MU3BhbkVsZW1lbnQsIEhUTUxNZXRlckVsZW1lbnQsIEF1ZGlvUHJvY2Vzc2luZ0V2ZW50LCBIVE1MVGltZUVsZW1lbnQsIElEQkRhdGFiYXNlLCBTVkdBbmltYXRlZEludGVnZXIsIENoYW5uZWxNZXJnZXJOb2RlLCBIVE1MRm9ybUVsZW1lbnQsIFhNTERvY3VtZW50LCBOYXZpZ2F0aW9uUHJlbG9hZE1hbmFnZXIsIEZpbGVSZWFkZXIsIFJhbmdlLCBUZXh0RW5jb2RlclN0cmVhbSwgSFRNTEJvZHlFbGVtZW50LCBIVE1MVGl0bGVFbGVtZW50LCBDb21tZW50LCBGaWxlU3lzdGVtRGlyZWN0b3J5UmVhZGVyLCBQdWJsaWNLZXlDcmVkZW50aWFsLCBJbWFnZUJpdG1hcCwgY29uc29sZSwgRm9udEZhY2VTZXQsIEhUTUxQcm9ncmVzc0VsZW1lbnQsIFJUQ1RyYWNrRXZlbnQsIFBvaW50ZXJFdmVudCwgSFRNTEZpZWxkU2V0RWxlbWVudCwgTWVkaWFTb3VyY2UsIFNWR0ZFRGlzcGxhY2VtZW50TWFwRWxlbWVudCwgQ2FjaGUsIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciwgTWVzc2FnZUV2ZW50LCBXZWJHTFByb2dyYW0sIFN0YXRpY1JhbmdlLCBYUGF0aEV2YWx1YXRvciwgSFRNTEFyZWFFbGVtZW50LCBIVE1MRm9ybUNvbnRyb2xzQ29sbGVjdGlvbiwgUGFpbnRSZXF1ZXN0LCBDaGFubmVsU3BsaXR0ZXJOb2RlLCBNZWRpYVNlc3Npb24sIERPTVJlY3QsIFNWR0ZFU3BlY3VsYXJMaWdodGluZ0VsZW1lbnQsIFNWR0Rlc2NFbGVtZW50LCBBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGUsIEhUTUxVbmtub3duRWxlbWVudCwgU1ZHRkVUaWxlRWxlbWVudCwgSFRNTE1lbnVFbGVtZW50LCBTdG9yYWdlLCBDb25zdGFudFNvdXJjZU5vZGUsIENhY2hlU3RvcmFnZSwgU1ZHQW5pbWF0ZWRQcmVzZXJ2ZUFzcGVjdFJhdGlvLCBTVkdGRUZ1bmNHRWxlbWVudCwgU2Nyb2xsQXJlYUV2ZW50LCBDU1NNZWRpYVJ1bGUsIFNWR1NldEVsZW1lbnQsIFNWR0dFbGVtZW50LCBTVkdNZXRhZGF0YUVsZW1lbnQsIENsaXBib2FyZEV2ZW50LCBBdWRpb0NvbnRleHQsIFdlYkdMUmVuZGVyYnVmZmVyLCBBdWRpb1BhcmFtTWFwLCBXZWJHTFF1ZXJ5LCBNZWRpYUtleVNlc3Npb24sIEhUTUxWaWRlb0VsZW1lbnQsIFNWR0ZFVHVyYnVsZW5jZUVsZW1lbnQsIEJlZm9yZVVubG9hZEV2ZW50LCBDU1NUcmFuc2l0aW9uLCBTVkdUZXh0UG9zaXRpb25pbmdFbGVtZW50LCBSVENQZWVyQ29ubmVjdGlvbkljZUV2ZW50LCBTVkdUcmFuc2Zvcm0sIFBlcmZvcm1hbmNlRXZlbnRUaW1pbmcsIEhUTUxCUkVsZW1lbnQsIFNWR1RTcGFuRWxlbWVudCwgU1ZHTWFza0VsZW1lbnQsIFNWR01hcmtlckVsZW1lbnQsIFUyRiwgTXV0YXRpb25SZWNvcmQsIEF1ZGlvRGVzdGluYXRpb25Ob2RlLCBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCBVSUV2ZW50LCBXZWJHTEJ1ZmZlciwgSURCVHJhbnNhY3Rpb24sIE9mZmxpbmVSZXNvdXJjZUxpc3QsIEhUTUxJbnB1dEVsZW1lbnQsIEhUTUxMZWdlbmRFbGVtZW50LCBtb3pSVENTZXNzaW9uRGVzY3JpcHRpb24sIFNWR0FuaW1hdGlvbkVsZW1lbnQsIFNWR1ZpZXdFbGVtZW50LCBDYXJldFBvc2l0aW9uLCBFdmVudFNvdXJjZSwgU2hhcmVkV29ya2VyLCBTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uLCBEZWxheU5vZGUsIENyeXB0b0tleSwgU1ZHTVBhdGhFbGVtZW50LCBOb2RlTGlzdCwgU1ZHRkVQb2ludExpZ2h0RWxlbWVudCwgTWVkaWFFcnJvciwgU1ZHRkVGbG9vZEVsZW1lbnQsIE1lZGlhS2V5TWVzc2FnZUV2ZW50LCBIVE1MVGV4dEFyZWFFbGVtZW50LCBNZWRpYURldmljZUluZm8sIENTU0NvdW50ZXJTdHlsZVJ1bGUsIEhUTUxUYWJsZVJvd0VsZW1lbnQsIEF1ZGlvV29ya2xldE5vZGUsIEF1dGhlbnRpY2F0b3JSZXNwb25zZSwgQXVkaW9Ob2RlLCBTdG9yYWdlTWFuYWdlciwgUGVybWlzc2lvbnMsIElEQktleVJhbmdlLCBTVkdGRUNvbXBvbmVudFRyYW5zZmVyRWxlbWVudCwgSFRNTE91dHB1dEVsZW1lbnQsIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQsIFNWR1RpdGxlRWxlbWVudCwgQW5pbWF0aW9uUGxheWJhY2tFdmVudCwgUHJvbWlzZVJlamVjdGlvbkV2ZW50LCBQZXJmb3JtYW5jZVBhaW50VGltaW5nLCBTVkdVbml0VHlwZXMsIFNWR1VzZUVsZW1lbnQsIFBlcmZvcm1hbmNlVGltaW5nLCBNYXRoTUxFbGVtZW50LCBHYW1lcGFkSGFwdGljQWN0dWF0b3IsIE5hdmlnYXRvciwgbW96UlRDUGVlckNvbm5lY3Rpb24sIFBlcmZvcm1hbmNlUmVzb3VyY2VUaW1pbmcsIEFuaW1hdGlvblRpbWVsaW5lLCBNSURJQ29ubmVjdGlvbkV2ZW50LCBDYW52YXNDYXB0dXJlTWVkaWFTdHJlYW0sIEhUTUxEaXJlY3RvcnlFbGVtZW50LCBHYW1lcGFkLCBMb2NrLCBET01RdWFkLCBNZWRpYVN0cmVhbVRyYWNrQXVkaW9Tb3VyY2VOb2RlLCBQb3B1cEJsb2NrZWRFdmVudCwgTW91c2VTY3JvbGxFdmVudCwgU1ZHRkVGdW5jQUVsZW1lbnQsIERhdGFUcmFuc2Zlckl0ZW1MaXN0LCBBdWRpb0J1ZmZlclNvdXJjZU5vZGUsIFdlYkdMQ29udGV4dEV2ZW50LCBYU0xUUHJvY2Vzc29yLCBTVkdGRUNvbXBvc2l0ZUVsZW1lbnQsIFRleHRUcmFjaywgT2ZmbGluZUF1ZGlvQ29tcGxldGlvbkV2ZW50LCBIVE1MSFJFbGVtZW50LCBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UsIENyZWRlbnRpYWxzQ29udGFpbmVyLCBSVENSdHBUcmFuc2NlaXZlciwgU1ZHVGV4dEVsZW1lbnQsIEltYWdlQml0bWFwUmVuZGVyaW5nQ29udGV4dCwgTWVkaWFMaXN0LCBIVE1MRGl2RWxlbWVudCwgU1ZHR3JhcGhpY3NFbGVtZW50LCBDYW52YXNQYXR0ZXJuLCBSZXNpemVPYnNlcnZlciwgSFRNTEJhc2VFbGVtZW50LCBNaW1lVHlwZUFycmF5LCBNZWRpYUNhcGFiaWxpdGllc0luZm8sIEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50LCBIVE1MU2VsZWN0RWxlbWVudCwgVmlkZW9QbGF5YmFja1F1YWxpdHksIFJUQ0RhdGFDaGFubmVsRXZlbnQsIEhlYWRlcnMsIElkbGVEZWFkbGluZSwgV2ViR0xTYW1wbGVyLCBIVE1MRnJhbWVFbGVtZW50LCBXZWJHTFNoYWRlciwgT3B0aW9uLCBQYWludFJlcXVlc3RMaXN0LCBCYXJQcm9wLCBTVkdNYXRyaXgsIEltYWdlRGF0YSwgQ1NTRm9udEZlYXR1cmVWYWx1ZXNSdWxlLCBTVkdQb2x5bGluZUVsZW1lbnQsIENTU0ltcG9ydFJ1bGUsIE1lZGlhU3RyZWFtRXZlbnQsIEhUTUxMYWJlbEVsZW1lbnQsIFJlYWRhYmxlU3RyZWFtLCBIVE1MRGlhbG9nRWxlbWVudCwgU1ZHQW5pbWF0ZWRTdHJpbmcsIE1pbWVUeXBlLCBTdG9yYWdlRXZlbnQsIElEQk9iamVjdFN0b3JlLCBIVE1MUGFyYW1FbGVtZW50LCBDU1NSdWxlTGlzdCwgSURCQ3Vyc29yLCBDU1NOYW1lc3BhY2VSdWxlLCBXb3JrZXIsIFNWR0FuaW1hdGVkVHJhbnNmb3JtTGlzdCwgR2VvbG9jYXRpb25Qb3NpdGlvbiwgUGFnZVRyYW5zaXRpb25FdmVudCwgRGlyZWN0b3J5LCBQZXJmb3JtYW5jZU9ic2VydmVyRW50cnlMaXN0LCBQZXJmb3JtYW5jZU1hcmssIEFuYWx5c2VyTm9kZSwgQ2xvc2VFdmVudCwgRG9jdW1lbnRUeXBlLCBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciwgU1ZHUGF0aEVsZW1lbnQsIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIsIFBlcmlvZGljV2F2ZSwgQmlxdWFkRmlsdGVyTm9kZSwgU3VibWl0RXZlbnQsIFdlYkdMVmVydGV4QXJyYXlPYmplY3QsIEhUTUxRdW90ZUVsZW1lbnQsIFJlcXVlc3QsIFNWR0NsaXBQYXRoRWxlbWVudCwgUmFkaW9Ob2RlTGlzdCwgUlRDUGVlckNvbm5lY3Rpb24sIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3ksIFdlYkdMVHJhbnNmb3JtRmVlZGJhY2ssIEhUTUxIZWFkRWxlbWVudCwgQ1NTTGF5ZXJTdGF0ZW1lbnRSdWxlLCBTVkdBRWxlbWVudCwgU2VydmljZVdvcmtlciwgQXVkaW9QYXJhbSwgSURCVmVyc2lvbkNoYW5nZUV2ZW50LCBCbG9iRXZlbnQsIFRyYWNrRXZlbnQsIFRleHQsIE1lZGlhS2V5cywgTWVkaWFNZXRhZGF0YSwgRE9NVG9rZW5MaXN0LCBTcGVlY2hTeW50aGVzaXMsIFJUQ1J0cFJlY2VpdmVyLCBSZXNpemVPYnNlcnZlclNpemUsIEZvcm1EYXRhLCBNZWRpYVN0cmVhbSwgSFRNTE1ldGFFbGVtZW50LCBXb3JrbGV0LCBGaWxlU3lzdGVtLCBTVkdMaW5lYXJHcmFkaWVudEVsZW1lbnQsIEVsZW1lbnQsIFNWR0FuaW1hdGVkUmVjdCwgU1ZHVGV4dFBhdGhFbGVtZW50LCBDU1NLZXlmcmFtZVJ1bGUsIFRpbWVFdmVudCwgSW5wdXRFdmVudCwgQWJzdHJhY3RSYW5nZSwgQWJvcnRTaWduYWwsIERldmljZU1vdGlvbkV2ZW50LCBTVkdBbmltYXRlZExlbmd0aExpc3QsIFBlcmZvcm1hbmNlTWVhc3VyZSwgSURCRmFjdG9yeSwgTWVkaWFSZWNvcmRlciwgQ1NTQ29uZGl0aW9uUnVsZSwgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLCBDU1NLZXlmcmFtZXNSdWxlLCBOb2RlSXRlcmF0b3IsIEdlb2xvY2F0aW9uLCBSVENJY2VDYW5kaWRhdGUsIE1lZGlhS2V5RXJyb3IsIEFuaW1hdGlvbkV2ZW50LCBDdXN0b21FbGVtZW50UmVnaXN0cnksIEhUTUxPYmplY3RFbGVtZW50LCBGaWxlLCBFcnJvckV2ZW50LCBNZWRpYVF1ZXJ5TGlzdEV2ZW50LCBWYWxpZGl0eVN0YXRlLCBQYW5uZXJOb2RlLCBJbnRlcnNlY3Rpb25PYnNlcnZlciwgRE9NU3RyaW5nTGlzdCwgU1ZHRkVPZmZzZXRFbGVtZW50LCBQbHVnaW4sIERPTVBhcnNlciwgU1ZHRkVDb252b2x2ZU1hdHJpeEVsZW1lbnQsIFNwZWVjaFN5bnRoZXNpc0V2ZW50LCBUcmVlV2Fsa2VyLCBIVE1MQWxsQ29sbGVjdGlvbiwgU1ZHQ2lyY2xlRWxlbWVudCwgU1ZHRkVEaXN0YW50TGlnaHRFbGVtZW50LCBTcGVlY2hTeW50aGVzaXNFcnJvckV2ZW50LCBXYXZlU2hhcGVyTm9kZSwgQ1NTQW5pbWF0aW9uLCBVUkwsIFNWR0xlbmd0aExpc3QsIFN1YnRsZUNyeXB0bywgU1ZHUG9pbnRMaXN0LCBIVE1MQXVkaW9FbGVtZW50LCBNZXNzYWdlQ2hhbm5lbCwgTWVzc2FnZVBvcnQsIFdlYkdMQWN0aXZlSW5mbywgU2NyZWVuLCBYUGF0aEV4cHJlc3Npb24sIE1lZGlhUmVjb3JkZXJFcnJvckV2ZW50LCBIVE1MQnV0dG9uRWxlbWVudCwgTG9jYXRpb24sIE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlLCBBbmltYXRpb25FZmZlY3QsIFBlcmZvcm1hbmNlT2JzZXJ2ZXIsIFNWR1JlY3RFbGVtZW50LCBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsIERPTVBvaW50LCBNZWRpYUtleVN5c3RlbUFjY2VzcywgU1ZHRkVEcm9wU2hhZG93RWxlbWVudCwgSFRNTERhdGFFbGVtZW50LCBTVkdUZXh0Q29udGVudEVsZW1lbnQsIFNWR0ZFTW9ycGhvbG9neUVsZW1lbnQsIFNWR0VsZW1lbnQsIEhUTUxNb2RFbGVtZW50LCBCbG9iLCBDREFUQVNlY3Rpb24sIEZvbnRGYWNlU2V0TG9hZEV2ZW50LCBBdXRoZW50aWNhdG9yQXR0ZXN0YXRpb25SZXNwb25zZSwgVGV4dFRyYWNrQ3VlLCBDU1NGb250RmFjZVJ1bGUsIE1lZGlhU3RyZWFtQXVkaW9EZXN0aW5hdGlvbk5vZGUsIFNWR0ltYWdlRWxlbWVudCwgU1ZHUmVjdCwgU1ZHU3RvcEVsZW1lbnQsIFZUVFJlZ2lvbiwgU1ZHRkVTcG90TGlnaHRFbGVtZW50LCBTZWxlY3Rpb24sIEJhc2VBdWRpb0NvbnRleHQsIFNWR1BvaW50LCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIEF0dHIsIFhNTEh0dHBSZXF1ZXN0LCBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIsIEF1ZGlvLCBIVE1MU3R5bGVFbGVtZW50LCBTVkdFbGxpcHNlRWxlbWVudCwgTXV0YXRpb25FdmVudCwgUHJvZ3Jlc3NFdmVudCwgSFRNTFByZUVsZW1lbnQsIERPTUltcGxlbWVudGF0aW9uLCBIVE1MTWFycXVlZUVsZW1lbnQsIFhNTFNlcmlhbGl6ZXIsIFNWR0FuaW1hdGVNb3Rpb25FbGVtZW50LCBTVkdHZW9tZXRyeUVsZW1lbnQsIElEQlJlcXVlc3QsIFB1c2hNYW5hZ2VyLCBDU1NNb3pEb2N1bWVudFJ1bGUsIEhUTUxNYXBFbGVtZW50LCBBdWRpb0xpc3RlbmVyLCBHYW1lcGFkRXZlbnQsIE1JRElNZXNzYWdlRXZlbnQsIEVsZW1lbnRJbnRlcm5hbHMsIFRleHRFbmNvZGVyLCB3ZWJraXRVUkwsIENTU1N0eWxlUnVsZSwgU1ZHR3JhZGllbnRFbGVtZW50LCBIVE1MRGV0YWlsc0VsZW1lbnQsIFNWR0ZvcmVpZ25PYmplY3RFbGVtZW50LCBDaGFyYWN0ZXJEYXRhLCBSVENDZXJ0aWZpY2F0ZSwgSFRNTENhbnZhc0VsZW1lbnQsIFJUQ0RUTUZUb25lQ2hhbmdlRXZlbnQsIENTU1N0eWxlU2hlZXQsIFNjcmVlbk9yaWVudGF0aW9uLCBTaGFkb3dSb290LCBEeW5hbWljc0NvbXByZXNzb3JOb2RlLCBXcml0YWJsZVN0cmVhbSwgSFRNTEZyYW1lU2V0RWxlbWVudCwgVGltZVJhbmdlcywgS2V5ZnJhbWVFZmZlY3QsIFNWR1NWR0VsZW1lbnQsIEtleUV2ZW50LCBDbGlwYm9hcmQsIEhUTUxETGlzdEVsZW1lbnQsIENvdW50UXVldWluZ1N0cmF0ZWd5LCBEb2N1bWVudEZyYWdtZW50LCBEcmFnRXZlbnQsIG1velJUQ0ljZUNhbmRpZGF0ZSwgTWVkaWFTdHJlYW1UcmFjaywgU1ZHTGVuZ3RoLCBNZWRpYVF1ZXJ5TGlzdCwgVVJMU2VhcmNoUGFyYW1zLCBIVE1MU291cmNlRWxlbWVudCwgS2V5Ym9hcmRFdmVudCwgU2NyaXB0UHJvY2Vzc29yTm9kZSwgRE9NU3RyaW5nTWFwLCBIVE1MT3B0R3JvdXBFbGVtZW50LCBXZWJHTFVuaWZvcm1Mb2NhdGlvbiwgT2Zmc2NyZWVuQ2FudmFzLCBTVkdQb2x5Z29uRWxlbWVudCwgSFRNTENvbGxlY3Rpb24sIFNWR051bWJlciwgTWVkaWFDYXBhYmlsaXRpZXMsIFNvdXJjZUJ1ZmZlciwgVmlzdWFsVmlld3BvcnQsIENTU1BhZ2VSdWxlLCBHZW9sb2NhdGlvblBvc2l0aW9uRXJyb3IsIEhUTUxUYWJsZUNvbEVsZW1lbnQsIFNWR1RyYW5zZm9ybUxpc3QsIFNWR0FuaW1hdGVkTnVtYmVyLCBDYW52YXNHcmFkaWVudCwgUHVzaFN1YnNjcmlwdGlvbk9wdGlvbnMsIEhpc3RvcnksIFdlYktpdENTU01hdHJpeCwgSFRNTFRhYmxlQ2VsbEVsZW1lbnQsIEhUTUxPcHRpb25FbGVtZW50LCBNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUsIEZvcm1EYXRhRXZlbnQsIFRleHRUcmFja0N1ZUxpc3QsIFNWR1N3aXRjaEVsZW1lbnQsIFBhdGgyRCwgU3R5bGVTaGVldCwgUGVyZm9ybWFuY2VTZXJ2ZXJUaW1pbmcsIFBlcmZvcm1hbmNlTmF2aWdhdGlvbiwgTXV0YXRpb25PYnNlcnZlciwgWE1MSHR0cFJlcXVlc3RVcGxvYWQsIENTU0xheWVyQmxvY2tSdWxlLCBTVkdQcmVzZXJ2ZUFzcGVjdFJhdGlvLCBIVE1MVGFibGVDYXB0aW9uRWxlbWVudCwgU1ZHUGF0dGVybkVsZW1lbnQsIEhUTUxFbWJlZEVsZW1lbnQsIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQsIFRyYW5zaXRpb25FdmVudCwgSFRNTEFuY2hvckVsZW1lbnQsIEhUTUxEYXRhTGlzdEVsZW1lbnQsIFNWR0FuZ2xlLCBTVkdMaW5lRWxlbWVudCwgQXVkaW9CdWZmZXIsIEhhc2hDaGFuZ2VFdmVudCwgTWVkaWFLZXlTdGF0dXNNYXAsIElEQkluZGV4LCBDU1MsIFNWR0ZFR2F1c3NpYW5CbHVyRWxlbWVudCwgQ3J5cHRvLCBOYW1lZE5vZGVNYXAsIENTU1N0eWxlRGVjbGFyYXRpb24sIE1vdXNlRXZlbnQsIEZpbGVTeXN0ZW1FbnRyeSwgRE9NTWF0cml4LCBTVkdBbmltYXRlZEFuZ2xlLCBPZmZsaW5lQXVkaW9Db250ZXh0LCBIVE1MU2NyaXB0RWxlbWVudCwgU3R5bGVTaGVldExpc3QsIFJUQ0RUTUZTZW5kZXIsIEhUTUxPTGlzdEVsZW1lbnQsIFNWR1N5bWJvbEVsZW1lbnQsIFNwZWVjaFN5bnRoZXNpc1ZvaWNlLCBTVkdGRUNvbG9yTWF0cml4RWxlbWVudCwgVHJhbnNmb3JtU3RyZWFtLCBTVkdGRUZ1bmNCRWxlbWVudCwgRE9NUmVxdWVzdCwgUlRDUnRwU2VuZGVyLCBDU1NSdWxlLCBPc2NpbGxhdG9yTm9kZSwgU2VydmljZVdvcmtlckNvbnRhaW5lciwgSFRNTFBhcmFncmFwaEVsZW1lbnQsIENvbnZvbHZlck5vZGUsIEF1ZGlvV29ya2xldCwgSFRNTExpbmtFbGVtZW50LCBNSURJSW5wdXRNYXAsIFBlcmZvcm1hbmNlRW50cnksIEF1dGhlbnRpY2F0b3JBc3NlcnRpb25SZXNwb25zZSwgVGV4dFRyYWNrTGlzdCwgRE9NRXhjZXB0aW9uLCBTVkdBbmltYXRlRWxlbWVudCwgSFRNTE9wdGlvbnNDb2xsZWN0aW9uLCBIVE1MVUxpc3RFbGVtZW50LCBXaGVlbEV2ZW50LCBTVkdBbmltYXRlZEJvb2xlYW4sIFNlY3VyaXR5UG9saWN5VmlvbGF0aW9uRXZlbnQsIFJUQ1N0YXRzUmVwb3J0LCBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIFBlcm1pc3Npb25TdGF0dXMsIENvbXBvc2l0aW9uRXZlbnQsIFNWR0ZFRnVuY1JFbGVtZW50LCBGaWxlTGlzdCwgU1ZHU3RyaW5nTGlzdCwgU1ZHRkVJbWFnZUVsZW1lbnQsIEhUTUxFbGVtZW50LCBET01NYXRyaXhSZWFkT25seSwgTG9ja01hbmFnZXIsIEhUTUxMSUVsZW1lbnQsIFNWR0ZFQmxlbmRFbGVtZW50LCBBbmltYXRpb24sIFJUQ0RhdGFDaGFubmVsLCBNZWRpYUVuY3J5cHRlZEV2ZW50LCBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLCBXZWJHTEZyYW1lYnVmZmVyLCBTVkdTdHlsZUVsZW1lbnQsIFNWR0FuaW1hdGVkTGVuZ3RoLCBDU1NGb250UGFsZXR0ZVZhbHVlc1J1bGUsIENTU1N1cHBvcnRzUnVsZSwgSFRNTElGcmFtZUVsZW1lbnQsIFNWR051bWJlckxpc3QsIE1JRElPdXRwdXQsIFdlYlNvY2tldCwgQ1NTMlByb3BlcnRpZXMsIEhUTUxUYWJsZUVsZW1lbnQsIEZpbGVTeXN0ZW1EaXJlY3RvcnlFbnRyeSwgU1ZHRkVNZXJnZUVsZW1lbnQsIEdlb2xvY2F0aW9uQ29vcmRpbmF0ZXMsIFN0ZXJlb1Bhbm5lck5vZGUsIENyZWRlbnRpYWwsIFdlYkdMUmVuZGVyaW5nQ29udGV4dCwgV2ViR0xTeW5jLCBIVE1MSHRtbEVsZW1lbnQsIEhUTUxUZW1wbGF0ZUVsZW1lbnQsIElEQkN1cnNvcldpdGhWYWx1ZSwgRnVuY3Rpb24sIE9iamVjdCwgZXZhbCwgRXZlbnRUYXJnZXQsIFdpbmRvdywgY2xvc2UsIHN0b3AsIGZvY3VzLCBibHVyLCBvcGVuLCBhbGVydCwgY29uZmlybSwgcHJvbXB0LCBwcmludCwgcG9zdE1lc3NhZ2UsIGNhcHR1cmVFdmVudHMsIHJlbGVhc2VFdmVudHMsIGdldFNlbGVjdGlvbiwgZ2V0Q29tcHV0ZWRTdHlsZSwgbWF0Y2hNZWRpYSwgbW92ZVRvLCBtb3ZlQnksIHJlc2l6ZVRvLCByZXNpemVCeSwgc2Nyb2xsLCBzY3JvbGxUbywgc2Nyb2xsQnksIGdldERlZmF1bHRDb21wdXRlZFN0eWxlLCBzY3JvbGxCeUxpbmVzLCBzY3JvbGxCeVBhZ2VzLCBzaXplVG9Db250ZW50LCB1cGRhdGVDb21tYW5kcywgZmluZCwgZHVtcCwgc2V0UmVzaXphYmxlLCByZXF1ZXN0SWRsZUNhbGxiYWNrLCBjYW5jZWxJZGxlQ2FsbGJhY2ssIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUsIHJlcG9ydEVycm9yLCBidG9hLCBhdG9iLCBzZXRUaW1lb3V0LCBjbGVhclRpbWVvdXQsIHNldEludGVydmFsLCBjbGVhckludGVydmFsLCBxdWV1ZU1pY3JvdGFzaywgY3JlYXRlSW1hZ2VCaXRtYXAsIHN0cnVjdHVyZWRDbG9uZSwgZmV0Y2gsIHNlbGYsIG5hbWUsIGhpc3RvcnksIGN1c3RvbUVsZW1lbnRzLCBsb2NhdGlvbmJhciwgbWVudWJhciwgcGVyc29uYWxiYXIsIHNjcm9sbGJhcnMsIHN0YXR1c2JhciwgdG9vbGJhciwgc3RhdHVzLCBjbG9zZWQsIGV2ZW50LCBmcmFtZXMsIGxlbmd0aCwgb3BlbmVyLCBwYXJlbnQsIGZyYW1lRWxlbWVudCwgbmF2aWdhdG9yLCBjbGllbnRJbmZvcm1hdGlvbiwgZXh0ZXJuYWwsIGFwcGxpY2F0aW9uQ2FjaGUsIHNjcmVlbiwgaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQsIHNjcm9sbFgsIHBhZ2VYT2Zmc2V0LCBzY3JvbGxZLCBwYWdlWU9mZnNldCwgc2NyZWVuTGVmdCwgc2NyZWVuVG9wLCBzY3JlZW5YLCBzY3JlZW5ZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCwgcGVyZm9ybWFuY2UsIG1veklubmVyU2NyZWVuWCwgbW96SW5uZXJTY3JlZW5ZLCBkZXZpY2VQaXhlbFJhdGlvLCBzY3JvbGxNYXhYLCBzY3JvbGxNYXhZLCBmdWxsU2NyZWVuLCBvbmRldmljZW1vdGlvbiwgb25kZXZpY2VvcmllbnRhdGlvbiwgb25hYnNvbHV0ZWRldmljZW9yaWVudGF0aW9uLCBJbnN0YWxsVHJpZ2dlciwgdmlzdWFsVmlld3BvcnQsIGNyeXB0bywgb25hYm9ydCwgb25ibHVyLCBvbmZvY3VzLCBvbmF1eGNsaWNrLCBvbmJlZm9yZWlucHV0LCBvbmNhbnBsYXksIG9uY2FucGxheXRocm91Z2gsIG9uY2hhbmdlLCBvbmNsaWNrLCBvbmNsb3NlLCBvbmNvbnRleHRtZW51LCBvbmN1ZWNoYW5nZSwgb25kYmxjbGljaywgb25kcmFnLCBvbmRyYWdlbmQsIG9uZHJhZ2VudGVyLCBvbmRyYWdleGl0LCBvbmRyYWdsZWF2ZSwgb25kcmFnb3Zlciwgb25kcmFnc3RhcnQsIG9uZHJvcCwgb25kdXJhdGlvbmNoYW5nZSwgb25lbXB0aWVkLCBvbmVuZGVkLCBvbmZvcm1kYXRhLCBvbmlucHV0LCBvbmludmFsaWQsIG9ua2V5ZG93biwgb25rZXlwcmVzcywgb25rZXl1cCwgb25sb2FkLCBvbmxvYWRlZGRhdGEsIG9ubG9hZGVkbWV0YWRhdGEsIG9ubG9hZHN0YXJ0LCBvbm1vdXNlZG93biwgb25tb3VzZWVudGVyLCBvbm1vdXNlbGVhdmUsIG9ubW91c2Vtb3ZlLCBvbm1vdXNlb3V0LCBvbm1vdXNlb3Zlciwgb25tb3VzZXVwLCBvbndoZWVsLCBvbnBhdXNlLCBvbnBsYXksIG9ucGxheWluZywgb25wcm9ncmVzcywgb25yYXRlY2hhbmdlLCBvbnJlc2V0LCBvbnJlc2l6ZSwgb25zY3JvbGwsIG9uc2VjdXJpdHlwb2xpY3l2aW9sYXRpb24sIG9uc2Vla2VkLCBvbnNlZWtpbmcsIG9uc2VsZWN0LCBvbnNsb3RjaGFuZ2UsIG9uc3RhbGxlZCwgb25zdWJtaXQsIG9uc3VzcGVuZCwgb250aW1ldXBkYXRlLCBvbnZvbHVtZWNoYW5nZSwgb253YWl0aW5nLCBvbnNlbGVjdHN0YXJ0LCBvbnNlbGVjdGlvbmNoYW5nZSwgb250b2dnbGUsIG9ucG9pbnRlcmNhbmNlbCwgb25wb2ludGVyZG93biwgb25wb2ludGVydXAsIG9ucG9pbnRlcm1vdmUsIG9ucG9pbnRlcm91dCwgb25wb2ludGVyb3Zlciwgb25wb2ludGVyZW50ZXIsIG9ucG9pbnRlcmxlYXZlLCBvbmdvdHBvaW50ZXJjYXB0dXJlLCBvbmxvc3Rwb2ludGVyY2FwdHVyZSwgb25tb3pmdWxsc2NyZWVuY2hhbmdlLCBvbm1vemZ1bGxzY3JlZW5lcnJvciwgb25hbmltYXRpb25jYW5jZWwsIG9uYW5pbWF0aW9uZW5kLCBvbmFuaW1hdGlvbml0ZXJhdGlvbiwgb25hbmltYXRpb25zdGFydCwgb250cmFuc2l0aW9uY2FuY2VsLCBvbnRyYW5zaXRpb25lbmQsIG9udHJhbnNpdGlvbnJ1biwgb250cmFuc2l0aW9uc3RhcnQsIG9ud2Via2l0YW5pbWF0aW9uZW5kLCBvbndlYmtpdGFuaW1hdGlvbml0ZXJhdGlvbiwgb253ZWJraXRhbmltYXRpb25zdGFydCwgb253ZWJraXR0cmFuc2l0aW9uZW5kLCB1MmYsIG9uZXJyb3IsIHNwZWVjaFN5bnRoZXNpcywgb25hZnRlcnByaW50LCBvbmJlZm9yZXByaW50LCBvbmJlZm9yZXVubG9hZCwgb25oYXNoY2hhbmdlLCBvbmxhbmd1YWdlY2hhbmdlLCBvbm1lc3NhZ2UsIG9ubWVzc2FnZWVycm9yLCBvbm9mZmxpbmUsIG9ub25saW5lLCBvbnBhZ2VoaWRlLCBvbnBhZ2VzaG93LCBvbnBvcHN0YXRlLCBvbnJlamVjdGlvbmhhbmRsZWQsIG9uc3RvcmFnZSwgb251bmhhbmRsZWRyZWplY3Rpb24sIG9udW5sb2FkLCBvbmdhbWVwYWRjb25uZWN0ZWQsIG9uZ2FtZXBhZGRpc2Nvbm5lY3RlZCwgbG9jYWxTdG9yYWdlLCBvcmlnaW4sIGNyb3NzT3JpZ2luSXNvbGF0ZWQsIGlzU2VjdXJlQ29udGV4dCwgaW5kZXhlZERCLCBjYWNoZXMsIHNlc3Npb25TdG9yYWdlLCB3aW5kb3csIGRvY3VtZW50LCBsb2NhdGlvbiwgdG9wLCBuZXRzY2FwZSwgTm9kZSwgRG9jdW1lbnQsIEhUTUxEb2N1bWVudCwgRXZlbnRDb3VudHMsIE1hcCwgRXZlbnQiLGNzc0tleXM6ImFsaWduQ29udGVudCwgYWxpZ24tY29udGVudCwgYWxpZ25JdGVtcywgYWxpZ24taXRlbXMsIGFsaWduU2VsZiwgYWxpZ24tc2VsZiwgYXNwZWN0UmF0aW8sIGFzcGVjdC1yYXRpbywgYmFja2ZhY2VWaXNpYmlsaXR5LCBiYWNrZmFjZS12aXNpYmlsaXR5LCBib3JkZXJDb2xsYXBzZSwgYm9yZGVyLWNvbGxhcHNlLCBib3JkZXJJbWFnZVJlcGVhdCwgYm9yZGVyLWltYWdlLXJlcGVhdCwgYm94RGVjb3JhdGlvbkJyZWFrLCBib3gtZGVjb3JhdGlvbi1icmVhaywgYm94U2l6aW5nLCBib3gtc2l6aW5nLCBicmVha0luc2lkZSwgYnJlYWstaW5zaWRlLCBjYXB0aW9uU2lkZSwgY2FwdGlvbi1zaWRlLCBjbGVhciwgY29sb3JJbnRlcnBvbGF0aW9uLCBjb2xvci1pbnRlcnBvbGF0aW9uLCBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzLCBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMsIGNvbHVtbkNvdW50LCBjb2x1bW4tY291bnQsIGNvbHVtbkZpbGwsIGNvbHVtbi1maWxsLCBjb2x1bW5TcGFuLCBjb2x1bW4tc3BhbiwgY29udGFpbiwgZGlyZWN0aW9uLCBkaXNwbGF5LCBkb21pbmFudEJhc2VsaW5lLCBkb21pbmFudC1iYXNlbGluZSwgZW1wdHlDZWxscywgZW1wdHktY2VsbHMsIGZsZXhEaXJlY3Rpb24sIGZsZXgtZGlyZWN0aW9uLCBmbGV4V3JhcCwgZmxleC13cmFwLCBjc3NGbG9hdCwgZmxvYXQsIGZvbnRLZXJuaW5nLCBmb250LWtlcm5pbmcsIGZvbnRPcHRpY2FsU2l6aW5nLCBmb250LW9wdGljYWwtc2l6aW5nLCBmb250U2l6ZUFkanVzdCwgZm9udC1zaXplLWFkanVzdCwgZm9udFN0cmV0Y2gsIGZvbnQtc3RyZXRjaCwgZm9udFN0eWxlLCBmb250LXN0eWxlLCBmb250U3ludGhlc2lzLCBmb250LXN5bnRoZXNpcywgZm9udFZhcmlhbnRDYXBzLCBmb250LXZhcmlhbnQtY2FwcywgZm9udFZhcmlhbnRFYXN0QXNpYW4sIGZvbnQtdmFyaWFudC1lYXN0LWFzaWFuLCBmb250VmFyaWFudExpZ2F0dXJlcywgZm9udC12YXJpYW50LWxpZ2F0dXJlcywgZm9udFZhcmlhbnROdW1lcmljLCBmb250LXZhcmlhbnQtbnVtZXJpYywgZm9udFZhcmlhbnRQb3NpdGlvbiwgZm9udC12YXJpYW50LXBvc2l0aW9uLCBmb250V2VpZ2h0LCBmb250LXdlaWdodCwgZ3JpZEF1dG9GbG93LCBncmlkLWF1dG8tZmxvdywgaHlwaGVucywgaW1hZ2VPcmllbnRhdGlvbiwgaW1hZ2Utb3JpZW50YXRpb24sIGltYWdlUmVuZGVyaW5nLCBpbWFnZS1yZW5kZXJpbmcsIGltZU1vZGUsIGltZS1tb2RlLCBpc29sYXRpb24sIGp1c3RpZnlDb250ZW50LCBqdXN0aWZ5LWNvbnRlbnQsIGp1c3RpZnlJdGVtcywganVzdGlmeS1pdGVtcywganVzdGlmeVNlbGYsIGp1c3RpZnktc2VsZiwgbGluZUJyZWFrLCBsaW5lLWJyZWFrLCBsaXN0U3R5bGVQb3NpdGlvbiwgbGlzdC1zdHlsZS1wb3NpdGlvbiwgbWFza1R5cGUsIG1hc2stdHlwZSwgbWl4QmxlbmRNb2RlLCBtaXgtYmxlbmQtbW9kZSwgTW96Qm94QWxpZ24sIC1tb3otYm94LWFsaWduLCBNb3pCb3hEaXJlY3Rpb24sIC1tb3otYm94LWRpcmVjdGlvbiwgTW96Qm94T3JpZW50LCAtbW96LWJveC1vcmllbnQsIE1vekJveFBhY2ssIC1tb3otYm94LXBhY2ssIE1vekZsb2F0RWRnZSwgLW1vei1mbG9hdC1lZGdlLCBNb3pPcmllbnQsIC1tb3otb3JpZW50LCBNb3pUZXh0U2l6ZUFkanVzdCwgLW1vei10ZXh0LXNpemUtYWRqdXN0LCBNb3pVc2VyRm9jdXMsIC1tb3otdXNlci1mb2N1cywgTW96VXNlcklucHV0LCAtbW96LXVzZXItaW5wdXQsIE1velVzZXJNb2RpZnksIC1tb3otdXNlci1tb2RpZnksIE1veldpbmRvd0RyYWdnaW5nLCAtbW96LXdpbmRvdy1kcmFnZ2luZywgb2JqZWN0Rml0LCBvYmplY3QtZml0LCBvZmZzZXRSb3RhdGUsIG9mZnNldC1yb3RhdGUsIG91dGxpbmVTdHlsZSwgb3V0bGluZS1zdHlsZSwgb3ZlcmZsb3dBbmNob3IsIG92ZXJmbG93LWFuY2hvciwgb3ZlcmZsb3dXcmFwLCBvdmVyZmxvdy13cmFwLCBwYWludE9yZGVyLCBwYWludC1vcmRlciwgcG9pbnRlckV2ZW50cywgcG9pbnRlci1ldmVudHMsIHBvc2l0aW9uLCBwcmludENvbG9yQWRqdXN0LCBwcmludC1jb2xvci1hZGp1c3QsIHJlc2l6ZSwgcnVieUFsaWduLCBydWJ5LWFsaWduLCBydWJ5UG9zaXRpb24sIHJ1YnktcG9zaXRpb24sIHNjcm9sbEJlaGF2aW9yLCBzY3JvbGwtYmVoYXZpb3IsIHNjcm9sbFNuYXBBbGlnbiwgc2Nyb2xsLXNuYXAtYWxpZ24sIHNjcm9sbFNuYXBTdG9wLCBzY3JvbGwtc25hcC1zdG9wLCBzY3JvbGxTbmFwVHlwZSwgc2Nyb2xsLXNuYXAtdHlwZSwgc2Nyb2xsYmFyR3V0dGVyLCBzY3JvbGxiYXItZ3V0dGVyLCBzY3JvbGxiYXJXaWR0aCwgc2Nyb2xsYmFyLXdpZHRoLCBzaGFwZVJlbmRlcmluZywgc2hhcGUtcmVuZGVyaW5nLCBzdHJva2VMaW5lY2FwLCBzdHJva2UtbGluZWNhcCwgc3Ryb2tlTGluZWpvaW4sIHN0cm9rZS1saW5lam9pbiwgdGFibGVMYXlvdXQsIHRhYmxlLWxheW91dCwgdGV4dEFsaWduLCB0ZXh0LWFsaWduLCB0ZXh0QWxpZ25MYXN0LCB0ZXh0LWFsaWduLWxhc3QsIHRleHRBbmNob3IsIHRleHQtYW5jaG9yLCB0ZXh0Q29tYmluZVVwcmlnaHQsIHRleHQtY29tYmluZS11cHJpZ2h0LCB0ZXh0RGVjb3JhdGlvbkxpbmUsIHRleHQtZGVjb3JhdGlvbi1saW5lLCB0ZXh0RGVjb3JhdGlvblNraXBJbmssIHRleHQtZGVjb3JhdGlvbi1za2lwLWluaywgdGV4dERlY29yYXRpb25TdHlsZSwgdGV4dC1kZWNvcmF0aW9uLXN0eWxlLCB0ZXh0RW1waGFzaXNQb3NpdGlvbiwgdGV4dC1lbXBoYXNpcy1wb3NpdGlvbiwgdGV4dEp1c3RpZnksIHRleHQtanVzdGlmeSwgdGV4dE9yaWVudGF0aW9uLCB0ZXh0LW9yaWVudGF0aW9uLCB0ZXh0UmVuZGVyaW5nLCB0ZXh0LXJlbmRlcmluZywgdGV4dFRyYW5zZm9ybSwgdGV4dC10cmFuc2Zvcm0sIHRleHRVbmRlcmxpbmVQb3NpdGlvbiwgdGV4dC11bmRlcmxpbmUtcG9zaXRpb24sIHRvdWNoQWN0aW9uLCB0b3VjaC1hY3Rpb24sIHRyYW5zZm9ybUJveCwgdHJhbnNmb3JtLWJveCwgdHJhbnNmb3JtU3R5bGUsIHRyYW5zZm9ybS1zdHlsZSwgdW5pY29kZUJpZGksIHVuaWNvZGUtYmlkaSwgdXNlclNlbGVjdCwgdXNlci1zZWxlY3QsIHZlY3RvckVmZmVjdCwgdmVjdG9yLWVmZmVjdCwgdmlzaWJpbGl0eSwgd2Via2l0TGluZUNsYW1wLCBXZWJraXRMaW5lQ2xhbXAsIC13ZWJraXQtbGluZS1jbGFtcCwgd2hpdGVTcGFjZSwgd2hpdGUtc3BhY2UsIHdvcmRCcmVhaywgd29yZC1icmVhaywgd3JpdGluZ01vZGUsIHdyaXRpbmctbW9kZSwgekluZGV4LCB6LWluZGV4LCBhcHBlYXJhbmNlLCBNb3pGb3JjZUJyb2tlbkltYWdlSWNvbiwgLW1vei1mb3JjZS1icm9rZW4taW1hZ2UtaWNvbiwgYnJlYWtBZnRlciwgYnJlYWstYWZ0ZXIsIGJyZWFrQmVmb3JlLCBicmVhay1iZWZvcmUsIGNsaXBSdWxlLCBjbGlwLXJ1bGUsIGZpbGxSdWxlLCBmaWxsLXJ1bGUsIGZpbGxPcGFjaXR5LCBmaWxsLW9wYWNpdHksIHN0cm9rZU9wYWNpdHksIHN0cm9rZS1vcGFjaXR5LCBNb3pCb3hPcmRpbmFsR3JvdXAsIC1tb3otYm94LW9yZGluYWwtZ3JvdXAsIG9yZGVyLCBmbGV4R3JvdywgZmxleC1ncm93LCBmbGV4U2hyaW5rLCBmbGV4LXNocmluaywgTW96Qm94RmxleCwgLW1vei1ib3gtZmxleCwgc3Ryb2tlTWl0ZXJsaW1pdCwgc3Ryb2tlLW1pdGVybGltaXQsIG92ZXJmbG93QmxvY2ssIG92ZXJmbG93LWJsb2NrLCBvdmVyZmxvd0lubGluZSwgb3ZlcmZsb3ctaW5saW5lLCBvdmVyZmxvd1gsIG92ZXJmbG93LXgsIG92ZXJmbG93WSwgb3ZlcmZsb3cteSwgb3ZlcnNjcm9sbEJlaGF2aW9yQmxvY2ssIG92ZXJzY3JvbGwtYmVoYXZpb3ItYmxvY2ssIG92ZXJzY3JvbGxCZWhhdmlvcklubGluZSwgb3ZlcnNjcm9sbC1iZWhhdmlvci1pbmxpbmUsIG92ZXJzY3JvbGxCZWhhdmlvclgsIG92ZXJzY3JvbGwtYmVoYXZpb3IteCwgb3ZlcnNjcm9sbEJlaGF2aW9yWSwgb3ZlcnNjcm9sbC1iZWhhdmlvci15LCBmbG9vZE9wYWNpdHksIGZsb29kLW9wYWNpdHksIG9wYWNpdHksIHNoYXBlSW1hZ2VUaHJlc2hvbGQsIHNoYXBlLWltYWdlLXRocmVzaG9sZCwgc3RvcE9wYWNpdHksIHN0b3Atb3BhY2l0eSwgYm9yZGVyQmxvY2tFbmRTdHlsZSwgYm9yZGVyLWJsb2NrLWVuZC1zdHlsZSwgYm9yZGVyQmxvY2tTdGFydFN0eWxlLCBib3JkZXItYmxvY2stc3RhcnQtc3R5bGUsIGJvcmRlckJvdHRvbVN0eWxlLCBib3JkZXItYm90dG9tLXN0eWxlLCBib3JkZXJJbmxpbmVFbmRTdHlsZSwgYm9yZGVyLWlubGluZS1lbmQtc3R5bGUsIGJvcmRlcklubGluZVN0YXJ0U3R5bGUsIGJvcmRlci1pbmxpbmUtc3RhcnQtc3R5bGUsIGJvcmRlckxlZnRTdHlsZSwgYm9yZGVyLWxlZnQtc3R5bGUsIGJvcmRlclJpZ2h0U3R5bGUsIGJvcmRlci1yaWdodC1zdHlsZSwgYm9yZGVyVG9wU3R5bGUsIGJvcmRlci10b3Atc3R5bGUsIGNvbHVtblJ1bGVTdHlsZSwgY29sdW1uLXJ1bGUtc3R5bGUsIGFjY2VudENvbG9yLCBhY2NlbnQtY29sb3IsIGFuaW1hdGlvbkRlbGF5LCBhbmltYXRpb24tZGVsYXksIGFuaW1hdGlvbkRpcmVjdGlvbiwgYW5pbWF0aW9uLWRpcmVjdGlvbiwgYW5pbWF0aW9uRHVyYXRpb24sIGFuaW1hdGlvbi1kdXJhdGlvbiwgYW5pbWF0aW9uRmlsbE1vZGUsIGFuaW1hdGlvbi1maWxsLW1vZGUsIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50LCBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50LCBhbmltYXRpb25OYW1lLCBhbmltYXRpb24tbmFtZSwgYW5pbWF0aW9uUGxheVN0YXRlLCBhbmltYXRpb24tcGxheS1zdGF0ZSwgYW5pbWF0aW9uVGltaW5nRnVuY3Rpb24sIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24sIGJhY2tkcm9wRmlsdGVyLCBiYWNrZHJvcC1maWx0ZXIsIGJhY2tncm91bmRBdHRhY2htZW50LCBiYWNrZ3JvdW5kLWF0dGFjaG1lbnQsIGJhY2tncm91bmRCbGVuZE1vZGUsIGJhY2tncm91bmQtYmxlbmQtbW9kZSwgYmFja2dyb3VuZENsaXAsIGJhY2tncm91bmQtY2xpcCwgYmFja2dyb3VuZEltYWdlLCBiYWNrZ3JvdW5kLWltYWdlLCBiYWNrZ3JvdW5kT3JpZ2luLCBiYWNrZ3JvdW5kLW9yaWdpbiwgYmFja2dyb3VuZFBvc2l0aW9uWCwgYmFja2dyb3VuZC1wb3NpdGlvbi14LCBiYWNrZ3JvdW5kUG9zaXRpb25ZLCBiYWNrZ3JvdW5kLXBvc2l0aW9uLXksIGJhY2tncm91bmRSZXBlYXQsIGJhY2tncm91bmQtcmVwZWF0LCBiYWNrZ3JvdW5kU2l6ZSwgYmFja2dyb3VuZC1zaXplLCBib3JkZXJJbWFnZU91dHNldCwgYm9yZGVyLWltYWdlLW91dHNldCwgYm9yZGVySW1hZ2VTbGljZSwgYm9yZGVyLWltYWdlLXNsaWNlLCBib3JkZXJJbWFnZVdpZHRoLCBib3JkZXItaW1hZ2Utd2lkdGgsIGJvcmRlclNwYWNpbmcsIGJvcmRlci1zcGFjaW5nLCBib3hTaGFkb3csIGJveC1zaGFkb3csIGNhcmV0Q29sb3IsIGNhcmV0LWNvbG9yLCBjbGlwUGF0aCwgY2xpcC1wYXRoLCBjb2xvciwgY29sb3JTY2hlbWUsIGNvbG9yLXNjaGVtZSwgY29sdW1uV2lkdGgsIGNvbHVtbi13aWR0aCwgY29udGVudCwgY291bnRlckluY3JlbWVudCwgY291bnRlci1pbmNyZW1lbnQsIGNvdW50ZXJSZXNldCwgY291bnRlci1yZXNldCwgY291bnRlclNldCwgY291bnRlci1zZXQsIGN1cnNvciwgZCwgZmlsdGVyLCBmbGV4QmFzaXMsIGZsZXgtYmFzaXMsIGZvbnRGYW1pbHksIGZvbnQtZmFtaWx5LCBmb250RmVhdHVyZVNldHRpbmdzLCBmb250LWZlYXR1cmUtc2V0dGluZ3MsIGZvbnRMYW5ndWFnZU92ZXJyaWRlLCBmb250LWxhbmd1YWdlLW92ZXJyaWRlLCBmb250UGFsZXR0ZSwgZm9udC1wYWxldHRlLCBmb250U2l6ZSwgZm9udC1zaXplLCBmb250VmFyaWFudEFsdGVybmF0ZXMsIGZvbnQtdmFyaWFudC1hbHRlcm5hdGVzLCBmb250VmFyaWF0aW9uU2V0dGluZ3MsIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzLCBncmlkVGVtcGxhdGVBcmVhcywgZ3JpZC10ZW1wbGF0ZS1hcmVhcywgaHlwaGVuYXRlQ2hhcmFjdGVyLCBoeXBoZW5hdGUtY2hhcmFjdGVyLCBsZXR0ZXJTcGFjaW5nLCBsZXR0ZXItc3BhY2luZywgbGluZUhlaWdodCwgbGluZS1oZWlnaHQsIGxpc3RTdHlsZVR5cGUsIGxpc3Qtc3R5bGUtdHlwZSwgbWFza0NsaXAsIG1hc2stY2xpcCwgbWFza0NvbXBvc2l0ZSwgbWFzay1jb21wb3NpdGUsIG1hc2tJbWFnZSwgbWFzay1pbWFnZSwgbWFza01vZGUsIG1hc2stbW9kZSwgbWFza09yaWdpbiwgbWFzay1vcmlnaW4sIG1hc2tQb3NpdGlvblgsIG1hc2stcG9zaXRpb24teCwgbWFza1Bvc2l0aW9uWSwgbWFzay1wb3NpdGlvbi15LCBtYXNrUmVwZWF0LCBtYXNrLXJlcGVhdCwgbWFza1NpemUsIG1hc2stc2l6ZSwgb2Zmc2V0QW5jaG9yLCBvZmZzZXQtYW5jaG9yLCBvZmZzZXRQYXRoLCBvZmZzZXQtcGF0aCwgcGVyc3BlY3RpdmUsIHF1b3Rlcywgcm90YXRlLCBzY2FsZSwgc2Nyb2xsYmFyQ29sb3IsIHNjcm9sbGJhci1jb2xvciwgc2hhcGVPdXRzaWRlLCBzaGFwZS1vdXRzaWRlLCBzdHJva2VEYXNoYXJyYXksIHN0cm9rZS1kYXNoYXJyYXksIHN0cm9rZURhc2hvZmZzZXQsIHN0cm9rZS1kYXNob2Zmc2V0LCBzdHJva2VXaWR0aCwgc3Ryb2tlLXdpZHRoLCB0YWJTaXplLCB0YWItc2l6ZSwgdGV4dERlY29yYXRpb25UaGlja25lc3MsIHRleHQtZGVjb3JhdGlvbi10aGlja25lc3MsIHRleHRFbXBoYXNpc1N0eWxlLCB0ZXh0LWVtcGhhc2lzLXN0eWxlLCB0ZXh0T3ZlcmZsb3csIHRleHQtb3ZlcmZsb3csIHRleHRTaGFkb3csIHRleHQtc2hhZG93LCB0cmFuc2l0aW9uRGVsYXksIHRyYW5zaXRpb24tZGVsYXksIHRyYW5zaXRpb25EdXJhdGlvbiwgdHJhbnNpdGlvbi1kdXJhdGlvbiwgdHJhbnNpdGlvblByb3BlcnR5LCB0cmFuc2l0aW9uLXByb3BlcnR5LCB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24sIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uLCB0cmFuc2xhdGUsIHZlcnRpY2FsQWxpZ24sIHZlcnRpY2FsLWFsaWduLCB3aWxsQ2hhbmdlLCB3aWxsLWNoYW5nZSwgd29yZFNwYWNpbmcsIHdvcmQtc3BhY2luZywgY2xpcCwgTW96SW1hZ2VSZWdpb24sIC1tb3otaW1hZ2UtcmVnaW9uLCBvYmplY3RQb3NpdGlvbiwgb2JqZWN0LXBvc2l0aW9uLCBwZXJzcGVjdGl2ZU9yaWdpbiwgcGVyc3BlY3RpdmUtb3JpZ2luLCBmaWxsLCBzdHJva2UsIHRyYW5zZm9ybU9yaWdpbiwgdHJhbnNmb3JtLW9yaWdpbiwgZ3JpZFRlbXBsYXRlQ29sdW1ucywgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zLCBncmlkVGVtcGxhdGVSb3dzLCBncmlkLXRlbXBsYXRlLXJvd3MsIGJvcmRlckltYWdlU291cmNlLCBib3JkZXItaW1hZ2Utc291cmNlLCBsaXN0U3R5bGVJbWFnZSwgbGlzdC1zdHlsZS1pbWFnZSwgZ3JpZEF1dG9Db2x1bW5zLCBncmlkLWF1dG8tY29sdW1ucywgZ3JpZEF1dG9Sb3dzLCBncmlkLWF1dG8tcm93cywgdHJhbnNmb3JtLCBjb2x1bW5HYXAsIGNvbHVtbi1nYXAsIHJvd0dhcCwgcm93LWdhcCwgbWFya2VyRW5kLCBtYXJrZXItZW5kLCBtYXJrZXJNaWQsIG1hcmtlci1taWQsIG1hcmtlclN0YXJ0LCBtYXJrZXItc3RhcnQsIGNvbnRhaW5JbnRyaW5zaWNCbG9ja1NpemUsIGNvbnRhaW4taW50cmluc2ljLWJsb2NrLXNpemUsIGNvbnRhaW5JbnRyaW5zaWNIZWlnaHQsIGNvbnRhaW4taW50cmluc2ljLWhlaWdodCwgY29udGFpbkludHJpbnNpY0lubGluZVNpemUsIGNvbnRhaW4taW50cmluc2ljLWlubGluZS1zaXplLCBjb250YWluSW50cmluc2ljV2lkdGgsIGNvbnRhaW4taW50cmluc2ljLXdpZHRoLCBncmlkQ29sdW1uRW5kLCBncmlkLWNvbHVtbi1lbmQsIGdyaWRDb2x1bW5TdGFydCwgZ3JpZC1jb2x1bW4tc3RhcnQsIGdyaWRSb3dFbmQsIGdyaWQtcm93LWVuZCwgZ3JpZFJvd1N0YXJ0LCBncmlkLXJvdy1zdGFydCwgbWF4QmxvY2tTaXplLCBtYXgtYmxvY2stc2l6ZSwgbWF4SGVpZ2h0LCBtYXgtaGVpZ2h0LCBtYXhJbmxpbmVTaXplLCBtYXgtaW5saW5lLXNpemUsIG1heFdpZHRoLCBtYXgtd2lkdGgsIGN4LCBjeSwgb2Zmc2V0RGlzdGFuY2UsIG9mZnNldC1kaXN0YW5jZSwgdGV4dEluZGVudCwgdGV4dC1pbmRlbnQsIHgsIHksIGJvcmRlckJvdHRvbUxlZnRSYWRpdXMsIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMsIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLCBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1cywgYm9yZGVyRW5kRW5kUmFkaXVzLCBib3JkZXItZW5kLWVuZC1yYWRpdXMsIGJvcmRlckVuZFN0YXJ0UmFkaXVzLCBib3JkZXItZW5kLXN0YXJ0LXJhZGl1cywgYm9yZGVyU3RhcnRFbmRSYWRpdXMsIGJvcmRlci1zdGFydC1lbmQtcmFkaXVzLCBib3JkZXJTdGFydFN0YXJ0UmFkaXVzLCBib3JkZXItc3RhcnQtc3RhcnQtcmFkaXVzLCBib3JkZXJUb3BMZWZ0UmFkaXVzLCBib3JkZXItdG9wLWxlZnQtcmFkaXVzLCBib3JkZXJUb3BSaWdodFJhZGl1cywgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMsIGJsb2NrU2l6ZSwgYmxvY2stc2l6ZSwgaGVpZ2h0LCBpbmxpbmVTaXplLCBpbmxpbmUtc2l6ZSwgbWluQmxvY2tTaXplLCBtaW4tYmxvY2stc2l6ZSwgbWluSGVpZ2h0LCBtaW4taGVpZ2h0LCBtaW5JbmxpbmVTaXplLCBtaW4taW5saW5lLXNpemUsIG1pbldpZHRoLCBtaW4td2lkdGgsIHdpZHRoLCBwYWRkaW5nQmxvY2tFbmQsIHBhZGRpbmctYmxvY2stZW5kLCBwYWRkaW5nQmxvY2tTdGFydCwgcGFkZGluZy1ibG9jay1zdGFydCwgcGFkZGluZ0JvdHRvbSwgcGFkZGluZy1ib3R0b20sIHBhZGRpbmdJbmxpbmVFbmQsIHBhZGRpbmctaW5saW5lLWVuZCwgcGFkZGluZ0lubGluZVN0YXJ0LCBwYWRkaW5nLWlubGluZS1zdGFydCwgcGFkZGluZ0xlZnQsIHBhZGRpbmctbGVmdCwgcGFkZGluZ1JpZ2h0LCBwYWRkaW5nLXJpZ2h0LCBwYWRkaW5nVG9wLCBwYWRkaW5nLXRvcCwgciwgc2hhcGVNYXJnaW4sIHNoYXBlLW1hcmdpbiwgcngsIHJ5LCBzY3JvbGxQYWRkaW5nQmxvY2tFbmQsIHNjcm9sbC1wYWRkaW5nLWJsb2NrLWVuZCwgc2Nyb2xsUGFkZGluZ0Jsb2NrU3RhcnQsIHNjcm9sbC1wYWRkaW5nLWJsb2NrLXN0YXJ0LCBzY3JvbGxQYWRkaW5nQm90dG9tLCBzY3JvbGwtcGFkZGluZy1ib3R0b20sIHNjcm9sbFBhZGRpbmdJbmxpbmVFbmQsIHNjcm9sbC1wYWRkaW5nLWlubGluZS1lbmQsIHNjcm9sbFBhZGRpbmdJbmxpbmVTdGFydCwgc2Nyb2xsLXBhZGRpbmctaW5saW5lLXN0YXJ0LCBzY3JvbGxQYWRkaW5nTGVmdCwgc2Nyb2xsLXBhZGRpbmctbGVmdCwgc2Nyb2xsUGFkZGluZ1JpZ2h0LCBzY3JvbGwtcGFkZGluZy1yaWdodCwgc2Nyb2xsUGFkZGluZ1RvcCwgc2Nyb2xsLXBhZGRpbmctdG9wLCBib3JkZXJCbG9ja0VuZFdpZHRoLCBib3JkZXItYmxvY2stZW5kLXdpZHRoLCBib3JkZXJCbG9ja1N0YXJ0V2lkdGgsIGJvcmRlci1ibG9jay1zdGFydC13aWR0aCwgYm9yZGVyQm90dG9tV2lkdGgsIGJvcmRlci1ib3R0b20td2lkdGgsIGJvcmRlcklubGluZUVuZFdpZHRoLCBib3JkZXItaW5saW5lLWVuZC13aWR0aCwgYm9yZGVySW5saW5lU3RhcnRXaWR0aCwgYm9yZGVyLWlubGluZS1zdGFydC13aWR0aCwgYm9yZGVyTGVmdFdpZHRoLCBib3JkZXItbGVmdC13aWR0aCwgYm9yZGVyUmlnaHRXaWR0aCwgYm9yZGVyLXJpZ2h0LXdpZHRoLCBib3JkZXJUb3BXaWR0aCwgYm9yZGVyLXRvcC13aWR0aCwgY29sdW1uUnVsZVdpZHRoLCBjb2x1bW4tcnVsZS13aWR0aCwgb3V0bGluZVdpZHRoLCBvdXRsaW5lLXdpZHRoLCB3ZWJraXRUZXh0U3Ryb2tlV2lkdGgsIFdlYmtpdFRleHRTdHJva2VXaWR0aCwgLXdlYmtpdC10ZXh0LXN0cm9rZS13aWR0aCwgb3V0bGluZU9mZnNldCwgb3V0bGluZS1vZmZzZXQsIG92ZXJmbG93Q2xpcE1hcmdpbiwgb3ZlcmZsb3ctY2xpcC1tYXJnaW4sIHNjcm9sbE1hcmdpbkJsb2NrRW5kLCBzY3JvbGwtbWFyZ2luLWJsb2NrLWVuZCwgc2Nyb2xsTWFyZ2luQmxvY2tTdGFydCwgc2Nyb2xsLW1hcmdpbi1ibG9jay1zdGFydCwgc2Nyb2xsTWFyZ2luQm90dG9tLCBzY3JvbGwtbWFyZ2luLWJvdHRvbSwgc2Nyb2xsTWFyZ2luSW5saW5lRW5kLCBzY3JvbGwtbWFyZ2luLWlubGluZS1lbmQsIHNjcm9sbE1hcmdpbklubGluZVN0YXJ0LCBzY3JvbGwtbWFyZ2luLWlubGluZS1zdGFydCwgc2Nyb2xsTWFyZ2luTGVmdCwgc2Nyb2xsLW1hcmdpbi1sZWZ0LCBzY3JvbGxNYXJnaW5SaWdodCwgc2Nyb2xsLW1hcmdpbi1yaWdodCwgc2Nyb2xsTWFyZ2luVG9wLCBzY3JvbGwtbWFyZ2luLXRvcCwgYm90dG9tLCBpbnNldEJsb2NrRW5kLCBpbnNldC1ibG9jay1lbmQsIGluc2V0QmxvY2tTdGFydCwgaW5zZXQtYmxvY2stc3RhcnQsIGluc2V0SW5saW5lRW5kLCBpbnNldC1pbmxpbmUtZW5kLCBpbnNldElubGluZVN0YXJ0LCBpbnNldC1pbmxpbmUtc3RhcnQsIGxlZnQsIG1hcmdpbkJsb2NrRW5kLCBtYXJnaW4tYmxvY2stZW5kLCBtYXJnaW5CbG9ja1N0YXJ0LCBtYXJnaW4tYmxvY2stc3RhcnQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luLWJvdHRvbSwgbWFyZ2luSW5saW5lRW5kLCBtYXJnaW4taW5saW5lLWVuZCwgbWFyZ2luSW5saW5lU3RhcnQsIG1hcmdpbi1pbmxpbmUtc3RhcnQsIG1hcmdpbkxlZnQsIG1hcmdpbi1sZWZ0LCBtYXJnaW5SaWdodCwgbWFyZ2luLXJpZ2h0LCBtYXJnaW5Ub3AsIG1hcmdpbi10b3AsIHJpZ2h0LCB0ZXh0VW5kZXJsaW5lT2Zmc2V0LCB0ZXh0LXVuZGVybGluZS1vZmZzZXQsIHRvcCwgYmFja2dyb3VuZENvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXJCbG9ja0VuZENvbG9yLCBib3JkZXItYmxvY2stZW5kLWNvbG9yLCBib3JkZXJCbG9ja1N0YXJ0Q29sb3IsIGJvcmRlci1ibG9jay1zdGFydC1jb2xvciwgYm9yZGVyQm90dG9tQ29sb3IsIGJvcmRlci1ib3R0b20tY29sb3IsIGJvcmRlcklubGluZUVuZENvbG9yLCBib3JkZXItaW5saW5lLWVuZC1jb2xvciwgYm9yZGVySW5saW5lU3RhcnRDb2xvciwgYm9yZGVyLWlubGluZS1zdGFydC1jb2xvciwgYm9yZGVyTGVmdENvbG9yLCBib3JkZXItbGVmdC1jb2xvciwgYm9yZGVyUmlnaHRDb2xvciwgYm9yZGVyLXJpZ2h0LWNvbG9yLCBib3JkZXJUb3BDb2xvciwgYm9yZGVyLXRvcC1jb2xvciwgY29sdW1uUnVsZUNvbG9yLCBjb2x1bW4tcnVsZS1jb2xvciwgZmxvb2RDb2xvciwgZmxvb2QtY29sb3IsIGxpZ2h0aW5nQ29sb3IsIGxpZ2h0aW5nLWNvbG9yLCBvdXRsaW5lQ29sb3IsIG91dGxpbmUtY29sb3IsIHN0b3BDb2xvciwgc3RvcC1jb2xvciwgdGV4dERlY29yYXRpb25Db2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCB0ZXh0RW1waGFzaXNDb2xvciwgdGV4dC1lbXBoYXNpcy1jb2xvciwgd2Via2l0VGV4dEZpbGxDb2xvciwgV2Via2l0VGV4dEZpbGxDb2xvciwgLXdlYmtpdC10ZXh0LWZpbGwtY29sb3IsIHdlYmtpdFRleHRTdHJva2VDb2xvciwgV2Via2l0VGV4dFN0cm9rZUNvbG9yLCAtd2Via2l0LXRleHQtc3Ryb2tlLWNvbG9yLCBiYWNrZ3JvdW5kLCBiYWNrZ3JvdW5kUG9zaXRpb24sIGJhY2tncm91bmQtcG9zaXRpb24sIGJvcmRlckNvbG9yLCBib3JkZXItY29sb3IsIGJvcmRlclN0eWxlLCBib3JkZXItc3R5bGUsIGJvcmRlcldpZHRoLCBib3JkZXItd2lkdGgsIGJvcmRlclRvcCwgYm9yZGVyLXRvcCwgYm9yZGVyUmlnaHQsIGJvcmRlci1yaWdodCwgYm9yZGVyQm90dG9tLCBib3JkZXItYm90dG9tLCBib3JkZXJMZWZ0LCBib3JkZXItbGVmdCwgYm9yZGVyQmxvY2tTdGFydCwgYm9yZGVyLWJsb2NrLXN0YXJ0LCBib3JkZXJCbG9ja0VuZCwgYm9yZGVyLWJsb2NrLWVuZCwgYm9yZGVySW5saW5lU3RhcnQsIGJvcmRlci1pbmxpbmUtc3RhcnQsIGJvcmRlcklubGluZUVuZCwgYm9yZGVyLWlubGluZS1lbmQsIGJvcmRlciwgYm9yZGVyUmFkaXVzLCBib3JkZXItcmFkaXVzLCBib3JkZXJJbWFnZSwgYm9yZGVyLWltYWdlLCBib3JkZXJCbG9ja1dpZHRoLCBib3JkZXItYmxvY2std2lkdGgsIGJvcmRlckJsb2NrU3R5bGUsIGJvcmRlci1ibG9jay1zdHlsZSwgYm9yZGVyQmxvY2tDb2xvciwgYm9yZGVyLWJsb2NrLWNvbG9yLCBib3JkZXJJbmxpbmVXaWR0aCwgYm9yZGVyLWlubGluZS13aWR0aCwgYm9yZGVySW5saW5lU3R5bGUsIGJvcmRlci1pbmxpbmUtc3R5bGUsIGJvcmRlcklubGluZUNvbG9yLCBib3JkZXItaW5saW5lLWNvbG9yLCBib3JkZXJCbG9jaywgYm9yZGVyLWJsb2NrLCBib3JkZXJJbmxpbmUsIGJvcmRlci1pbmxpbmUsIG92ZXJmbG93LCBvdmVyc2Nyb2xsQmVoYXZpb3IsIG92ZXJzY3JvbGwtYmVoYXZpb3IsIHBhZ2VCcmVha0JlZm9yZSwgcGFnZS1icmVhay1iZWZvcmUsIHBhZ2VCcmVha0FmdGVyLCBwYWdlLWJyZWFrLWFmdGVyLCBwYWdlQnJlYWtJbnNpZGUsIHBhZ2UtYnJlYWstaW5zaWRlLCBvZmZzZXQsIGNvbHVtbnMsIGNvbHVtblJ1bGUsIGNvbHVtbi1ydWxlLCBmb250LCBmb250VmFyaWFudCwgZm9udC12YXJpYW50LCBtYXJrZXIsIHRleHRFbXBoYXNpcywgdGV4dC1lbXBoYXNpcywgd2Via2l0VGV4dFN0cm9rZSwgV2Via2l0VGV4dFN0cm9rZSwgLXdlYmtpdC10ZXh0LXN0cm9rZSwgbGlzdFN0eWxlLCBsaXN0LXN0eWxlLCBtYXJnaW4sIG1hcmdpbkJsb2NrLCBtYXJnaW4tYmxvY2ssIG1hcmdpbklubGluZSwgbWFyZ2luLWlubGluZSwgc2Nyb2xsTWFyZ2luLCBzY3JvbGwtbWFyZ2luLCBzY3JvbGxNYXJnaW5CbG9jaywgc2Nyb2xsLW1hcmdpbi1ibG9jaywgc2Nyb2xsTWFyZ2luSW5saW5lLCBzY3JvbGwtbWFyZ2luLWlubGluZSwgb3V0bGluZSwgcGFkZGluZywgcGFkZGluZ0Jsb2NrLCBwYWRkaW5nLWJsb2NrLCBwYWRkaW5nSW5saW5lLCBwYWRkaW5nLWlubGluZSwgc2Nyb2xsUGFkZGluZywgc2Nyb2xsLXBhZGRpbmcsIHNjcm9sbFBhZGRpbmdCbG9jaywgc2Nyb2xsLXBhZGRpbmctYmxvY2ssIHNjcm9sbFBhZGRpbmdJbmxpbmUsIHNjcm9sbC1wYWRkaW5nLWlubGluZSwgZmxleEZsb3csIGZsZXgtZmxvdywgZmxleCwgZ2FwLCBncmlkUm93LCBncmlkLXJvdywgZ3JpZENvbHVtbiwgZ3JpZC1jb2x1bW4sIGdyaWRBcmVhLCBncmlkLWFyZWEsIGdyaWRUZW1wbGF0ZSwgZ3JpZC10ZW1wbGF0ZSwgZ3JpZCwgcGxhY2VDb250ZW50LCBwbGFjZS1jb250ZW50LCBwbGFjZVNlbGYsIHBsYWNlLXNlbGYsIHBsYWNlSXRlbXMsIHBsYWNlLWl0ZW1zLCBpbnNldCwgaW5zZXRCbG9jaywgaW5zZXQtYmxvY2ssIGluc2V0SW5saW5lLCBpbnNldC1pbmxpbmUsIGNvbnRhaW5JbnRyaW5zaWNTaXplLCBjb250YWluLWludHJpbnNpYy1zaXplLCBtYXNrLCBtYXNrUG9zaXRpb24sIG1hc2stcG9zaXRpb24sIHRleHREZWNvcmF0aW9uLCB0ZXh0LWRlY29yYXRpb24sIHRyYW5zaXRpb24sIGFuaW1hdGlvbiwgYWxsLCB3ZWJraXRCYWNrZ3JvdW5kQ2xpcCwgV2Via2l0QmFja2dyb3VuZENsaXAsIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwLCB3ZWJraXRCYWNrZ3JvdW5kT3JpZ2luLCBXZWJraXRCYWNrZ3JvdW5kT3JpZ2luLCAtd2Via2l0LWJhY2tncm91bmQtb3JpZ2luLCB3ZWJraXRCYWNrZ3JvdW5kU2l6ZSwgV2Via2l0QmFja2dyb3VuZFNpemUsIC13ZWJraXQtYmFja2dyb3VuZC1zaXplLCBNb3pCb3JkZXJTdGFydENvbG9yLCAtbW96LWJvcmRlci1zdGFydC1jb2xvciwgTW96Qm9yZGVyU3RhcnRTdHlsZSwgLW1vei1ib3JkZXItc3RhcnQtc3R5bGUsIE1vekJvcmRlclN0YXJ0V2lkdGgsIC1tb3otYm9yZGVyLXN0YXJ0LXdpZHRoLCBNb3pCb3JkZXJFbmRDb2xvciwgLW1vei1ib3JkZXItZW5kLWNvbG9yLCBNb3pCb3JkZXJFbmRTdHlsZSwgLW1vei1ib3JkZXItZW5kLXN0eWxlLCBNb3pCb3JkZXJFbmRXaWR0aCwgLW1vei1ib3JkZXItZW5kLXdpZHRoLCB3ZWJraXRCb3JkZXJUb3BMZWZ0UmFkaXVzLCBXZWJraXRCb3JkZXJUb3BMZWZ0UmFkaXVzLCAtd2Via2l0LWJvcmRlci10b3AtbGVmdC1yYWRpdXMsIHdlYmtpdEJvcmRlclRvcFJpZ2h0UmFkaXVzLCBXZWJraXRCb3JkZXJUb3BSaWdodFJhZGl1cywgLXdlYmtpdC1ib3JkZXItdG9wLXJpZ2h0LXJhZGl1cywgd2Via2l0Qm9yZGVyQm90dG9tUmlnaHRSYWRpdXMsIFdlYmtpdEJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzLCAtd2Via2l0LWJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzLCB3ZWJraXRCb3JkZXJCb3R0b21MZWZ0UmFkaXVzLCBXZWJraXRCb3JkZXJCb3R0b21MZWZ0UmFkaXVzLCAtd2Via2l0LWJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXMsIE1velRyYW5zZm9ybSwgLW1vei10cmFuc2Zvcm0sIHdlYmtpdFRyYW5zZm9ybSwgV2Via2l0VHJhbnNmb3JtLCAtd2Via2l0LXRyYW5zZm9ybSwgTW96UGVyc3BlY3RpdmUsIC1tb3otcGVyc3BlY3RpdmUsIHdlYmtpdFBlcnNwZWN0aXZlLCBXZWJraXRQZXJzcGVjdGl2ZSwgLXdlYmtpdC1wZXJzcGVjdGl2ZSwgTW96UGVyc3BlY3RpdmVPcmlnaW4sIC1tb3otcGVyc3BlY3RpdmUtb3JpZ2luLCB3ZWJraXRQZXJzcGVjdGl2ZU9yaWdpbiwgV2Via2l0UGVyc3BlY3RpdmVPcmlnaW4sIC13ZWJraXQtcGVyc3BlY3RpdmUtb3JpZ2luLCBNb3pCYWNrZmFjZVZpc2liaWxpdHksIC1tb3otYmFja2ZhY2UtdmlzaWJpbGl0eSwgd2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5LCBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHksIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eSwgTW96VHJhbnNmb3JtU3R5bGUsIC1tb3otdHJhbnNmb3JtLXN0eWxlLCB3ZWJraXRUcmFuc2Zvcm1TdHlsZSwgV2Via2l0VHJhbnNmb3JtU3R5bGUsIC13ZWJraXQtdHJhbnNmb3JtLXN0eWxlLCBNb3pUcmFuc2Zvcm1PcmlnaW4sIC1tb3otdHJhbnNmb3JtLW9yaWdpbiwgd2Via2l0VHJhbnNmb3JtT3JpZ2luLCBXZWJraXRUcmFuc2Zvcm1PcmlnaW4sIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbiwgTW96QXBwZWFyYW5jZSwgLW1vei1hcHBlYXJhbmNlLCB3ZWJraXRBcHBlYXJhbmNlLCBXZWJraXRBcHBlYXJhbmNlLCAtd2Via2l0LWFwcGVhcmFuY2UsIHdlYmtpdEJveFNoYWRvdywgV2Via2l0Qm94U2hhZG93LCAtd2Via2l0LWJveC1zaGFkb3csIHdlYmtpdEZpbHRlciwgV2Via2l0RmlsdGVyLCAtd2Via2l0LWZpbHRlciwgTW96Rm9udEZlYXR1cmVTZXR0aW5ncywgLW1vei1mb250LWZlYXR1cmUtc2V0dGluZ3MsIE1vekZvbnRMYW5ndWFnZU92ZXJyaWRlLCAtbW96LWZvbnQtbGFuZ3VhZ2Utb3ZlcnJpZGUsIGNvbG9yQWRqdXN0LCBjb2xvci1hZGp1c3QsIE1vekh5cGhlbnMsIC1tb3otaHlwaGVucywgd2Via2l0VGV4dFNpemVBZGp1c3QsIFdlYmtpdFRleHRTaXplQWRqdXN0LCAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3QsIHdvcmRXcmFwLCB3b3JkLXdyYXAsIE1velRhYlNpemUsIC1tb3otdGFiLXNpemUsIE1vek1hcmdpblN0YXJ0LCAtbW96LW1hcmdpbi1zdGFydCwgTW96TWFyZ2luRW5kLCAtbW96LW1hcmdpbi1lbmQsIE1velBhZGRpbmdTdGFydCwgLW1vei1wYWRkaW5nLXN0YXJ0LCBNb3pQYWRkaW5nRW5kLCAtbW96LXBhZGRpbmctZW5kLCB3ZWJraXRGbGV4RGlyZWN0aW9uLCBXZWJraXRGbGV4RGlyZWN0aW9uLCAtd2Via2l0LWZsZXgtZGlyZWN0aW9uLCB3ZWJraXRGbGV4V3JhcCwgV2Via2l0RmxleFdyYXAsIC13ZWJraXQtZmxleC13cmFwLCB3ZWJraXRKdXN0aWZ5Q29udGVudCwgV2Via2l0SnVzdGlmeUNvbnRlbnQsIC13ZWJraXQtanVzdGlmeS1jb250ZW50LCB3ZWJraXRBbGlnbkNvbnRlbnQsIFdlYmtpdEFsaWduQ29udGVudCwgLXdlYmtpdC1hbGlnbi1jb250ZW50LCB3ZWJraXRBbGlnbkl0ZW1zLCBXZWJraXRBbGlnbkl0ZW1zLCAtd2Via2l0LWFsaWduLWl0ZW1zLCB3ZWJraXRGbGV4R3JvdywgV2Via2l0RmxleEdyb3csIC13ZWJraXQtZmxleC1ncm93LCB3ZWJraXRGbGV4U2hyaW5rLCBXZWJraXRGbGV4U2hyaW5rLCAtd2Via2l0LWZsZXgtc2hyaW5rLCB3ZWJraXRBbGlnblNlbGYsIFdlYmtpdEFsaWduU2VsZiwgLXdlYmtpdC1hbGlnbi1zZWxmLCB3ZWJraXRPcmRlciwgV2Via2l0T3JkZXIsIC13ZWJraXQtb3JkZXIsIHdlYmtpdEZsZXhCYXNpcywgV2Via2l0RmxleEJhc2lzLCAtd2Via2l0LWZsZXgtYmFzaXMsIE1vekJveFNpemluZywgLW1vei1ib3gtc2l6aW5nLCB3ZWJraXRCb3hTaXppbmcsIFdlYmtpdEJveFNpemluZywgLXdlYmtpdC1ib3gtc2l6aW5nLCBncmlkQ29sdW1uR2FwLCBncmlkLWNvbHVtbi1nYXAsIGdyaWRSb3dHYXAsIGdyaWQtcm93LWdhcCwgd2Via2l0TWFza1JlcGVhdCwgV2Via2l0TWFza1JlcGVhdCwgLXdlYmtpdC1tYXNrLXJlcGVhdCwgd2Via2l0TWFza1Bvc2l0aW9uWCwgV2Via2l0TWFza1Bvc2l0aW9uWCwgLXdlYmtpdC1tYXNrLXBvc2l0aW9uLXgsIHdlYmtpdE1hc2tQb3NpdGlvblksIFdlYmtpdE1hc2tQb3NpdGlvblksIC13ZWJraXQtbWFzay1wb3NpdGlvbi15LCB3ZWJraXRNYXNrQ2xpcCwgV2Via2l0TWFza0NsaXAsIC13ZWJraXQtbWFzay1jbGlwLCB3ZWJraXRNYXNrT3JpZ2luLCBXZWJraXRNYXNrT3JpZ2luLCAtd2Via2l0LW1hc2stb3JpZ2luLCB3ZWJraXRNYXNrU2l6ZSwgV2Via2l0TWFza1NpemUsIC13ZWJraXQtbWFzay1zaXplLCB3ZWJraXRNYXNrQ29tcG9zaXRlLCBXZWJraXRNYXNrQ29tcG9zaXRlLCAtd2Via2l0LW1hc2stY29tcG9zaXRlLCB3ZWJraXRNYXNrSW1hZ2UsIFdlYmtpdE1hc2tJbWFnZSwgLXdlYmtpdC1tYXNrLWltYWdlLCBNb3pVc2VyU2VsZWN0LCAtbW96LXVzZXItc2VsZWN0LCB3ZWJraXRVc2VyU2VsZWN0LCBXZWJraXRVc2VyU2VsZWN0LCAtd2Via2l0LXVzZXItc2VsZWN0LCBNb3pUcmFuc2l0aW9uRHVyYXRpb24sIC1tb3otdHJhbnNpdGlvbi1kdXJhdGlvbiwgd2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uLCBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb24sIC13ZWJraXQtdHJhbnNpdGlvbi1kdXJhdGlvbiwgTW96VHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uLCAtbW96LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uLCB3ZWJraXRUcmFuc2l0aW9uVGltaW5nRnVuY3Rpb24sIFdlYmtpdFRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiwgLXdlYmtpdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiwgTW96VHJhbnNpdGlvblByb3BlcnR5LCAtbW96LXRyYW5zaXRpb24tcHJvcGVydHksIHdlYmtpdFRyYW5zaXRpb25Qcm9wZXJ0eSwgV2Via2l0VHJhbnNpdGlvblByb3BlcnR5LCAtd2Via2l0LXRyYW5zaXRpb24tcHJvcGVydHksIE1velRyYW5zaXRpb25EZWxheSwgLW1vei10cmFuc2l0aW9uLWRlbGF5LCB3ZWJraXRUcmFuc2l0aW9uRGVsYXksIFdlYmtpdFRyYW5zaXRpb25EZWxheSwgLXdlYmtpdC10cmFuc2l0aW9uLWRlbGF5LCBNb3pBbmltYXRpb25OYW1lLCAtbW96LWFuaW1hdGlvbi1uYW1lLCB3ZWJraXRBbmltYXRpb25OYW1lLCBXZWJraXRBbmltYXRpb25OYW1lLCAtd2Via2l0LWFuaW1hdGlvbi1uYW1lLCBNb3pBbmltYXRpb25EdXJhdGlvbiwgLW1vei1hbmltYXRpb24tZHVyYXRpb24sIHdlYmtpdEFuaW1hdGlvbkR1cmF0aW9uLCBXZWJraXRBbmltYXRpb25EdXJhdGlvbiwgLXdlYmtpdC1hbmltYXRpb24tZHVyYXRpb24sIE1vekFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uLCAtbW96LWFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24sIHdlYmtpdEFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uLCBXZWJraXRBbmltYXRpb25UaW1pbmdGdW5jdGlvbiwgLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uLCBNb3pBbmltYXRpb25JdGVyYXRpb25Db3VudCwgLW1vei1hbmltYXRpb24taXRlcmF0aW9uLWNvdW50LCB3ZWJraXRBbmltYXRpb25JdGVyYXRpb25Db3VudCwgV2Via2l0QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQsIC13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCwgTW96QW5pbWF0aW9uRGlyZWN0aW9uLCAtbW96LWFuaW1hdGlvbi1kaXJlY3Rpb24sIHdlYmtpdEFuaW1hdGlvbkRpcmVjdGlvbiwgV2Via2l0QW5pbWF0aW9uRGlyZWN0aW9uLCAtd2Via2l0LWFuaW1hdGlvbi1kaXJlY3Rpb24sIE1vekFuaW1hdGlvblBsYXlTdGF0ZSwgLW1vei1hbmltYXRpb24tcGxheS1zdGF0ZSwgd2Via2l0QW5pbWF0aW9uUGxheVN0YXRlLCBXZWJraXRBbmltYXRpb25QbGF5U3RhdGUsIC13ZWJraXQtYW5pbWF0aW9uLXBsYXktc3RhdGUsIE1vekFuaW1hdGlvbkZpbGxNb2RlLCAtbW96LWFuaW1hdGlvbi1maWxsLW1vZGUsIHdlYmtpdEFuaW1hdGlvbkZpbGxNb2RlLCBXZWJraXRBbmltYXRpb25GaWxsTW9kZSwgLXdlYmtpdC1hbmltYXRpb24tZmlsbC1tb2RlLCBNb3pBbmltYXRpb25EZWxheSwgLW1vei1hbmltYXRpb24tZGVsYXksIHdlYmtpdEFuaW1hdGlvbkRlbGF5LCBXZWJraXRBbmltYXRpb25EZWxheSwgLXdlYmtpdC1hbmltYXRpb24tZGVsYXksIHdlYmtpdEJveEFsaWduLCBXZWJraXRCb3hBbGlnbiwgLXdlYmtpdC1ib3gtYWxpZ24sIHdlYmtpdEJveERpcmVjdGlvbiwgV2Via2l0Qm94RGlyZWN0aW9uLCAtd2Via2l0LWJveC1kaXJlY3Rpb24sIHdlYmtpdEJveEZsZXgsIFdlYmtpdEJveEZsZXgsIC13ZWJraXQtYm94LWZsZXgsIHdlYmtpdEJveE9yaWVudCwgV2Via2l0Qm94T3JpZW50LCAtd2Via2l0LWJveC1vcmllbnQsIHdlYmtpdEJveFBhY2ssIFdlYmtpdEJveFBhY2ssIC13ZWJraXQtYm94LXBhY2ssIHdlYmtpdEJveE9yZGluYWxHcm91cCwgV2Via2l0Qm94T3JkaW5hbEdyb3VwLCAtd2Via2l0LWJveC1vcmRpbmFsLWdyb3VwLCBNb3pCb3JkZXJTdGFydCwgLW1vei1ib3JkZXItc3RhcnQsIE1vekJvcmRlckVuZCwgLW1vei1ib3JkZXItZW5kLCB3ZWJraXRCb3JkZXJSYWRpdXMsIFdlYmtpdEJvcmRlclJhZGl1cywgLXdlYmtpdC1ib3JkZXItcmFkaXVzLCBNb3pCb3JkZXJJbWFnZSwgLW1vei1ib3JkZXItaW1hZ2UsIHdlYmtpdEJvcmRlckltYWdlLCBXZWJraXRCb3JkZXJJbWFnZSwgLXdlYmtpdC1ib3JkZXItaW1hZ2UsIHdlYmtpdEZsZXhGbG93LCBXZWJraXRGbGV4RmxvdywgLXdlYmtpdC1mbGV4LWZsb3csIHdlYmtpdEZsZXgsIFdlYmtpdEZsZXgsIC13ZWJraXQtZmxleCwgZ3JpZEdhcCwgZ3JpZC1nYXAsIHdlYmtpdE1hc2ssIFdlYmtpdE1hc2ssIC13ZWJraXQtbWFzaywgd2Via2l0TWFza1Bvc2l0aW9uLCBXZWJraXRNYXNrUG9zaXRpb24sIC13ZWJraXQtbWFzay1wb3NpdGlvbiwgTW96VHJhbnNpdGlvbiwgLW1vei10cmFuc2l0aW9uLCB3ZWJraXRUcmFuc2l0aW9uLCBXZWJraXRUcmFuc2l0aW9uLCAtd2Via2l0LXRyYW5zaXRpb24sIE1vekFuaW1hdGlvbiwgLW1vei1hbmltYXRpb24sIHdlYmtpdEFuaW1hdGlvbiwgV2Via2l0QW5pbWF0aW9uLCAtd2Via2l0LWFuaW1hdGlvbiwgY29uc3RydWN0b3IiLGpzS2V5czoiT2JqZWN0LmFzc2lnbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3Quc2V0UHJvdG90eXBlT2YsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLCBPYmplY3Qua2V5cywgT2JqZWN0LnZhbHVlcywgT2JqZWN0LmVudHJpZXMsIE9iamVjdC5pcywgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcywgT2JqZWN0LmNyZWF0ZSwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIE9iamVjdC5pc0V4dGVuc2libGUsIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucywgT2JqZWN0LmZyZWV6ZSwgT2JqZWN0LmlzRnJvemVuLCBPYmplY3Quc2VhbCwgT2JqZWN0LmlzU2VhbGVkLCBPYmplY3QuZnJvbUVudHJpZXMsIE9iamVjdC5oYXNPd24sIE9iamVjdC50b1N0cmluZywgT2JqZWN0LnRvTG9jYWxlU3RyaW5nLCBPYmplY3QudmFsdWVPZiwgT2JqZWN0Lmhhc093blByb3BlcnR5LCBPYmplY3QuaXNQcm90b3R5cGVPZiwgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLCBPYmplY3QuX19kZWZpbmVHZXR0ZXJfXywgT2JqZWN0Ll9fZGVmaW5lU2V0dGVyX18sIE9iamVjdC5fX2xvb2t1cEdldHRlcl9fLCBPYmplY3QuX19sb29rdXBTZXR0ZXJfXywgT2JqZWN0Ll9fcHJvdG9fXywgRnVuY3Rpb24udG9TdHJpbmcsIEZ1bmN0aW9uLmFwcGx5LCBGdW5jdGlvbi5jYWxsLCBGdW5jdGlvbi5iaW5kLCBCb29sZWFuLnRvU3RyaW5nLCBCb29sZWFuLnZhbHVlT2YsIFN5bWJvbC5mb3IsIFN5bWJvbC5rZXlGb3IsIFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUsIFN5bWJvbC5pdGVyYXRvciwgU3ltYm9sLm1hdGNoLCBTeW1ib2wucmVwbGFjZSwgU3ltYm9sLnNlYXJjaCwgU3ltYm9sLnNwZWNpZXMsIFN5bWJvbC5oYXNJbnN0YW5jZSwgU3ltYm9sLnNwbGl0LCBTeW1ib2wudG9QcmltaXRpdmUsIFN5bWJvbC50b1N0cmluZ1RhZywgU3ltYm9sLnVuc2NvcGFibGVzLCBTeW1ib2wuYXN5bmNJdGVyYXRvciwgU3ltYm9sLm1hdGNoQWxsLCBTeW1ib2wudG9TdHJpbmcsIFN5bWJvbC52YWx1ZU9mLCBTeW1ib2wuZGVzY3JpcHRpb24sIEVycm9yLnRvU3RyaW5nLCBFcnJvci5tZXNzYWdlLCBFcnJvci5zdGFjaywgTnVtYmVyLmlzRmluaXRlLCBOdW1iZXIuaXNJbnRlZ2VyLCBOdW1iZXIuaXNOYU4sIE51bWJlci5pc1NhZmVJbnRlZ2VyLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1JTl9WQUxVRSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLCBOdW1iZXIuRVBTSUxPTiwgTnVtYmVyLnBhcnNlSW50LCBOdW1iZXIucGFyc2VGbG9hdCwgTnVtYmVyLk5hTiwgTnVtYmVyLnRvU3RyaW5nLCBOdW1iZXIudG9Mb2NhbGVTdHJpbmcsIE51bWJlci52YWx1ZU9mLCBOdW1iZXIudG9GaXhlZCwgTnVtYmVyLnRvRXhwb25lbnRpYWwsIE51bWJlci50b1ByZWNpc2lvbiwgQmlnSW50LmFzVWludE4sIEJpZ0ludC5hc0ludE4sIEJpZ0ludC52YWx1ZU9mLCBCaWdJbnQudG9TdHJpbmcsIEJpZ0ludC50b0xvY2FsZVN0cmluZywgTWF0aC5hYnMsIE1hdGguYWNvcywgTWF0aC5hc2luLCBNYXRoLmF0YW4sIE1hdGguYXRhbjIsIE1hdGguY2VpbCwgTWF0aC5jbHozMiwgTWF0aC5jb3MsIE1hdGguZXhwLCBNYXRoLmZsb29yLCBNYXRoLmltdWwsIE1hdGguZnJvdW5kLCBNYXRoLmxvZywgTWF0aC5tYXgsIE1hdGgubWluLCBNYXRoLnBvdywgTWF0aC5yYW5kb20sIE1hdGgucm91bmQsIE1hdGguc2luLCBNYXRoLnNxcnQsIE1hdGgudGFuLCBNYXRoLmxvZzEwLCBNYXRoLmxvZzIsIE1hdGgubG9nMXAsIE1hdGguZXhwbTEsIE1hdGguY29zaCwgTWF0aC5zaW5oLCBNYXRoLnRhbmgsIE1hdGguYWNvc2gsIE1hdGguYXNpbmgsIE1hdGguYXRhbmgsIE1hdGguaHlwb3QsIE1hdGgudHJ1bmMsIE1hdGguc2lnbiwgTWF0aC5jYnJ0LCBNYXRoLkUsIE1hdGguTE9HMkUsIE1hdGguTE9HMTBFLCBNYXRoLkxOMiwgTWF0aC5MTjEwLCBNYXRoLlBJLCBNYXRoLlNRUlQyLCBNYXRoLlNRUlQxXzIsIERhdGUuVVRDLCBEYXRlLnBhcnNlLCBEYXRlLm5vdywgRGF0ZS5nZXRUaW1lLCBEYXRlLmdldFRpbWV6b25lT2Zmc2V0LCBEYXRlLmdldFllYXIsIERhdGUuZ2V0RnVsbFllYXIsIERhdGUuZ2V0VVRDRnVsbFllYXIsIERhdGUuZ2V0TW9udGgsIERhdGUuZ2V0VVRDTW9udGgsIERhdGUuZ2V0RGF0ZSwgRGF0ZS5nZXRVVENEYXRlLCBEYXRlLmdldERheSwgRGF0ZS5nZXRVVENEYXksIERhdGUuZ2V0SG91cnMsIERhdGUuZ2V0VVRDSG91cnMsIERhdGUuZ2V0TWludXRlcywgRGF0ZS5nZXRVVENNaW51dGVzLCBEYXRlLmdldFNlY29uZHMsIERhdGUuZ2V0VVRDU2Vjb25kcywgRGF0ZS5nZXRNaWxsaXNlY29uZHMsIERhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzLCBEYXRlLnNldFRpbWUsIERhdGUuc2V0WWVhciwgRGF0ZS5zZXRGdWxsWWVhciwgRGF0ZS5zZXRVVENGdWxsWWVhciwgRGF0ZS5zZXRNb250aCwgRGF0ZS5zZXRVVENNb250aCwgRGF0ZS5zZXREYXRlLCBEYXRlLnNldFVUQ0RhdGUsIERhdGUuc2V0SG91cnMsIERhdGUuc2V0VVRDSG91cnMsIERhdGUuc2V0TWludXRlcywgRGF0ZS5zZXRVVENNaW51dGVzLCBEYXRlLnNldFNlY29uZHMsIERhdGUuc2V0VVRDU2Vjb25kcywgRGF0ZS5zZXRNaWxsaXNlY29uZHMsIERhdGUuc2V0VVRDTWlsbGlzZWNvbmRzLCBEYXRlLnRvVVRDU3RyaW5nLCBEYXRlLnRvTG9jYWxlU3RyaW5nLCBEYXRlLnRvTG9jYWxlRGF0ZVN0cmluZywgRGF0ZS50b0xvY2FsZVRpbWVTdHJpbmcsIERhdGUudG9EYXRlU3RyaW5nLCBEYXRlLnRvVGltZVN0cmluZywgRGF0ZS50b0lTT1N0cmluZywgRGF0ZS50b0pTT04sIERhdGUudG9TdHJpbmcsIERhdGUudmFsdWVPZiwgRGF0ZS50b0dNVFN0cmluZywgU3RyaW5nLmZyb21DaGFyQ29kZSwgU3RyaW5nLmZyb21Db2RlUG9pbnQsIFN0cmluZy5yYXcsIFN0cmluZy50b1N0cmluZywgU3RyaW5nLnZhbHVlT2YsIFN0cmluZy50b0xvd2VyQ2FzZSwgU3RyaW5nLnRvVXBwZXJDYXNlLCBTdHJpbmcuY2hhckF0LCBTdHJpbmcuY2hhckNvZGVBdCwgU3RyaW5nLnN1YnN0cmluZywgU3RyaW5nLnBhZFN0YXJ0LCBTdHJpbmcucGFkRW5kLCBTdHJpbmcuY29kZVBvaW50QXQsIFN0cmluZy5pbmNsdWRlcywgU3RyaW5nLmluZGV4T2YsIFN0cmluZy5sYXN0SW5kZXhPZiwgU3RyaW5nLnN0YXJ0c1dpdGgsIFN0cmluZy5lbmRzV2l0aCwgU3RyaW5nLnRyaW0sIFN0cmluZy50cmltU3RhcnQsIFN0cmluZy50cmltRW5kLCBTdHJpbmcudG9Mb2NhbGVMb3dlckNhc2UsIFN0cmluZy50b0xvY2FsZVVwcGVyQ2FzZSwgU3RyaW5nLmxvY2FsZUNvbXBhcmUsIFN0cmluZy5yZXBlYXQsIFN0cmluZy5ub3JtYWxpemUsIFN0cmluZy5tYXRjaCwgU3RyaW5nLm1hdGNoQWxsLCBTdHJpbmcuc2VhcmNoLCBTdHJpbmcucmVwbGFjZSwgU3RyaW5nLnJlcGxhY2VBbGwsIFN0cmluZy5zcGxpdCwgU3RyaW5nLnN1YnN0ciwgU3RyaW5nLmNvbmNhdCwgU3RyaW5nLnNsaWNlLCBTdHJpbmcuYXQsIFN0cmluZy5ib2xkLCBTdHJpbmcuaXRhbGljcywgU3RyaW5nLmZpeGVkLCBTdHJpbmcuc3RyaWtlLCBTdHJpbmcuc21hbGwsIFN0cmluZy5iaWcsIFN0cmluZy5ibGluaywgU3RyaW5nLnN1cCwgU3RyaW5nLnN1YiwgU3RyaW5nLmFuY2hvciwgU3RyaW5nLmxpbmssIFN0cmluZy5mb250Y29sb3IsIFN0cmluZy5mb250c2l6ZSwgU3RyaW5nLnRyaW1MZWZ0LCBTdHJpbmcudHJpbVJpZ2h0LCBSZWdFeHAuaW5wdXQsIFJlZ0V4cC5sYXN0TWF0Y2gsIFJlZ0V4cC5sYXN0UGFyZW4sIFJlZ0V4cC5sZWZ0Q29udGV4dCwgUmVnRXhwLnJpZ2h0Q29udGV4dCwgUmVnRXhwLiQxLCBSZWdFeHAuJDIsIFJlZ0V4cC4kMywgUmVnRXhwLiQ0LCBSZWdFeHAuJDUsIFJlZ0V4cC4kNiwgUmVnRXhwLiQ3LCBSZWdFeHAuJDgsIFJlZ0V4cC4kOSwgUmVnRXhwLiRfLCBSZWdFeHAuJCYsIFJlZ0V4cC4kKywgUmVnRXhwLiRgLCBSZWdFeHAuJCcsIFJlZ0V4cC50b1N0cmluZywgUmVnRXhwLmNvbXBpbGUsIFJlZ0V4cC5leGVjLCBSZWdFeHAudGVzdCwgUmVnRXhwLmZsYWdzLCBSZWdFeHAuaGFzSW5kaWNlcywgUmVnRXhwLmdsb2JhbCwgUmVnRXhwLmlnbm9yZUNhc2UsIFJlZ0V4cC5tdWx0aWxpbmUsIFJlZ0V4cC5kb3RBbGwsIFJlZ0V4cC5zb3VyY2UsIFJlZ0V4cC5zdGlja3ksIFJlZ0V4cC51bmljb2RlLCBBcnJheS5pc0FycmF5LCBBcnJheS5mcm9tLCBBcnJheS5vZiwgQXJyYXkudG9TdHJpbmcsIEFycmF5LnRvTG9jYWxlU3RyaW5nLCBBcnJheS5qb2luLCBBcnJheS5yZXZlcnNlLCBBcnJheS5zb3J0LCBBcnJheS5wdXNoLCBBcnJheS5wb3AsIEFycmF5LnNoaWZ0LCBBcnJheS51bnNoaWZ0LCBBcnJheS5zcGxpY2UsIEFycmF5LmNvbmNhdCwgQXJyYXkuc2xpY2UsIEFycmF5Lmxhc3RJbmRleE9mLCBBcnJheS5pbmRleE9mLCBBcnJheS5mb3JFYWNoLCBBcnJheS5tYXAsIEFycmF5LmZpbHRlciwgQXJyYXkucmVkdWNlLCBBcnJheS5yZWR1Y2VSaWdodCwgQXJyYXkuc29tZSwgQXJyYXkuZXZlcnksIEFycmF5LmZpbmQsIEFycmF5LmZpbmRJbmRleCwgQXJyYXkuY29weVdpdGhpbiwgQXJyYXkuZmlsbCwgQXJyYXkuZW50cmllcywgQXJyYXkua2V5cywgQXJyYXkudmFsdWVzLCBBcnJheS5pbmNsdWRlcywgQXJyYXkuZmxhdE1hcCwgQXJyYXkuZmxhdCwgQXJyYXkuYXQsIEFycmF5LmZpbmRMYXN0LCBBcnJheS5maW5kTGFzdEluZGV4LCBNYXAuZ2V0LCBNYXAuaGFzLCBNYXAuc2V0LCBNYXAuZGVsZXRlLCBNYXAua2V5cywgTWFwLnZhbHVlcywgTWFwLmNsZWFyLCBNYXAuZm9yRWFjaCwgTWFwLmVudHJpZXMsIE1hcC5zaXplLCBTZXQuaGFzLCBTZXQuYWRkLCBTZXQuZGVsZXRlLCBTZXQuZW50cmllcywgU2V0LmNsZWFyLCBTZXQuZm9yRWFjaCwgU2V0LnZhbHVlcywgU2V0LmtleXMsIFNldC5zaXplLCBXZWFrTWFwLmhhcywgV2Vha01hcC5nZXQsIFdlYWtNYXAuZGVsZXRlLCBXZWFrTWFwLnNldCwgV2Vha1NldC5hZGQsIFdlYWtTZXQuZGVsZXRlLCBXZWFrU2V0LmhhcywgQXRvbWljcy5jb21wYXJlRXhjaGFuZ2UsIEF0b21pY3MubG9hZCwgQXRvbWljcy5zdG9yZSwgQXRvbWljcy5leGNoYW5nZSwgQXRvbWljcy5hZGQsIEF0b21pY3Muc3ViLCBBdG9taWNzLmFuZCwgQXRvbWljcy5vciwgQXRvbWljcy54b3IsIEF0b21pY3MuaXNMb2NrRnJlZSwgQXRvbWljcy53YWl0LCBBdG9taWNzLm5vdGlmeSwgQXRvbWljcy53YWtlLCBKU09OLnBhcnNlLCBKU09OLnN0cmluZ2lmeSwgUHJvbWlzZS5hbGwsIFByb21pc2UuYWxsU2V0dGxlZCwgUHJvbWlzZS5hbnksIFByb21pc2UucmFjZSwgUHJvbWlzZS5yZWplY3QsIFByb21pc2UucmVzb2x2ZSwgUHJvbWlzZS50aGVuLCBQcm9taXNlLmNhdGNoLCBQcm9taXNlLmZpbmFsbHksIFJlZmxlY3QuYXBwbHksIFJlZmxlY3QuY29uc3RydWN0LCBSZWZsZWN0LmRlZmluZVByb3BlcnR5LCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5LCBSZWZsZWN0LmdldCwgUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YsIFJlZmxlY3QuaGFzLCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSwgUmVmbGVjdC5vd25LZXlzLCBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zLCBSZWZsZWN0LnNldCwgUmVmbGVjdC5zZXRQcm90b3R5cGVPZiwgUHJveHkucmV2b2NhYmxlLCBJbnRsLmdldENhbm9uaWNhbExvY2FsZXMsIEludGwuc3VwcG9ydGVkVmFsdWVzT2YsIEludGwuQ29sbGF0b3IsIEludGwuRGF0ZVRpbWVGb3JtYXQsIEludGwuRGlzcGxheU5hbWVzLCBJbnRsLkxpc3RGb3JtYXQsIEludGwuTG9jYWxlLCBJbnRsLk51bWJlckZvcm1hdCwgSW50bC5QbHVyYWxSdWxlcywgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQsIFdlYkFzc2VtYmx5LmNvbXBpbGUsIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlLCBXZWJBc3NlbWJseS52YWxpZGF0ZSwgV2ViQXNzZW1ibHkuY29tcGlsZVN0cmVhbWluZywgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcsIFdlYkFzc2VtYmx5Lk1vZHVsZSwgV2ViQXNzZW1ibHkuSW5zdGFuY2UsIFdlYkFzc2VtYmx5Lk1lbW9yeSwgV2ViQXNzZW1ibHkuVGFibGUsIFdlYkFzc2VtYmx5Lkdsb2JhbCwgV2ViQXNzZW1ibHkuQ29tcGlsZUVycm9yLCBXZWJBc3NlbWJseS5MaW5rRXJyb3IsIFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvciwgV2ViQXNzZW1ibHkuVGFnLCBXZWJBc3NlbWJseS5FeGNlcHRpb24sIERvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lLCBEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZU5TLCBEb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lLCBEb2N1bWVudC5nZXRFbGVtZW50QnlJZCwgRG9jdW1lbnQuY3JlYXRlRWxlbWVudCwgRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TLCBEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50LCBEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSwgRG9jdW1lbnQuY3JlYXRlQ29tbWVudCwgRG9jdW1lbnQuY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBEb2N1bWVudC5pbXBvcnROb2RlLCBEb2N1bWVudC5hZG9wdE5vZGUsIERvY3VtZW50LmNyZWF0ZUV2ZW50LCBEb2N1bWVudC5jcmVhdGVSYW5nZSwgRG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yLCBEb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyLCBEb2N1bWVudC5jcmVhdGVDREFUQVNlY3Rpb24sIERvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZSwgRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlTlMsIERvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lLCBEb2N1bWVudC5vcGVuLCBEb2N1bWVudC5jbG9zZSwgRG9jdW1lbnQud3JpdGUsIERvY3VtZW50LndyaXRlbG4sIERvY3VtZW50Lmhhc0ZvY3VzLCBEb2N1bWVudC5leGVjQ29tbWFuZCwgRG9jdW1lbnQucXVlcnlDb21tYW5kRW5hYmxlZCwgRG9jdW1lbnQucXVlcnlDb21tYW5kSW5kZXRlcm0sIERvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlLCBEb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQsIERvY3VtZW50LnF1ZXJ5Q29tbWFuZFZhbHVlLCBEb2N1bWVudC5yZWxlYXNlQ2FwdHVyZSwgRG9jdW1lbnQubW96U2V0SW1hZ2VFbGVtZW50LCBEb2N1bWVudC5jbGVhciwgRG9jdW1lbnQuY2FwdHVyZUV2ZW50cywgRG9jdW1lbnQucmVsZWFzZUV2ZW50cywgRG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4sIERvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4sIERvY3VtZW50LmV4aXRQb2ludGVyTG9jaywgRG9jdW1lbnQuZW5hYmxlU3R5bGVTaGVldHNGb3JTZXQsIERvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQsIERvY3VtZW50LnF1ZXJ5U2VsZWN0b3IsIERvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwsIERvY3VtZW50LmdldFNlbGVjdGlvbiwgRG9jdW1lbnQuaGFzU3RvcmFnZUFjY2VzcywgRG9jdW1lbnQucmVxdWVzdFN0b3JhZ2VBY2Nlc3MsIERvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQsIERvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50LCBEb2N1bWVudC5nZXRBbmltYXRpb25zLCBEb2N1bWVudC5wcmVwZW5kLCBEb2N1bWVudC5hcHBlbmQsIERvY3VtZW50LnJlcGxhY2VDaGlsZHJlbiwgRG9jdW1lbnQuY3JlYXRlRXhwcmVzc2lvbiwgRG9jdW1lbnQuY3JlYXRlTlNSZXNvbHZlciwgRG9jdW1lbnQuZXZhbHVhdGUsIERvY3VtZW50LmltcGxlbWVudGF0aW9uLCBEb2N1bWVudC5VUkwsIERvY3VtZW50LmRvY3VtZW50VVJJLCBEb2N1bWVudC5jb21wYXRNb2RlLCBEb2N1bWVudC5jaGFyYWN0ZXJTZXQsIERvY3VtZW50LmNoYXJzZXQsIERvY3VtZW50LmlucHV0RW5jb2RpbmcsIERvY3VtZW50LmNvbnRlbnRUeXBlLCBEb2N1bWVudC5kb2N0eXBlLCBEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIERvY3VtZW50LmRvbWFpbiwgRG9jdW1lbnQucmVmZXJyZXIsIERvY3VtZW50LmNvb2tpZSwgRG9jdW1lbnQubGFzdE1vZGlmaWVkLCBEb2N1bWVudC5yZWFkeVN0YXRlLCBEb2N1bWVudC50aXRsZSwgRG9jdW1lbnQuZGlyLCBEb2N1bWVudC5ib2R5LCBEb2N1bWVudC5oZWFkLCBEb2N1bWVudC5pbWFnZXMsIERvY3VtZW50LmVtYmVkcywgRG9jdW1lbnQucGx1Z2lucywgRG9jdW1lbnQubGlua3MsIERvY3VtZW50LmZvcm1zLCBEb2N1bWVudC5zY3JpcHRzLCBEb2N1bWVudC5kZWZhdWx0VmlldywgRG9jdW1lbnQuZGVzaWduTW9kZSwgRG9jdW1lbnQub25yZWFkeXN0YXRlY2hhbmdlLCBEb2N1bWVudC5vbmJlZm9yZXNjcmlwdGV4ZWN1dGUsIERvY3VtZW50Lm9uYWZ0ZXJzY3JpcHRleGVjdXRlLCBEb2N1bWVudC5jdXJyZW50U2NyaXB0LCBEb2N1bWVudC5mZ0NvbG9yLCBEb2N1bWVudC5saW5rQ29sb3IsIERvY3VtZW50LnZsaW5rQ29sb3IsIERvY3VtZW50LmFsaW5rQ29sb3IsIERvY3VtZW50LmJnQ29sb3IsIERvY3VtZW50LmFuY2hvcnMsIERvY3VtZW50LmFwcGxldHMsIERvY3VtZW50LmFsbCwgRG9jdW1lbnQuZnVsbHNjcmVlbiwgRG9jdW1lbnQubW96RnVsbFNjcmVlbiwgRG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQsIERvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbmFibGVkLCBEb2N1bWVudC5vbmZ1bGxzY3JlZW5jaGFuZ2UsIERvY3VtZW50Lm9uZnVsbHNjcmVlbmVycm9yLCBEb2N1bWVudC5vbnBvaW50ZXJsb2NrY2hhbmdlLCBEb2N1bWVudC5vbnBvaW50ZXJsb2NrZXJyb3IsIERvY3VtZW50LmhpZGRlbiwgRG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlLCBEb2N1bWVudC5vbnZpc2liaWxpdHljaGFuZ2UsIERvY3VtZW50LnNlbGVjdGVkU3R5bGVTaGVldFNldCwgRG9jdW1lbnQubGFzdFN0eWxlU2hlZXRTZXQsIERvY3VtZW50LnByZWZlcnJlZFN0eWxlU2hlZXRTZXQsIERvY3VtZW50LnN0eWxlU2hlZXRTZXRzLCBEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LCBEb2N1bWVudC50aW1lbGluZSwgRG9jdW1lbnQucm9vdEVsZW1lbnQsIERvY3VtZW50Lm9uY29weSwgRG9jdW1lbnQub25jdXQsIERvY3VtZW50Lm9ucGFzdGUsIERvY3VtZW50LmFjdGl2ZUVsZW1lbnQsIERvY3VtZW50LnN0eWxlU2hlZXRzLCBEb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQsIERvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50LCBEb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCwgRG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLCBEb2N1bWVudC5mb250cywgRG9jdW1lbnQub25hYm9ydCwgRG9jdW1lbnQub25ibHVyLCBEb2N1bWVudC5vbmZvY3VzLCBEb2N1bWVudC5vbmF1eGNsaWNrLCBEb2N1bWVudC5vbmJlZm9yZWlucHV0LCBEb2N1bWVudC5vbmNhbnBsYXksIERvY3VtZW50Lm9uY2FucGxheXRocm91Z2gsIERvY3VtZW50Lm9uY2hhbmdlLCBEb2N1bWVudC5vbmNsaWNrLCBEb2N1bWVudC5vbmNsb3NlLCBEb2N1bWVudC5vbmNvbnRleHRtZW51LCBEb2N1bWVudC5vbmN1ZWNoYW5nZSwgRG9jdW1lbnQub25kYmxjbGljaywgRG9jdW1lbnQub25kcmFnLCBEb2N1bWVudC5vbmRyYWdlbmQsIERvY3VtZW50Lm9uZHJhZ2VudGVyLCBEb2N1bWVudC5vbmRyYWdleGl0LCBEb2N1bWVudC5vbmRyYWdsZWF2ZSwgRG9jdW1lbnQub25kcmFnb3ZlciwgRG9jdW1lbnQub25kcmFnc3RhcnQsIERvY3VtZW50Lm9uZHJvcCwgRG9jdW1lbnQub25kdXJhdGlvbmNoYW5nZSwgRG9jdW1lbnQub25lbXB0aWVkLCBEb2N1bWVudC5vbmVuZGVkLCBEb2N1bWVudC5vbmZvcm1kYXRhLCBEb2N1bWVudC5vbmlucHV0LCBEb2N1bWVudC5vbmludmFsaWQsIERvY3VtZW50Lm9ua2V5ZG93biwgRG9jdW1lbnQub25rZXlwcmVzcywgRG9jdW1lbnQub25rZXl1cCwgRG9jdW1lbnQub25sb2FkLCBEb2N1bWVudC5vbmxvYWRlZGRhdGEsIERvY3VtZW50Lm9ubG9hZGVkbWV0YWRhdGEsIERvY3VtZW50Lm9ubG9hZHN0YXJ0LCBEb2N1bWVudC5vbm1vdXNlZG93biwgRG9jdW1lbnQub25tb3VzZWVudGVyLCBEb2N1bWVudC5vbm1vdXNlbGVhdmUsIERvY3VtZW50Lm9ubW91c2Vtb3ZlLCBEb2N1bWVudC5vbm1vdXNlb3V0LCBEb2N1bWVudC5vbm1vdXNlb3ZlciwgRG9jdW1lbnQub25tb3VzZXVwLCBEb2N1bWVudC5vbndoZWVsLCBEb2N1bWVudC5vbnBhdXNlLCBEb2N1bWVudC5vbnBsYXksIERvY3VtZW50Lm9ucGxheWluZywgRG9jdW1lbnQub25wcm9ncmVzcywgRG9jdW1lbnQub25yYXRlY2hhbmdlLCBEb2N1bWVudC5vbnJlc2V0LCBEb2N1bWVudC5vbnJlc2l6ZSwgRG9jdW1lbnQub25zY3JvbGwsIERvY3VtZW50Lm9uc2VjdXJpdHlwb2xpY3l2aW9sYXRpb24sIERvY3VtZW50Lm9uc2Vla2VkLCBEb2N1bWVudC5vbnNlZWtpbmcsIERvY3VtZW50Lm9uc2VsZWN0LCBEb2N1bWVudC5vbnNsb3RjaGFuZ2UsIERvY3VtZW50Lm9uc3RhbGxlZCwgRG9jdW1lbnQub25zdWJtaXQsIERvY3VtZW50Lm9uc3VzcGVuZCwgRG9jdW1lbnQub250aW1ldXBkYXRlLCBEb2N1bWVudC5vbnZvbHVtZWNoYW5nZSwgRG9jdW1lbnQub253YWl0aW5nLCBEb2N1bWVudC5vbnNlbGVjdHN0YXJ0LCBEb2N1bWVudC5vbnNlbGVjdGlvbmNoYW5nZSwgRG9jdW1lbnQub250b2dnbGUsIERvY3VtZW50Lm9ucG9pbnRlcmNhbmNlbCwgRG9jdW1lbnQub25wb2ludGVyZG93biwgRG9jdW1lbnQub25wb2ludGVydXAsIERvY3VtZW50Lm9ucG9pbnRlcm1vdmUsIERvY3VtZW50Lm9ucG9pbnRlcm91dCwgRG9jdW1lbnQub25wb2ludGVyb3ZlciwgRG9jdW1lbnQub25wb2ludGVyZW50ZXIsIERvY3VtZW50Lm9ucG9pbnRlcmxlYXZlLCBEb2N1bWVudC5vbmdvdHBvaW50ZXJjYXB0dXJlLCBEb2N1bWVudC5vbmxvc3Rwb2ludGVyY2FwdHVyZSwgRG9jdW1lbnQub25tb3pmdWxsc2NyZWVuY2hhbmdlLCBEb2N1bWVudC5vbm1vemZ1bGxzY3JlZW5lcnJvciwgRG9jdW1lbnQub25hbmltYXRpb25jYW5jZWwsIERvY3VtZW50Lm9uYW5pbWF0aW9uZW5kLCBEb2N1bWVudC5vbmFuaW1hdGlvbml0ZXJhdGlvbiwgRG9jdW1lbnQub25hbmltYXRpb25zdGFydCwgRG9jdW1lbnQub250cmFuc2l0aW9uY2FuY2VsLCBEb2N1bWVudC5vbnRyYW5zaXRpb25lbmQsIERvY3VtZW50Lm9udHJhbnNpdGlvbnJ1biwgRG9jdW1lbnQub250cmFuc2l0aW9uc3RhcnQsIERvY3VtZW50Lm9ud2Via2l0YW5pbWF0aW9uZW5kLCBEb2N1bWVudC5vbndlYmtpdGFuaW1hdGlvbml0ZXJhdGlvbiwgRG9jdW1lbnQub253ZWJraXRhbmltYXRpb25zdGFydCwgRG9jdW1lbnQub253ZWJraXR0cmFuc2l0aW9uZW5kLCBEb2N1bWVudC5vbmVycm9yLCBEb2N1bWVudC5jaGlsZHJlbiwgRG9jdW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQsIERvY3VtZW50Lmxhc3RFbGVtZW50Q2hpbGQsIERvY3VtZW50LmNoaWxkRWxlbWVudENvdW50LCBFbGVtZW50LmdldEF0dHJpYnV0ZU5hbWVzLCBFbGVtZW50LmdldEF0dHJpYnV0ZSwgRWxlbWVudC5nZXRBdHRyaWJ1dGVOUywgRWxlbWVudC50b2dnbGVBdHRyaWJ1dGUsIEVsZW1lbnQuc2V0QXR0cmlidXRlLCBFbGVtZW50LnNldEF0dHJpYnV0ZU5TLCBFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSwgRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGVOUywgRWxlbWVudC5oYXNBdHRyaWJ1dGUsIEVsZW1lbnQuaGFzQXR0cmlidXRlTlMsIEVsZW1lbnQuaGFzQXR0cmlidXRlcywgRWxlbWVudC5jbG9zZXN0LCBFbGVtZW50Lm1hdGNoZXMsIEVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yLCBFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lLCBFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lTlMsIEVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSwgRWxlbWVudC5pbnNlcnRBZGphY2VudEVsZW1lbnQsIEVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRUZXh0LCBFbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvciwgRWxlbWVudC5zZXRQb2ludGVyQ2FwdHVyZSwgRWxlbWVudC5yZWxlYXNlUG9pbnRlckNhcHR1cmUsIEVsZW1lbnQuaGFzUG9pbnRlckNhcHR1cmUsIEVsZW1lbnQuc2V0Q2FwdHVyZSwgRWxlbWVudC5yZWxlYXNlQ2FwdHVyZSwgRWxlbWVudC5nZXRBdHRyaWJ1dGVOb2RlLCBFbGVtZW50LnNldEF0dHJpYnV0ZU5vZGUsIEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlTm9kZSwgRWxlbWVudC5nZXRBdHRyaWJ1dGVOb2RlTlMsIEVsZW1lbnQuc2V0QXR0cmlidXRlTm9kZU5TLCBFbGVtZW50LmdldENsaWVudFJlY3RzLCBFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCwgRWxlbWVudC5jaGVja1Zpc2liaWxpdHksIEVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcsIEVsZW1lbnQuc2Nyb2xsLCBFbGVtZW50LnNjcm9sbFRvLCBFbGVtZW50LnNjcm9sbEJ5LCBFbGVtZW50Lmluc2VydEFkamFjZW50SFRNTCwgRWxlbWVudC5xdWVyeVNlbGVjdG9yLCBFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwsIEVsZW1lbnQuYXR0YWNoU2hhZG93LCBFbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuLCBFbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuLCBFbGVtZW50LnJlcXVlc3RQb2ludGVyTG9jaywgRWxlbWVudC5hbmltYXRlLCBFbGVtZW50LmdldEFuaW1hdGlvbnMsIEVsZW1lbnQuYmVmb3JlLCBFbGVtZW50LmFmdGVyLCBFbGVtZW50LnJlcGxhY2VXaXRoLCBFbGVtZW50LnJlbW92ZSwgRWxlbWVudC5wcmVwZW5kLCBFbGVtZW50LmFwcGVuZCwgRWxlbWVudC5yZXBsYWNlQ2hpbGRyZW4sIEVsZW1lbnQubmFtZXNwYWNlVVJJLCBFbGVtZW50LnByZWZpeCwgRWxlbWVudC5sb2NhbE5hbWUsIEVsZW1lbnQudGFnTmFtZSwgRWxlbWVudC5pZCwgRWxlbWVudC5jbGFzc05hbWUsIEVsZW1lbnQuY2xhc3NMaXN0LCBFbGVtZW50LnBhcnQsIEVsZW1lbnQuYXR0cmlidXRlcywgRWxlbWVudC5zY3JvbGxUb3AsIEVsZW1lbnQuc2Nyb2xsTGVmdCwgRWxlbWVudC5zY3JvbGxXaWR0aCwgRWxlbWVudC5zY3JvbGxIZWlnaHQsIEVsZW1lbnQuY2xpZW50VG9wLCBFbGVtZW50LmNsaWVudExlZnQsIEVsZW1lbnQuY2xpZW50V2lkdGgsIEVsZW1lbnQuY2xpZW50SGVpZ2h0LCBFbGVtZW50LnNjcm9sbFRvcE1heCwgRWxlbWVudC5zY3JvbGxMZWZ0TWF4LCBFbGVtZW50LmlubmVySFRNTCwgRWxlbWVudC5vdXRlckhUTUwsIEVsZW1lbnQuc2hhZG93Um9vdCwgRWxlbWVudC5hc3NpZ25lZFNsb3QsIEVsZW1lbnQuc2xvdCwgRWxlbWVudC5vbmZ1bGxzY3JlZW5jaGFuZ2UsIEVsZW1lbnQub25mdWxsc2NyZWVuZXJyb3IsIEVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZywgRWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcsIEVsZW1lbnQuY2hpbGRyZW4sIEVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQsIEVsZW1lbnQubGFzdEVsZW1lbnRDaGlsZCwgRWxlbWVudC5jaGlsZEVsZW1lbnRDb3VudCJ9fSx7dmVyc2lvbjpvfT1hW09lXXx8e307aWYoIShlJiZ0KSlyZXR1cm57fTtjb25zdFtyLGldPXQ/dC5zcGxpdCgiLSIpOltdLHM9aXx8cixjPStlPCtyLW4sbD0hKCtzPT1vJiYrZT5vKSYmKCtlPitzK258fGMpO3JldHVybntsaWVkVmVyc2lvbjpsLGRpc3RhbmNlOmw/TWF0aC5hYnMoZS0oYz9yOnMpKTowfX07YXN5bmMgZnVuY3Rpb24gRmUoe2Nzc0NvbXB1dGVkOmUsbmF2aWdhdG9yQ29tcHV0ZWQ6dCx3aW5kb3dGZWF0dXJlc0NvbXB1dGVkOm59KXt0cnl7Y29uc3QgYT13KCk7YXdhaXQgayhhKTtjb25zdCBvPVl8fHdpbmRvdztpZighZXx8IW4pcmV0dXJuIHZvaWQgRSh7dGVzdDoiZmVhdHVyZXMiLHBhc3NlZDohMX0pO2NvbnN0IHI9KGU9Pntjb25zdCB0PVsiT2JqZWN0IiwiRnVuY3Rpb24iLCJCb29sZWFuIiwiU3ltYm9sIiwiRXJyb3IiLCJOdW1iZXIiLCJCaWdJbnQiLCJNYXRoIiwiRGF0ZSIsIlN0cmluZyIsIlJlZ0V4cCIsIkFycmF5IiwiTWFwIiwiU2V0IiwiV2Vha01hcCIsIldlYWtTZXQiLCJBdG9taWNzIiwiSlNPTiIsIlByb21pc2UiLCJSZWZsZWN0IiwiUHJveHkiLCJJbnRsIiwiV2ViQXNzZW1ibHkiLCJEb2N1bWVudCIsIkVsZW1lbnQiXTt0cnl7cmV0dXJuIHQucmVkdWNlKCgodCxuKT0+e2NvbnN0IGE9WyJuYW1lIiwibGVuZ3RoIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJhcmd1bWVudHMiLCJjYWxsZXIiXSxvPU9iamVjdC5rZXlzKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGVbbl18fHt9KSkscj1PYmplY3Qua2V5cyhPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycygoZVtuXXx8e30pLnByb3RvdHlwZXx8e30pKTtyZXR1cm5bLi4udCwuLi5bLi4ubmV3IFNldChbLi4ubywuLi5yXS5maWx0ZXIoKGU9PiFhLmluY2x1ZGVzKGUpKSkpXS5tYXAoKGU9PmAke259LiR7ZX1gKSldfSksW10pfWNhdGNoKGUpe3JldHVybiBjb25zb2xlLmVycm9yKGUpLFtdfX0pKG8pLHtrZXlzOml9PWUuY29tcHV0ZWRTdHlsZXx8e30se2tleXM6c309bnx8e30se3VzZXJBZ2VudFBhcnNlZDpjfT10fHx7fSxsPShlLHQpPT4vXFtuYXRpdmUgY29kZVxdLy50ZXN0KGVbdF0rIiIpJiYicHJvdG90eXBlImluIGVbdF0mJmVbdF0ucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWU9PT10LGQ9KHtjb250ZXh0OmUsYWxsS2V5czp0LGVuZ2luZU1hcDpuLGNoZWNrTmF0aXZlOmE9ITF9PXt9KT0+e2NvbnN0IG89bmV3IFNldCh0KSxyPW5ldyBTZXQsaT1PYmplY3Qua2V5cyhufHx7fSkucmVkdWNlKCgodCxpKT0+e2NvbnN0IHM9bltpXTtyZXR1cm4gcy5sZW5ndGg9PXMuZmlsdGVyKCh0PT57aWYoIiEiPT10LmNoYXJBdCgwKSl7Y29uc3QgZT10LnNsaWNlKDEpO3JldHVybiFvLmhhcyhlKSYmci5hZGQodCl9cmV0dXJuIG8uaGFzKHQpJiYoIWF8fGwoZSx0KSkmJnIuYWRkKHQpfSkpLmxlbmd0aD9bLi4udCxpXTp0fSksW10pO3JldHVybnt2ZXJzaW9uOkJlKGkpWzBdLGZlYXR1cmVzOnJ9fSx7Y3NzOm0sd2luOnUsanM6Z309KGU9Pntjb25zdCB0PSJDaHJvbWUiPT1lLG49IkZpcmVmb3giPT1lO3JldHVybntjc3M6dD97NzY6WyJiYWNrZHJvcC1maWx0ZXIiXSwiNzctODAiOlsib3ZlcnNjcm9sbC1iZWhhdmlvci1ibG9jayIsIm92ZXJzY3JvbGwtYmVoYXZpb3ItaW5saW5lIl0sODE6WyJjb2xvci1zY2hlbWUiLCJpbWFnZS1vcmllbnRhdGlvbiJdLDgzOlsiY29udGFpbi1pbnRyaW5zaWMtc2l6ZSJdLDg0OlsiYXBwZWFyYW5jZSIsInJ1YnktcG9zaXRpb24iXSwiODUtODYiOlsiY29udGVudC12aXNpYmlsaXR5IiwiY291bnRlci1zZXQiLCJpbmhlcml0cyIsImluaXRpYWwtdmFsdWUiLCJwYWdlLW9yaWVudGF0aW9uIiwic3ludGF4Il0sODc6WyJhc2NlbnQtb3ZlcnJpZGUiLCJib3JkZXItYmxvY2siLCJib3JkZXItYmxvY2stY29sb3IiLCJib3JkZXItYmxvY2stc3R5bGUiLCJib3JkZXItYmxvY2std2lkdGgiLCJib3JkZXItaW5saW5lIiwiYm9yZGVyLWlubGluZS1jb2xvciIsImJvcmRlci1pbmxpbmUtc3R5bGUiLCJib3JkZXItaW5saW5lLXdpZHRoIiwiZGVzY2VudC1vdmVycmlkZSIsImluc2V0IiwiaW5zZXQtYmxvY2siLCJpbnNldC1ibG9jay1lbmQiLCJpbnNldC1ibG9jay1zdGFydCIsImluc2V0LWlubGluZSIsImluc2V0LWlubGluZS1lbmQiLCJpbnNldC1pbmxpbmUtc3RhcnQiLCJsaW5lLWdhcC1vdmVycmlkZSIsIm1hcmdpbi1ibG9jayIsIm1hcmdpbi1pbmxpbmUiLCJwYWRkaW5nLWJsb2NrIiwicGFkZGluZy1pbmxpbmUiLCJ0ZXh0LWRlY29yYXRpb24tdGhpY2tuZXNzIiwidGV4dC11bmRlcmxpbmUtb2Zmc2V0Il0sODg6WyJhc3BlY3QtcmF0aW8iXSw4OTpbImJvcmRlci1lbmQtZW5kLXJhZGl1cyIsImJvcmRlci1lbmQtc3RhcnQtcmFkaXVzIiwiYm9yZGVyLXN0YXJ0LWVuZC1yYWRpdXMiLCJib3JkZXItc3RhcnQtc3RhcnQtcmFkaXVzIiwiZm9yY2VkLWNvbG9yLWFkanVzdCJdLDkwOlsib3ZlcmZsb3ctY2xpcC1tYXJnaW4iXSw5MTpbImFkZGl0aXZlLXN5bWJvbHMiLCJmYWxsYmFjayIsIm5lZ2F0aXZlIiwicGFkIiwicHJlZml4IiwicmFuZ2UiLCJzcGVhay1hcyIsInN1ZmZpeCIsInN5bWJvbHMiLCJzeXN0ZW0iXSw5MjpbInNpemUtYWRqdXN0Il0sOTM6WyJhY2NlbnQtY29sb3IiXSw5NDpbInNjcm9sbGJhci1ndXR0ZXIiXSwiOTUtOTYiOlsiYXBwLXJlZ2lvbiIsImNvbnRhaW4taW50cmluc2ljLWJsb2NrLXNpemUiLCJjb250YWluLWludHJpbnNpYy1oZWlnaHQiLCJjb250YWluLWludHJpbnNpYy1pbmxpbmUtc2l6ZSIsImNvbnRhaW4taW50cmluc2ljLXdpZHRoIl0sIjk3LTk4IjpbImZvbnQtc3ludGhlc2lzLXNtYWxsLWNhcHMiLCJmb250LXN5bnRoZXNpcy1zdHlsZSIsImZvbnQtc3ludGhlc2lzLXdlaWdodCIsImZvbnQtc3ludGhlc2lzIl0sIjk5LTEwMCI6WyJ0ZXh0LWVtcGhhc2lzLWNvbG9yIiwidGV4dC1lbXBoYXNpcy1wb3NpdGlvbiIsInRleHQtZW1waGFzaXMtc3R5bGUiLCJ0ZXh0LWVtcGhhc2lzIl0sIjEwMS0xMDMiOlsiZm9udC1wYWxldHRlIiwiYmFzZS1wYWxldHRlIiwib3ZlcnJpZGUtY29sb3JzIl0sMTA0Olsib2JqZWN0LXZpZXctYm94Il0sMTA1OlsiY29udGFpbmVyLW5hbWUiLCJjb250YWluZXItdHlwZSIsImNvbnRhaW5lciJdLCIxMDYtMTA3IjpbImh5cGhlbmF0ZS1jaGFyYWN0ZXIiXSwxMDg6WyJoeXBoZW5hdGUtY2hhcmFjdGVyIiwiIW9yaWVudGF0aW9uIiwiIW1heC16b29tIiwiIW1pbi16b29tIiwiIXVzZXItem9vbSJdLDEwOTpbImh5cGhlbmF0ZS1saW1pdC1jaGFycyIsIm1hdGgtZGVwdGgiLCJtYXRoLXNoaWZ0IiwibWF0aC1zdHlsZSJdfTpuP3s3MTpbIi1tb3otY29sdW1uLXNwYW4iXSw3MjpbIm9mZnNldCIsIm9mZnNldC1hbmNob3IiLCJvZmZzZXQtZGlzdGFuY2UiLCJvZmZzZXQtcGF0aCIsIm9mZnNldC1yb3RhdGUiLCJyb3RhdGUiLCJzY2FsZSIsInRyYW5zbGF0ZSJdLDczOlsib3ZlcnNjcm9sbC1iZWhhdmlvci1ibG9jayIsIm92ZXJzY3JvbGwtYmVoYXZpb3ItaW5saW5lIl0sIjc0LTc5IjpbIiEtbW96LXN0YWNrLXNpemluZyIsInRleHQtdW5kZXJsaW5lLXBvc2l0aW9uIl0sIjgwLTg4IjpbImFwcGVhcmFuY2UiXSwiODktOTAiOlsiIS1tb3otb3V0bGluZS1yYWRpdXMiLCIhLW1vei1vdXRsaW5lLXJhZGl1cy1ib3R0b21sZWZ0IiwiIS1tb3otb3V0bGluZS1yYWRpdXMtYm90dG9tcmlnaHQiLCIhLW1vei1vdXRsaW5lLXJhZGl1cy10b3BsZWZ0IiwiIS1tb3otb3V0bGluZS1yYWRpdXMtdG9wcmlnaHQiLCJhc3BlY3QtcmF0aW8iXSw5MTpbInRhYi1zaXplIl0sIjkyLTk1IjpbImFjY2VudC1jb2xvciJdLDk2OlsiY29sb3Itc2NoZW1lIl0sOTc6WyJwcmludC1jb2xvci1hZGp1c3QiLCJzY3JvbGxiYXItZ3V0dGVyIiwiZCJdLCI5OC0xMDEiOlsiaHlwaGVuYXRlLWNoYXJhY3RlciJdLDEwMjpbIm92ZXJmbG93LWNsaXAtbWFyZ2luIl0sIjEwMy0xMDYiOlsic2Nyb2xsLXNuYXAtc3RvcCJdLCIxMDctMTA4IjpbImJhY2tkcm9wLWZpbHRlciIsImZvbnQtcGFsZXR0ZSIsImNvbnRhaW4taW50cmluc2ljLWJsb2NrLXNpemUiLCJjb250YWluLWludHJpbnNpYy1oZWlnaHQiLCJjb250YWluLWludHJpbnNpYy1pbmxpbmUtc2l6ZSIsImNvbnRhaW4taW50cmluc2ljLXdpZHRoIiwiY29udGFpbi1pbnRyaW5zaWMtc2l6ZSJdfTp7fSx3aW46dD97ODA6WyJDb21wcmVzc2lvblN0cmVhbSIsIkRlY29tcHJlc3Npb25TdHJlYW0iLCJGZWF0dXJlUG9saWN5IiwiRnJhZ21lbnREaXJlY3RpdmUiLCJQZXJpb2RpY1N5bmNNYW5hZ2VyIiwiVmlkZW9QbGF5YmFja1F1YWxpdHkiXSw4MTpbIlN1Ym1pdEV2ZW50IiwiWFJIaXRUZXN0UmVzdWx0IiwiWFJIaXRUZXN0U291cmNlIiwiWFJSYXkiLCJYUlRyYW5zaWVudElucHV0SGl0VGVzdFJlc3VsdCIsIlhSVHJhbnNpZW50SW5wdXRIaXRUZXN0U291cmNlIl0sODM6WyJCYXJjb2RlRGV0ZWN0b3IiLCJYUkRPTU92ZXJsYXlTdGF0ZSIsIlhSU3lzdGVtIl0sODQ6WyJBbmltYXRpb25QbGF5YmFja0V2ZW50IiwiQW5pbWF0aW9uVGltZWxpbmUiLCJDU1NBbmltYXRpb24iLCJDU1NUcmFuc2l0aW9uIiwiRG9jdW1lbnRUaW1lbGluZSIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiTGF5b3V0U2hpZnRBdHRyaWJ1dGlvbiIsIlJlc2l6ZU9ic2VydmVyU2l6ZSIsIldha2VMb2NrIiwiV2FrZUxvY2tTZW50aW5lbCIsIldlYWtSZWYiLCJYUkxheWVyIl0sODU6WyJBZ2dyZWdhdGVFcnJvciIsIkNTU1Byb3BlcnR5UnVsZSIsIkV2ZW50Q291bnRzIiwiWFJBbmNob3IiLCJYUkFuY2hvclNldCJdLDg2OlsiUlRDRW5jb2RlZEF1ZGlvRnJhbWUiLCJSVENFbmNvZGVkVmlkZW9GcmFtZSJdLDg3OlsiQ29va2llQ2hhbmdlRXZlbnQiLCJDb29raWVTdG9yZSIsIkNvb2tpZVN0b3JlTWFuYWdlciIsIlNjaGVkdWxpbmciXSw4ODpbIlNjaGVkdWxpbmciLCIhQmFyY29kZURldGVjdG9yIl0sODk6WyJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJYUldlYkdMQmluZGluZyJdLDkwOlsiQWJzdHJhY3RSYW5nZSIsIkN1c3RvbVN0YXRlU2V0IiwiTmF2aWdhdG9yVUFEYXRhIiwiWFJDUFVEZXB0aEluZm9ybWF0aW9uIiwiWFJEZXB0aEluZm9ybWF0aW9uIiwiWFJMaWdodEVzdGltYXRlIiwiWFJMaWdodFByb2JlIiwiWFJXZWJHTERlcHRoSW5mb3JtYXRpb24iXSw5MTpbIkNTU0NvdW50ZXJTdHlsZVJ1bGUiLCJHcmF2aXR5U2Vuc29yIiwiTmF2aWdhdG9yTWFuYWdlZERhdGEiXSw5MjpbIkNTU0NvdW50ZXJTdHlsZVJ1bGUiLCIhU2hhcmVkQXJyYXlCdWZmZXIiXSw5MzpbIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiXSw5NDpbIkF1ZGlvRGF0YSIsIkF1ZGlvRGVjb2RlciIsIkF1ZGlvRW5jb2RlciIsIkVuY29kZWRBdWRpb0NodW5rIiwiRW5jb2RlZFZpZGVvQ2h1bmsiLCJJZGxlRGV0ZWN0b3IiLCJJbWFnZURlY29kZXIiLCJJbWFnZVRyYWNrIiwiSW1hZ2VUcmFja0xpc3QiLCJWaWRlb0NvbG9yU3BhY2UiLCJWaWRlb0RlY29kZXIiLCJWaWRlb0VuY29kZXIiLCJWaWRlb0ZyYW1lIiwiTWVkaWFTdHJlYW1UcmFja0dlbmVyYXRvciIsIk1lZGlhU3RyZWFtVHJhY2tQcm9jZXNzb3IiLCJQcm9maWxlciIsIlZpcnR1YWxLZXlib2FyZCIsIkRlbGVnYXRlZElua1RyYWlsUHJlc2VudGVyIiwiSW5rIiwiU2NoZWR1bGVyIiwiVGFza0NvbnRyb2xsZXIiLCJUYXNrUHJpb3JpdHlDaGFuZ2VFdmVudCIsIlRhc2tTaWduYWwiLCJWaXJ0dWFsS2V5Ym9hcmRHZW9tZXRyeUNoYW5nZUV2ZW50Il0sIjk1LTk2IjpbIlVSTFBhdHRlcm4iXSwiOTctOTgiOlsiV2ViVHJhbnNwb3J0IiwiV2ViVHJhbnNwb3J0QmlkaXJlY3Rpb25hbFN0cmVhbSIsIldlYlRyYW5zcG9ydERhdGFncmFtRHVwbGV4U3RyZWFtIiwiV2ViVHJhbnNwb3J0RXJyb3IiXSw5OTpbIkNhbnZhc0ZpbHRlciIsIkNTU0xheWVyQmxvY2tSdWxlIiwiQ1NTTGF5ZXJTdGF0ZW1lbnRSdWxlIl0sMTAwOlsiQ1NTTWF0aENsYW1wIl0sIjEwMS0xMDQiOlsiQ1NTRm9udFBhbGV0dGVWYWx1ZXNSdWxlIl0sIjEwNS0xMDYiOlsiQ1NTQ29udGFpbmVyUnVsZSJdLCIxMDctMTA4IjpbIlhSQ2FtZXJhIl0sMTA5OlsiTWF0aE1MRWxlbWVudCJdfTpuP3s3MTpbIk1hdGhNTEVsZW1lbnQiLCIhU1ZHWm9vbUFuZFBhbiJdLCI3Mi03MyI6WyIhQmF0dGVyeU1hbmFnZXIiLCJGb3JtRGF0YUV2ZW50IiwiR2VvbG9jYXRpb24iLCJHZW9sb2NhdGlvbkNvb3JkaW5hdGVzIiwiR2VvbG9jYXRpb25Qb3NpdGlvbiIsIkdlb2xvY2F0aW9uUG9zaXRpb25FcnJvciIsIiFtb3pQYWludENvdW50Il0sNzQ6WyJGb3JtRGF0YUV2ZW50IiwiIXVuZXZhbCJdLDc1OlsiQW5pbWF0aW9uVGltZWxpbmUiLCJDU1NBbmltYXRpb24iLCJDU1NUcmFuc2l0aW9uIiwiRG9jdW1lbnRUaW1lbGluZSIsIlN1Ym1pdEV2ZW50Il0sIjc2LTc3IjpbIkF1ZGlvUGFyYW1NYXAiLCJBdWRpb1dvcmtsZXQiLCJBdWRpb1dvcmtsZXROb2RlIiwiV29ya2xldCJdLDc4OlsiQXRvbWljcyJdLCI3OS04MSI6WyJBZ2dyZWdhdGVFcnJvciIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5Il0sODI6WyJNZWRpYU1ldGFkYXRhIiwiTWVkaWFTZXNzaW9uIiwiU2FuaXRpemVyIl0sODM6WyJNZWRpYU1ldGFkYXRhIiwiTWVkaWFTZXNzaW9uIiwiIVNhbml0aXplciJdLDg0OlsiUGVyZm9ybWFuY2VQYWludFRpbWluZyJdLCI4NS04NiI6WyJQZXJmb3JtYW5jZVBhaW50VGltaW5nIiwiIUhUTUxNZW51SXRlbUVsZW1lbnQiLCIhb25zaG93Il0sODc6WyJvbmJlZm9yZWlucHV0Il0sODg6WyJvbmJlZm9yZWlucHV0IiwiIVZpc3VhbFZpZXdwb3J0Il0sIjg5LTkyIjpbIiFvbmRldmljZWxpZ2h0IiwiIW9uZGV2aWNlcHJveGltaXR5IiwiIW9udXNlcnByb3hpbWl0eSJdLCI5My05NSI6WyJFbGVtZW50SW50ZXJuYWxzIl0sOTY6WyJMb2NrIiwiTG9ja01hbmFnZXIiXSw5NzpbIkNTU0xheWVyQmxvY2tSdWxlIiwiQ1NTTGF5ZXJTdGF0ZW1lbnRSdWxlIl0sOTg6WyJIVE1MRGlhbG9nRWxlbWVudCJdLDk5OlsiTmF2aWdhdGlvblByZWxvYWRNYW5hZ2VyIl0sIjEwMC0xMDQiOlsiV3JpdGFibGVTdHJlYW0iXSwiMTA1LTEwNiI6WyJUZXh0RGVjb2RlclN0cmVhbSIsIk9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCIsIk9mZnNjcmVlbkNhbnZhcyIsIlRleHRFbmNvZGVyU3RyZWFtIl0sIjEwNy0xMDgiOlsiQ1NTRm9udFBhbGV0dGVWYWx1ZXNSdWxlIl19Ont9LGpzOnQ/ezc2OlsiRG9jdW1lbnQub25zZWN1cml0eXBvbGljeXZpb2xhdGlvbiIsIlByb21pc2UuYWxsU2V0dGxlZCJdLDc3OlsiRG9jdW1lbnQub25mb3JtZGF0YSIsIkRvY3VtZW50Lm9ucG9pbnRlcnJhd3VwZGF0ZSJdLDc4OlsiRWxlbWVudC5lbGVtZW50VGltaW5nIl0sNzk6WyJEb2N1bWVudC5vbmFuaW1hdGlvbmVuZCIsIkRvY3VtZW50Lm9uYW5pbWF0aW9uaXRlcmF0aW9uIiwiRG9jdW1lbnQub25hbmltYXRpb25zdGFydCIsIkRvY3VtZW50Lm9udHJhbnNpdGlvbmVuZCJdLDgwOlsiIURvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCIsIiFFbGVtZW50LmNyZWF0ZVNoYWRvd1Jvb3QiLCIhRWxlbWVudC5nZXREZXN0aW5hdGlvbkluc2VydGlvblBvaW50cyJdLDgxOlsiRG9jdW1lbnQub253ZWJraXRhbmltYXRpb25lbmQiLCJEb2N1bWVudC5vbndlYmtpdGFuaW1hdGlvbml0ZXJhdGlvbiIsIkRvY3VtZW50Lm9ud2Via2l0YW5pbWF0aW9uc3RhcnQiLCJEb2N1bWVudC5vbndlYmtpdHRyYW5zaXRpb25lbmQiLCJFbGVtZW50LmFyaWFBdG9taWMiLCJFbGVtZW50LmFyaWFBdXRvQ29tcGxldGUiLCJFbGVtZW50LmFyaWFCdXN5IiwiRWxlbWVudC5hcmlhQ2hlY2tlZCIsIkVsZW1lbnQuYXJpYUNvbENvdW50IiwiRWxlbWVudC5hcmlhQ29sSW5kZXgiLCJFbGVtZW50LmFyaWFDb2xTcGFuIiwiRWxlbWVudC5hcmlhQ3VycmVudCIsIkVsZW1lbnQuYXJpYURpc2FibGVkIiwiRWxlbWVudC5hcmlhRXhwYW5kZWQiLCJFbGVtZW50LmFyaWFIYXNQb3B1cCIsIkVsZW1lbnQuYXJpYUhpZGRlbiIsIkVsZW1lbnQuYXJpYUtleVNob3J0Y3V0cyIsIkVsZW1lbnQuYXJpYUxhYmVsIiwiRWxlbWVudC5hcmlhTGV2ZWwiLCJFbGVtZW50LmFyaWFMaXZlIiwiRWxlbWVudC5hcmlhTW9kYWwiLCJFbGVtZW50LmFyaWFNdWx0aUxpbmUiLCJFbGVtZW50LmFyaWFNdWx0aVNlbGVjdGFibGUiLCJFbGVtZW50LmFyaWFPcmllbnRhdGlvbiIsIkVsZW1lbnQuYXJpYVBsYWNlaG9sZGVyIiwiRWxlbWVudC5hcmlhUG9zSW5TZXQiLCJFbGVtZW50LmFyaWFQcmVzc2VkIiwiRWxlbWVudC5hcmlhUmVhZE9ubHkiLCJFbGVtZW50LmFyaWFSZWxldmFudCIsIkVsZW1lbnQuYXJpYVJlcXVpcmVkIiwiRWxlbWVudC5hcmlhUm9sZURlc2NyaXB0aW9uIiwiRWxlbWVudC5hcmlhUm93Q291bnQiLCJFbGVtZW50LmFyaWFSb3dJbmRleCIsIkVsZW1lbnQuYXJpYVJvd1NwYW4iLCJFbGVtZW50LmFyaWFTZWxlY3RlZCIsIkVsZW1lbnQuYXJpYVNvcnQiLCJFbGVtZW50LmFyaWFWYWx1ZU1heCIsIkVsZW1lbnQuYXJpYVZhbHVlTWluIiwiRWxlbWVudC5hcmlhVmFsdWVOb3ciLCJFbGVtZW50LmFyaWFWYWx1ZVRleHQiLCJJbnRsLkRpc3BsYXlOYW1lcyJdLDgzOlsiRWxlbWVudC5hcmlhRGVzY3JpcHRpb24iLCJFbGVtZW50Lm9uYmVmb3JleHJzZWxlY3QiXSw4NDpbIkRvY3VtZW50LmdldEFuaW1hdGlvbnMiLCJEb2N1bWVudC50aW1lbGluZSIsIkVsZW1lbnQuYXJpYVNldFNpemUiLCJFbGVtZW50LmdldEFuaW1hdGlvbnMiXSw4NTpbIlByb21pc2UuYW55IiwiU3RyaW5nLnJlcGxhY2VBbGwiXSw4NjpbIkRvY3VtZW50LmZyYWdtZW50RGlyZWN0aXZlIiwiRG9jdW1lbnQucmVwbGFjZUNoaWxkcmVuIiwiRWxlbWVudC5yZXBsYWNlQ2hpbGRyZW4iLCIhQXRvbWljcy53YWtlIl0sIjg3LTg5IjpbIkF0b21pY3Mud2FpdEFzeW5jIiwiRG9jdW1lbnQub250cmFuc2l0aW9uY2FuY2VsIiwiRG9jdW1lbnQub250cmFuc2l0aW9ucnVuIiwiRG9jdW1lbnQub250cmFuc2l0aW9uc3RhcnQiLCJJbnRsLlNlZ21lbnRlciJdLDkwOlsiRG9jdW1lbnQub25iZWZvcmV4cnNlbGVjdCIsIlJlZ0V4cC5oYXNJbmRpY2VzIiwiIUVsZW1lbnQub25iZWZvcmV4cnNlbGVjdCJdLDkxOlsiRWxlbWVudC5nZXRJbm5lckhUTUwiXSw5MjpbIkFycmF5LmF0IiwiU3RyaW5nLmF0Il0sOTM6WyJFcnJvci5jYXVzZSIsIk9iamVjdC5oYXNPd24iXSw5NDpbIiFFcnJvci5jYXVzZSIsIk9iamVjdC5oYXNPd24iXSwiOTUtOTYiOlsiV2ViQXNzZW1ibHkuRXhjZXB0aW9uIiwiV2ViQXNzZW1ibHkuVGFnIl0sIjk3LTk4IjpbIkFycmF5LmZpbmRMYXN0IiwiQXJyYXkuZmluZExhc3RJbmRleCIsIkRvY3VtZW50Lm9uc2xvdGNoYW5nZSJdLCI5OS0xMDEiOlsiSW50bC5zdXBwb3J0ZWRWYWx1ZXNPZiIsIkRvY3VtZW50Lm9uY29udGV4dGxvc3QiLCJEb2N1bWVudC5vbmNvbnRleHRyZXN0b3JlZCJdLDEwMjpbIkVsZW1lbnQuYXJpYUludmFsaWQiLCJEb2N1bWVudC5vbmJlZm9yZW1hdGNoIl0sIjEwMy0xMDYiOlsiRWxlbWVudC5yb2xlIl0sIjEwNy0xMDkiOlsiRWxlbWVudC5hcmlhQnJhaWxsZUxhYmVsIiwiRWxlbWVudC5hcmlhQnJhaWxsZVJvbGVEZXNjcmlwdGlvbiJdfTpuP3s3MTpbIlByb21pc2UuYWxsU2V0dGxlZCJdLCI3Mi03MyI6WyJEb2N1bWVudC5vbmZvcm1kYXRhIiwiRWxlbWVudC5wYXJ0Il0sNzQ6WyIhQXJyYXkudG9Tb3VyY2UiLCIhQm9vbGVhbi50b1NvdXJjZSIsIiFEYXRlLnRvU291cmNlIiwiIUVycm9yLnRvU291cmNlIiwiIUZ1bmN0aW9uLnRvU291cmNlIiwiIUludGwudG9Tb3VyY2UiLCIhSlNPTi50b1NvdXJjZSIsIiFNYXRoLnRvU291cmNlIiwiIU51bWJlci50b1NvdXJjZSIsIiFPYmplY3QudG9Tb3VyY2UiLCIhUmVnRXhwLnRvU291cmNlIiwiIVN0cmluZy50b1NvdXJjZSIsIiFXZWJBc3NlbWJseS50b1NvdXJjZSJdLCI3NS03NiI6WyJEb2N1bWVudC5nZXRBbmltYXRpb25zIiwiRG9jdW1lbnQudGltZWxpbmUiLCJFbGVtZW50LmdldEFuaW1hdGlvbnMiLCJJbnRsLkxvY2FsZSJdLDc3OlsiU3RyaW5nLnJlcGxhY2VBbGwiXSw3ODpbIkF0b21pY3MuYWRkIiwiQXRvbWljcy5hbmQiLCJBdG9taWNzLmNvbXBhcmVFeGNoYW5nZSIsIkF0b21pY3MuZXhjaGFuZ2UiLCJBdG9taWNzLmlzTG9ja0ZyZWUiLCJBdG9taWNzLmxvYWQiLCJBdG9taWNzLm5vdGlmeSIsIkF0b21pY3Mub3IiLCJBdG9taWNzLnN0b3JlIiwiQXRvbWljcy5zdWIiLCJBdG9taWNzLndhaXQiLCJBdG9taWNzLndha2UiLCJBdG9taWNzLnhvciIsIkRvY3VtZW50LnJlcGxhY2VDaGlsZHJlbiIsIkVsZW1lbnQucmVwbGFjZUNoaWxkcmVuIiwiSW50bC5MaXN0Rm9ybWF0IiwiUmVnRXhwLmRvdEFsbCJdLCI3OS04NCI6WyJQcm9taXNlLmFueSJdLDg1OlsiIURvY3VtZW50Lm9uc2hvdyIsIlByb21pc2UuYW55Il0sODY6WyJJbnRsLkRpc3BsYXlOYW1lcyJdLDg3OlsiRG9jdW1lbnQub25iZWZvcmVpbnB1dCJdLCI4OC04OSI6WyJSZWdFeHAuaGFzSW5kaWNlcyJdLCI5MC05MSI6WyJBcnJheS5hdCIsIlN0cmluZy5hdCJdLDkyOlsiT2JqZWN0Lmhhc093biJdLCI5My05OSI6WyJJbnRsLnN1cHBvcnRlZFZhbHVlc09mIiwiRG9jdW1lbnQub25zZWN1cml0eXBvbGljeXZpb2xhdGlvbiIsIkRvY3VtZW50Lm9uc2xvdGNoYW5nZSJdLDEwMDpbIldlYkFzc2VtYmx5LlRhZyIsIldlYkFzc2VtYmx5LkV4Y2VwdGlvbiJdLCIxMDEtMTAzIjpbIkRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cyJdLCIxMDQtMTA4IjpbIkFycmF5LmZpbmRMYXN0IiwiQXJyYXkuZmluZExhc3RJbmRleCJdfTp7fX19KShPZSkse3ZlcnNpb246cCxmZWF0dXJlczpofT1kKHtjb250ZXh0Om8sYWxsS2V5czppLGVuZ2luZU1hcDptfSkse3ZlcnNpb246YixmZWF0dXJlczpmfT1kKHtjb250ZXh0Om8sYWxsS2V5czpzLGVuZ2luZU1hcDp1LGNoZWNrTmF0aXZlOiEwfSkse3ZlcnNpb246UyxmZWF0dXJlczp5fT1kKHtjb250ZXh0Om8sYWxsS2V5czpyLGVuZ2luZU1hcDpnfSksdj0oZSx0KT0+e2NvbnN0IG49dC5maW5kKChlPT5lJiYhLy0vLnRlc3QoZSkpKTtpZihuKXJldHVybiBuO2NvbnN0IGE9ZS5sZW5ndGgsbz1lWzBdLHI9ZVthLTFdO3JldHVybiBhPzE9PWE/bzpgJHtyfS0ke299YDoiIn0sQT1uZXcgU2V0KFtwLGIsU10pO0EuZGVsZXRlKHZvaWQgMCk7Y29uc3QgRD1CZShbLi4uQV0ucmVkdWNlKCgoZSx0KT0+Wy4uLmUsLi4udC5zcGxpdCgiLSIpXSksW10pKSxNPXYoRCxbcCxiLFNdKSxDPSgvXGQrLy5leGVjKGMpfHxbXSlbMF0se2xpZWRWZXJzaW9uOlQsZGlzdGFuY2U6eH09SGUoQyxwKSx7bGllZFZlcnNpb246UixkaXN0YW5jZTpOfT1IZShDLFMpLHtsaWVkVmVyc2lvbjpJLGRpc3RhbmNlOkx9PUhlKEMsYik7cmV0dXJuIFQmJihtZSgidXNlckFnZW50IixgdiR7Q30gZmFpbGVkIHYke3B9IENTUyBmZWF0dXJlc2ApLHg+MSYmTygiTmF2aWdhdG9yLnVzZXJBZ2VudCIsYHYke0N9IGZhaWxlZCBDU1MgZmVhdHVyZXMgYnkgJHt4fSB2ZXJzaW9uc2ApKSxSJiYobWUoInVzZXJBZ2VudCIsYHYke0N9IGZhaWxlZCB2JHtTfSBKUyBmZWF0dXJlc2ApLE4+MiYmTygiTmF2aWdhdG9yLnVzZXJBZ2VudCIsYHYke0N9IGZhaWxlZCBKUyBmZWF0dXJlcyBieSAke059IHZlcnNpb25zYCkpLEkmJihtZSgidXNlckFnZW50IixgdiR7Q30gZmFpbGVkIHYke2J9IFdpbmRvdyBmZWF0dXJlc2ApLEw+MyYmTygiTmF2aWdhdG9yLnVzZXJBZ2VudCIsYHYke0N9IGZhaWxlZCBXaW5kb3cgZmVhdHVyZXMgYnkgJHtMfSB2ZXJzaW9uc2ApKSxFKHt0aW1lOmEuc3RvcCgpLHRlc3Q6ImZlYXR1cmVzIixwYXNzZWQ6ITB9KSx7dmVyc2lvblJhbmdlOkQsdmVyc2lvbjpNLGNzc1ZlcnNpb246cCx3aW5kb3dWZXJzaW9uOmIsanNWZXJzaW9uOlMsY3NzRmVhdHVyZXM6Wy4uLmhdLHdpbmRvd0ZlYXR1cmVzOlsuLi5mXSxqc0ZlYXR1cmVzOlsuLi55XSxqc0ZlYXR1cmVzS2V5czpyfX1jYXRjaChlKXtyZXR1cm4gRSh7dGVzdDoiZmVhdHVyZXMiLHBhc3NlZDohMX0pLHZvaWQgUihlKX19Y29uc3QgR2U9WyJjYXB0aW9uIiwiaWNvbiIsIm1lbnUiLCJtZXNzYWdlLWJveCIsInNtYWxsLWNhcHRpb24iLCJzdGF0dXMtYmFyIl0sVmU9eyItYXBwbGUtc3lzdGVtIjoiTWFjIiwiU2Vnb2UgVUkiOiJXaW5kb3dzIixUYWhvbWE6IldpbmRvd3MiLCJZdSBHb3RoaWMgVUkiOiJXaW5kb3dzIiwiTWljcm9zb2Z0IEpoZW5nSGVpIFVJIjoiV2luZG93cyIsIk1pY3Jvc29mdCBZYUhlaSBVSSI6IldpbmRvd3MiLCJNZWlyeW8gVUkiOiJXaW5kb3dzIixDYW50YXJlbGw6IkxpbnV4IixVYnVudHU6IkxpbnV4IixTYW5zOiJMaW51eCIsInNhbnMtc2VyaWYiOiJMaW51eCIsIkZpcmEgU2FucyI6IkxpbnV4IixSb2JvdG86IkFuZHJvaWQifTthc3luYyBmdW5jdGlvbiBfZSh7d2ViZ2w6ZSx3b3JrZXJTY29wZTp0fSl7dHJ5e2NvbnN0IGE9dygpO2F3YWl0IGsoYSk7Y29uc3Qgbz1PYmplY3Qua2V5cyh7Li4ubmF2aWdhdG9yLm1pbWVUeXBlc30pLHI9ZnVuY3Rpb24oKXtjb25zdHtib2R5OmV9PWRvY3VtZW50LHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ZS5hcHBlbmRDaGlsZCh0KTt0cnl7Y29uc3QgZT1TdHJpbmcoWy4uLkdlLnJlZHVjZSgoKGUsbik9Pih0LnNldEF0dHJpYnV0ZSgic3R5bGUiLGBmb250OiAke259ICFpbXBvcnRhbnRgKSxlLmFkZChnZXRDb21wdXRlZFN0eWxlKHQpLmZvbnRGYW1pbHkpKSksbmV3IFNldCldKSxuPVZlW2VdO3JldHVybiBWZVtlXT9gJHtlfToke259YDplfWNhdGNoKGUpe3JldHVybiIifWZpbmFsbHl7ZS5yZW1vdmVDaGlsZCh0KX19KCksW2kscyxjXT1mdW5jdGlvbigpe2lmKCFuKXJldHVybltdO2NvbnN0IGU9ImdldFZpZGVvUGxheWJhY2tRdWFsaXR5ImluIEhUTUxWaWRlb0VsZW1lbnQucHJvdG90eXBlLHQ9Q1NTLnN1cHBvcnRzKCJhcHBlYXJhbmNlOiBpbml0aWFsIiksYT0iRGlzcGxheU5hbWVzImluIEludGwsbz1DU1Muc3VwcG9ydHMoImFzcGVjdC1yYXRpbzogaW5pdGlhbCIpLHI9Q1NTLnN1cHBvcnRzKCJib3JkZXItZW5kLWVuZC1yYWRpdXM6IGluaXRpYWwiKSxpPSJyYW5kb21VVUlEImluIENyeXB0by5wcm90b3R5cGUscz0iQmFyY29kZURldGVjdG9yImluIHdpbmRvdyxjPSJkb3dubGlua01heCJpbih3aW5kb3cuTmV0d29ya0luZm9ybWF0aW9uPy5wcm90b3R5cGV8fHt9KSxsPSJDb250ZW50SW5kZXgiaW4gd2luZG93LGQ9IkNvbnRhY3RzTWFuYWdlciJpbiB3aW5kb3csbT0iRXllRHJvcHBlciJpbiB3aW5kb3csdT0iRmlsZVN5c3RlbVdyaXRhYmxlRmlsZVN0cmVhbSJpbiB3aW5kb3csZz0iSElEImluIHdpbmRvdyYmIkhJRERldmljZSJpbiB3aW5kb3cscD0iU2VyaWFsUG9ydCJpbiB3aW5kb3cmJiJTZXJpYWwiaW4gd2luZG93LGg9IlNoYXJlZFdvcmtlciJpbiB3aW5kb3csYj0ib250b3VjaHN0YXJ0ImluIFdpbmRvdyYmIlRvdWNoRXZlbnQiaW4gd2luZG93LGY9KGUsdCk9PmU/W3RdOltdLFM9e0FuZHJvaWQ6Wy4uLmYobyxzKSwuLi5mKHQsbCksLi4uZihlLGQpLGMsLi4uZihpLCFtKSwuLi5mKGEsIXUpLC4uLmYociwhZyksLi4uZihyLCFwKSwhaCxiXSwiQ2hyb21lIE9TIjpbLi4uZihvLHMpLC4uLmYodCwhbCksLi4uZihlLCFkKSxjLC4uLmYoaSxtKSwuLi5mKGEsdSksLi4uZihyLGcpLC4uLmYocixwKSxoLGJ8fCFiXSxXaW5kb3dzOlsuLi5mKG8sIXMpLC4uLmYodCwhbCksLi4uZihlLCFkKSwhYywuLi5mKGksbSksLi4uZihhLHUpLC4uLmYocixnKSwuLi5mKHIscCksaCxifHwhYl0sTWFjOlsuLi5mKG8scyksLi4uZih0LCFsKSwuLi5mKGUsIWQpLCFjLC4uLmYoaSxtKSwuLi5mKGEsdSksLi4uZihyLGcpLC4uLmYocixwKSxoLCFiXSxMaW51eDpbLi4uZihvLCFzKSwuLi5mKHQsIWwpLC4uLmYoZSwhZCksIWMsLi4uZihpLG0pLC4uLmYoYSx1KSwuLi5mKHIsZyksLi4uZihyLHApLGgsIWJ8fCFiXX0seT17bm9Db250ZW50SW5kZXg6dCYmIWwsbm9Db250YWN0c01hbmFnZXI6ZSYmIWQsbm9Eb3dubGlua01heDohY30sRT1PYmplY3Qua2V5cyhTKS5yZWR1Y2UoKChlLHQpPT57Y29uc3Qgbj1TW3RdLGE9KyhuLmZpbHRlcigoZT0+ZSkpLmxlbmd0aC9uLmxlbmd0aCkudG9GaXhlZCgyKTtyZXR1cm4gZVt0XT1hLGV9KSx7fSksdz1PYmplY3Qua2V5cyhFKS5yZWR1Y2UoKChlLHQpPT5FW2VdPkVbdF0/ZTp0KSksaz1FW3ddO3JldHVybltFLGsseV19KCksbD17Y2hyb21pdW06bixsaWtlSGVhZGxlc3M6e25vUGx1Z2luczpuJiYwPT09bmF2aWdhdG9yLnBsdWdpbnMubGVuZ3RoLG5vTWltZVR5cGVzOm4mJjA9PT1vLmxlbmd0aCxub3RpZmljYXRpb25Jc0RlbmllZDpuJiYiTm90aWZpY2F0aW9uImluIHdpbmRvdyYmImRlbmllZCI9PU5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uLGhhc0tub3duQmdDb2xvcjpuJiYoKCk9PntsZXQgZT1RO2lmKFF8fChlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSkpLCFlKXJldHVybiExO2Uuc2V0QXR0cmlidXRlKCJzdHlsZSIsImJhY2tncm91bmQtY29sb3I6IEFjdGl2ZVRleHQiKTtjb25zdHtiYWNrZ3JvdW5kQ29sb3I6dH09Z2V0Q29tcHV0ZWRTdHlsZShlKXx8W107cmV0dXJuIFF8fGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZSksInJnYigyNTUsIDAsIDApIj09PXR9KSgpLHByZWZlcnNMaWdodENvbG9yOm1hdGNoTWVkaWEoIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogbGlnaHQpIikubWF0Y2hlcyxydHRJc1plcm86MD09PW5hdmlnYXRvcj8uY29ubmVjdGlvbj8ucnR0LHVhRGF0YUlzQmxhbms6InVzZXJBZ2VudERhdGEiaW4gbmF2aWdhdG9yJiYoIiI9PT1uYXZpZ2F0b3IudXNlckFnZW50RGF0YT8ucGxhdGZvcm18fCIiPT09YXdhaXQgbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuZ2V0SGlnaEVudHJvcHlWYWx1ZXMoWyJwbGF0Zm9ybSJdKS5wbGF0Zm9ybSkscGRmSXNEaXNhYmxlZDoicGRmVmlld2VyRW5hYmxlZCJpbiBuYXZpZ2F0b3ImJiExPT09bmF2aWdhdG9yLnBkZlZpZXdlckVuYWJsZWQsbm9UYXNrYmFyOnNjcmVlbi5oZWlnaHQ9PT1zY3JlZW4uYXZhaWxIZWlnaHQmJnNjcmVlbi53aWR0aD09PXNjcmVlbi5hdmFpbFdpZHRoLGhhc1Z2cFNjcmVlblJlczppbm5lcldpZHRoPT09c2NyZWVuLndpZHRoJiZvdXRlckhlaWdodD09PXNjcmVlbi5oZWlnaHR8fCJ2aXN1YWxWaWV3cG9ydCJpbiB3aW5kb3cmJnZpc3VhbFZpZXdwb3J0LndpZHRoPT09c2NyZWVuLndpZHRoJiZ2aXN1YWxWaWV3cG9ydC5oZWlnaHQ9PT1zY3JlZW4uaGVpZ2h0LGhhc1N3aWZ0U2hhZGVyOi9Td2lmdFNoYWRlci8udGVzdCh0Py53ZWJnbFJlbmRlcmVyKSxub1dlYlNoYXJlOm4mJkNTUy5zdXBwb3J0cygiYWNjZW50LWNvbG9yOiBpbml0aWFsIikmJighKCJzaGFyZSJpbiBuYXZpZ2F0b3IpfHwhKCJjYW5TaGFyZSJpbiBuYXZpZ2F0b3IpKSxub0NvbnRlbnRJbmRleDohIWM/Lm5vQ29udGVudEluZGV4LG5vQ29udGFjdHNNYW5hZ2VyOiEhYz8ubm9Db250YWN0c01hbmFnZXIsbm9Eb3dubGlua01heDohIWM/Lm5vRG93bmxpbmtNYXh9LGhlYWRsZXNzOnt3ZWJEcml2ZXJJc09uOkNTUy5zdXBwb3J0cygiYm9yZGVyLWVuZC1lbmQtcmFkaXVzOiBpbml0aWFsIikmJnZvaWQgMD09PW5hdmlnYXRvci53ZWJkcml2ZXJ8fCEhbmF2aWdhdG9yLndlYmRyaXZlcnx8LTEhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG5hdmlnYXRvcikuaW5kZXhPZigid2ViZHJpdmVyIiksbm9DaHJvbWU6biYmISgiY2hyb21lImluIHdpbmRvdyksaGFzUGVybWlzc2lvbnNCdWc6biYmInBlcm1pc3Npb25zImluIG5hdmlnYXRvciYmYXdhaXQoYXN5bmMoKT0+InByb21wdCI9PShhd2FpdCBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoe25hbWU6Im5vdGlmaWNhdGlvbnMifSkpLnN0YXRlJiYiTm90aWZpY2F0aW9uImluIHdpbmRvdyYmImRlbmllZCI9PT1Ob3RpZmljYXRpb24ucGVybWlzc2lvbikoKSxoYXNIZWFkbGVzc1VBOi9IZWFkbGVzc0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KXx8L0hlYWRsZXNzQ2hyb21lLy50ZXN0KG5hdmlnYXRvci5hcHBWZXJzaW9uKSxoYXNIZWFkbGVzc1dvcmtlclVBOiEhdCYmL0hlYWRsZXNzQ2hyb21lLy50ZXN0KHQudXNlckFnZW50KX0sc3RlYWx0aDp7aGFzSWZyYW1lUHJveHk6KCgpPT57dHJ5e2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaWZyYW1lIik7cmV0dXJuIGUuc3JjZG9jPWtlLCEhZS5jb250ZW50V2luZG93fWNhdGNoKGUpe3JldHVybiEwfX0pKCksaGFzSGlnaENocm9tZUluZGV4OigoKT0+e2NvbnN0IGU9ImNvb2tpZVN0b3JlImluIHdpbmRvdz8iY29va2llU3RvcmUiOiJvbmRldmljZW1vdGlvbiJpbiB3aW5kb3c/Im9uZGV2aWNlbW90aW9uIjoic3BlZWNoU3ludGhlc2lzIix0PVtdO2Zvcihjb25zdCBlIGluIHdpbmRvdyl0LnB1c2goZSk7cmV0dXJuIHQuaW5kZXhPZigiY2hyb21lIik+dC5pbmRleE9mKGUpfSkoKSxoYXNCYWRDaHJvbWVSdW50aW1lOigoKT0+e2lmKCEoImNocm9tZSJpbiB3aW5kb3cpfHwhKCJydW50aW1lImluIGNocm9tZSkpcmV0dXJuITE7dHJ5e3JldHVybiJwcm90b3R5cGUiaW4gY2hyb21lLnJ1bnRpbWUuc2VuZE1lc3NhZ2V8fCJwcm90b3R5cGUiaW4gY2hyb21lLnJ1bnRpbWUuY29ubmVjdHx8KG5ldyBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZSxuZXcgY2hyb21lLnJ1bnRpbWUuY29ubmVjdCksITB9Y2F0Y2goZSl7cmV0dXJuIlR5cGVFcnJvciIhPWUuY29uc3RydWN0b3IubmFtZX19KSgpLGhhc1RvU3RyaW5nUHJveHk6ISFhZVsiRnVuY3Rpb24udG9TdHJpbmciXSxoYXNCYWRXZWJHTDooKCk9Pntjb25zdHtVTk1BU0tFRF9SRU5ERVJFUl9XRUJHTDpufT1lPy5wYXJhbWV0ZXJzfHx7fSx7d2ViZ2xSZW5kZXJlcjphfT10fHx7fTtyZXR1cm4gbiYmYSYmbiE9PWF9KSgpfX0se2xpa2VIZWFkbGVzczpkLGhlYWRsZXNzOm0sc3RlYWx0aDp1fT1sLGc9T2JqZWN0LmtleXMoZCkscD1PYmplY3Qua2V5cyhtKSxoPU9iamVjdC5rZXlzKHUpLGI9KyhnLmZpbHRlcigoZT0+ZFtlXSkpLmxlbmd0aC9nLmxlbmd0aCoxMDApLnRvRml4ZWQoMCksZj0rKHAuZmlsdGVyKChlPT5tW2VdKSkubGVuZ3RoL3AubGVuZ3RoKjEwMCkudG9GaXhlZCgwKSxTPSsoaC5maWx0ZXIoKGU9PnVbZV0pKS5sZW5ndGgvaC5sZW5ndGgqMTAwKS50b0ZpeGVkKDApO3JldHVybiBFKHt0aW1lOmEuc3RvcCgpLHRlc3Q6ImhlYWRsZXNzIixwYXNzZWQ6ITB9KSx7Li4ubCxsaWtlSGVhZGxlc3NSYXRpbmc6YixoZWFkbGVzc1JhdGluZzpmLHN0ZWFsdGhSYXRpbmc6UyxzeXN0ZW1Gb250czpyLHBsYXRmb3JtRXN0aW1hdGU6W2ksc119fWNhdGNoKGUpe3JldHVybiBFKHt0ZXN0OiJoZWFkbGVzcyIscGFzc2VkOiExfSksdm9pZCBSKGUpfX1hc3luYyBmdW5jdGlvbiBXZSgpe3RyeXtjb25zdCBlPXcoKTthd2FpdCBrKGUpO2NvbnN0IHQ9YWVbIkludGwuQ29sbGF0b3IucmVzb2x2ZWRPcHRpb25zIl18fGFlWyJJbnRsLkRhdGVUaW1lRm9ybWF0LnJlc29sdmVkT3B0aW9ucyJdfHxhZVsiSW50bC5EaXNwbGF5TmFtZXMucmVzb2x2ZWRPcHRpb25zIl18fGFlWyJJbnRsLkxpc3RGb3JtYXQucmVzb2x2ZWRPcHRpb25zIl18fGFlWyJJbnRsLk51bWJlckZvcm1hdC5yZXNvbHZlZE9wdGlvbnMiXXx8YWVbIkludGwuUGx1cmFsUnVsZXMucmVzb2x2ZWRPcHRpb25zIl18fGFlWyJJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5yZXNvbHZlZE9wdGlvbnMiXXx8ITEsbj1JKCgoKT0+bmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodm9pZCAwLHttb250aDoibG9uZyIsdGltZVpvbmVOYW1lOiJsb25nIn0pLmZvcm1hdCg5NjM2NDQ0ZTUpKSksYT1JKCgoKT0+bmV3IEludGwuRGlzcGxheU5hbWVzKHZvaWQgMCx7dHlwZToibGFuZ3VhZ2UifSkub2YoImVuLVVTIikpKSxvPUkoKCgpPT5uZXcgSW50bC5MaXN0Rm9ybWF0KHZvaWQgMCx7c3R5bGU6ImxvbmciLHR5cGU6ImRpc2p1bmN0aW9uIn0pLmZvcm1hdChbIjAiLCIxIl0pKSkscj1JKCgoKT0+bmV3IEludGwuTnVtYmVyRm9ybWF0KHZvaWQgMCx7bm90YXRpb246ImNvbXBhY3QiLGNvbXBhY3REaXNwbGF5OiJsb25nIn0pLmZvcm1hdCgyMWU2KSkpLGk9SSgoKCk9PihuZXcgSW50bC5QbHVyYWxSdWxlcykuc2VsZWN0KDEpKSkscz1JKCgoKT0+bmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KHZvaWQgMCx7bG9jYWxlTWF0Y2hlcjoiYmVzdCBmaXQiLG51bWVyaWM6ImF1dG8iLHN0eWxlOiJsb25nIn0pLmZvcm1hdCgxLCJ5ZWFyIikpKSxjPShlPT57Y29uc3QgdD1bIkNvbGxhdG9yIiwiRGF0ZVRpbWVGb3JtYXQiLCJEaXNwbGF5TmFtZXMiLCJMaXN0Rm9ybWF0IiwiTnVtYmVyRm9ybWF0IiwiUGx1cmFsUnVsZXMiLCJSZWxhdGl2ZVRpbWVGb3JtYXQiXS5yZWR1Y2UoKCh0LG4pPT57dHJ5e2NvbnN0IGE9bmV3IGVbbl07aWYoIWEpcmV0dXJuIHQ7Y29uc3R7bG9jYWxlOm99PWEucmVzb2x2ZWRPcHRpb25zKCl8fHt9O3JldHVyblsuLi50LG9dfWNhdGNoKGUpe3JldHVybiB0fX0pLFtdKTtyZXR1cm5bLi4ubmV3IFNldCh0KV19KShJbnRsKTtyZXR1cm4gRSh7dGltZTplLnN0b3AoKSx0ZXN0OiJpbnRsIixwYXNzZWQ6ITB9KSx7ZGF0ZVRpbWVGb3JtYXQ6bixkaXNwbGF5TmFtZXM6YSxsaXN0Rm9ybWF0Om8sbnVtYmVyRm9ybWF0OnIscGx1cmFsUnVsZXM6aSxyZWxhdGl2ZVRpbWVGb3JtYXQ6cyxsb2NhbGU6IiIrYyxsaWVkOnR9fWNhdGNoKGUpe3JldHVybiBFKHt0ZXN0OiJpbnRsIixwYXNzZWQ6ITF9KSx2b2lkIFIoZSl9fWZ1bmN0aW9uIHplKCl7dHJ5e2NvbnN0IGU9dygpO2Uuc3RhcnQoKTtsZXQgdD0hMTtbImFjb3MiLCJhY29zaCIsImFzaW4iLCJhc2luaCIsImF0YW4iLCJhdGFuaCIsImF0YW4yIiwiY2JydCIsImNvcyIsImNvc2giLCJleHBtMSIsImV4cCIsImh5cG90IiwibG9nIiwibG9nMXAiLCJsb2cxMCIsInNpbiIsInNpbmgiLCJzcXJ0IiwidGFuIiwidGFuaCIsInBvdyJdLmZvckVhY2goKGU9PnthZVtgTWF0aC4ke2V9YF0mJih0PSEwKTtjb25zdCBuPSJjb3MiPT1lP1sxZTMwOF06ImFjb3MiPT1lfHwiYXNpbiI9PWV8fCJhdGFuaCI9PWU/Wy41XToicG93Ij09ZXx8ImF0YW4yIj09ZT9bTWF0aC5QSSwyXTpbTWF0aC5QSV0sYT1NYXRoW2VdKC4uLm4pLG89TWF0aFtlXSguLi5uKTtpZighKCEoIWlzTmFOKGEpfHwhaXNOYU4obykpfHxhPT1vKSl7dD0hMDtPKGBNYXRoLiR7ZX1gLCJleHBlY3RlZCB4IGFuZCBnb3QgeSIpfX0pKTtjb25zdCBuPS4xMjMsYT01ODYwODQ3MzYyMjc3Mjg0ZTIzLG89W1siYWNvcyIsW25dLGBhY29zKCR7bn0pYCwxLjQ0NzQ4NDA1MTYwMzAyNDcsTmFOLE5hTiwxLjQ0NzQ4NDA1MTYwMzAyNDVdLFsiYWNvcyIsW01hdGguU1FSVDFfMl0sImFjb3MoTWF0aC5TUVJUMV8yKSIsLjc4NTM5ODE2MzM5NzQ0ODMsTmFOLE5hTixOYU5dLFsiYWNvc2giLFsxZTMwOF0sImFjb3NoKDFlMzA4KSIsNzA5Ljg4OTM1NTgyMjcyNixOYU4sTmFOLE5hTl0sWyJhY29zaCIsW01hdGguUEldLCJhY29zaChNYXRoLlBJKSIsMS44MTE1MjYyNzI0NjA4NTMsTmFOLE5hTixOYU5dLFsiYWNvc2giLFtNYXRoLlNRUlQyXSwiYWNvc2goTWF0aC5TUVJUMikiLC44ODEzNzM1ODcwMTk1NDMsTmFOLE5hTiwuODgxMzczNTg3MDE5NTQzMl0sWyJhc2luIixbbl0sYGFzaW4oJHtufSlgLC4xMjMzMTIyNzUxOTE4NzE5OSxOYU4sTmFOLE5hTl0sWyJhc2luaCIsWzFlMzAwXSwiYXNpbmgoMWUzMDgpIiw2OTEuNDY4Njc1MDc4NzczNixOYU4sTmFOLE5hTl0sWyJhc2luaCIsW01hdGguUEldLCJhc2luaChNYXRoLlBJKSIsMS44NjIyOTU3NDMzMTA4NDgyLE5hTixOYU4sTmFOXSxbImF0YW4iLFsyXSwiYXRhbigyKSIsMS4xMDcxNDg3MTc3OTQwOTA0LE5hTixOYU4sMS4xMDcxNDg3MTc3OTQwOTA2XSxbImF0YW4iLFtNYXRoLlBJXSwiYXRhbihNYXRoLlBJKSIsMS4yNjI2MjcyNTU2Nzg5MTE1LE5hTixOYU4sTmFOXSxbImF0YW5oIixbLjVdLCJhdGFuaCgwLjUpIiwuNTQ5MzA2MTQ0MzM0MDU0OCxOYU4sTmFOLC41NDkzMDYxNDQzMzQwNTQ5XSxbImF0YW4yIixbMWUtMzEwLDJdLCJhdGFuMigxZS0zMTAsIDIpIiw1ZS0zMTEsTmFOLE5hTixOYU5dLFsiYXRhbjIiLFtNYXRoLlBJLDJdLCJhdGFuMihNYXRoLlBJKSIsMS4wMDM4ODQ4MjE4NTM4ODcyLE5hTixOYU4sTmFOXSxbImNicnQiLFsxMDBdLCJjYnJ0KDEwMCkiLDQuNjQxNTg4ODMzNjEyNzc5LE5hTixOYU4sTmFOXSxbImNicnQiLFtNYXRoLlBJXSwiY2JydChNYXRoLlBJKSIsMS40NjQ1OTE4ODc1NjE1MjMxLE5hTixOYU4sMS40NjQ1OTE4ODc1NjE1MjM0XSxbImNvcyIsW25dLGBjb3MoJHtufSlgLC45OTI0NDUwMzIxMzUxOTM1LE5hTixOYU4sTmFOXSxbImNvcyIsW01hdGguUEldLCJjb3MoTWF0aC5QSSkiLC0xLE5hTixOYU4sTmFOXSxbImNvcyIsW2FdLGBjb3MoJHthfSlgLC0uMTA4NjgwNDk0MjQ5OTU2NTksTmFOLC0uOTc3OTY2MTU1MTE5NjYxNyxOYU5dLFsiY29zIixbLTFlMzA4XSwiY29zKC0xZTMwOCkiLC0uODkxMzA4OTM3Njg3MDMzNSxOYU4sLjk5OTcwMTYyMzg4ODM4LE5hTl0sWyJjb3MiLFsxMypNYXRoLkVdLCJjb3MoMTMqTWF0aC5FKSIsLS43MTA4MTE4NTAxMDY0MzMxLC0uNzEwODExODUwMTA2NDMzMixOYU4sTmFOXSxbImNvcyIsWzU3Kk1hdGguRV0sImNvcyg1NypNYXRoLkUpIiwtLjUzNjkxMTY5NTc0OTAyNCwtLjUzNjkxMTY5NTc0OTAyMzksTmFOLE5hTl0sWyJjb3MiLFsyMSpNYXRoLkxOMl0sImNvcygyMSpNYXRoLkxOMikiLC0uNDA2Nzc3NTk3MDI1MTcyNCwtLjQwNjc3NzU5NzAyNTE3MjM1LC0uNjUzNDA2MzE4NTgyMDE5NyxOYU5dLFsiY29zIixbNTEqTWF0aC5MTjJdLCJjb3MoNTEqTWF0aC5MTjIpIiwtLjcwMTcyMDM0MDA4NTU0NDYsLS43MDE3MjAzNDAwODU1NDQ1LE5hTixOYU5dLFsiY29zIixbMjEqTWF0aC5MT0cyRV0sImNvcygyMSpNYXRoLkxPRzJFKSIsLjQzNjI4NDgwNjM2MTg5OTgsLjQzNjI4NDgwNjM2MTg5OTc2LE5hTixOYU5dLFsiY29zIixbMjUqTWF0aC5TUVJUMl0sImNvcygyNSpNYXRoLlNRUlQyKSIsLS42OTgyNjg5ODIwNDYyMzc3LC0uNjk4MjY4OTgyMDQ2MjM3NixOYU4sTmFOXSxbImNvcyIsWzUwKk1hdGguU1FSVDFfMl0sImNvcyg1MCpNYXRoLlNRUlQxXzIpIiwtLjY5ODI2ODk4MjA0NjIzNzcsLS42OTgyNjg5ODIwNDYyMzc2LE5hTixOYU5dLFsiY29zIixbMjEqTWF0aC5TUVJUMV8yXSwiY29zKDIxKk1hdGguU1FSVDFfMikiLC0uNjUzNDA2MzE4NTgyMDE5OCxOYU4sTmFOLE5hTl0sWyJjb3MiLFsxNypNYXRoLkxPRzEwRV0sImNvcygxNypNYXRoLkxPRzEwRSkiLC40NTM3NTU3NDI1OTgyNzg0LC40NTM3NTU3NDI1OTgyNzgzMyxOYU4sTmFOXSxbImNvcyIsWzIqTWF0aC5MT0cxMEVdLCJjb3MoMipNYXRoLkxPRzEwRSkiLC42NDU5MDQ0MDA3NDM4MTQyLE5hTiwuNjQ1OTA0NDAwNzQzODE0MSxOYU5dLFsiY29zaCIsWzFdLCJjb3NoKDEpIiwxLjU0MzA4MDYzNDgxNTI0MzcsTmFOLE5hTixOYU5dLFsiY29zaCIsW01hdGguUEldLCJjb3NoKE1hdGguUEkpIiwxMS41OTE5NTMyNzU1MjE1MTksTmFOLE5hTixOYU5dLFsiY29zaCIsWzQ5MipNYXRoLkxPRzJFXSwiY29zaCg0OTIqTWF0aC5MT0cyRSkiLDkxOTk4NzAzMTM4Nzc3NzJlMjkyLDkxOTk4NzAzMTM4Nzc3NzRlMjkyLE5hTixOYU5dLFsiY29zaCIsWzUwMipNYXRoLlNRUlQyXSwiY29zaCg1MDIqTWF0aC5TUVJUMikiLDEwNDY5MTk5NjY5MDIzMTM4ZTI5MiwxMDQ2OTE5OTY2OTAyMzE0ZTI5MyxOYU4sTmFOXSxbImV4cG0xIixbMV0sImV4cG0xKDEpIiwxLjcxODI4MTgyODQ1OTA0NSxOYU4sTmFOLDEuNzE4MjgxODI4NDU5MDQ1M10sWyJleHBtMSIsW01hdGguUEldLCJleHBtMShNYXRoLlBJKSIsMjIuMTQwNjkyNjMyNzc5MjY3LE5hTixOYU4sTmFOXSxbImV4cCIsW25dLGBleHAoJHtufSlgLDEuMTMwODg0NDIwOTQ3NDg5MyxOYU4sTmFOLE5hTl0sWyJleHAiLFtNYXRoLlBJXSwiZXhwKE1hdGguUEkpIiwyMy4xNDA2OTI2MzI3NzkyNjcsTmFOLE5hTixOYU5dLFsiaHlwb3QiLFsxLDIsMyw0LDUsNl0sImh5cG90KDEsIDIsIDMsIDQsIDUsIDYpIiw5LjUzOTM5MjAxNDE2OTQ1NixOYU4sTmFOLE5hTl0sWyJoeXBvdCIsW2EsYV0sYGh5cG90KCR7YX0sICR7YX0pYCw4Mjg4NDg5ODI2NzMxMTE2ZTIzLDgyODg0ODk4MjY3MzExMTRlMjMsTmFOLE5hTl0sWyJoeXBvdCIsWzIqTWF0aC5FLC0xMDBdLCJoeXBvdCgyKk1hdGguRSwgLTEwMCkiLDEwMC4xNDc2NzIwODY3NTI1OSwxMDAuMTQ3NjcyMDg2NzUyNTgsTmFOLE5hTl0sWyJoeXBvdCIsWzYqTWF0aC5QSSwtMTAwXSwiaHlwb3QoNipNYXRoLlBJLCAtMTAwKSIsMTAxLjc2MTAyMjc4NTkzMzE5LDEwMS43NjEwMjI3ODU5MzMyLE5hTixOYU5dLFsiaHlwb3QiLFsyKk1hdGguTE4yLC0xMDBdLCJoeXBvdCgyKk1hdGguTE4yLCAtMTAwKSIsMTAwLjAwOTYwODU5ODY1MjUsMTAwLjAwOTYwODU5ODY1MjUyLE5hTixOYU5dLFsiaHlwb3QiLFtNYXRoLkxPRzJFLC0xMDBdLCJoeXBvdChNYXRoLkxPRzJFLCAtMTAwKSIsMTAwLjAxMDQwNjMwMzQ0OTI5LDEwMC4wMTA0MDYzMDM0NDkyNyxOYU4sTmFOXSxbImh5cG90IixbTWF0aC5TUVJUMiwtMTAwXSwiaHlwb3QoTWF0aC5TUVJUMiwgLTEwMCkiLDEwMC4wMDk5OTk1MDAwNDk5OSwxMDAuMDA5OTk5NTAwMDUsTmFOLE5hTl0sWyJoeXBvdCIsW01hdGguU1FSVDFfMiwtMTAwXSwiaHlwb3QoTWF0aC5TUVJUMV8yLCAtMTAwKSIsMTAwLjAwMjQ5OTk2ODc1MDgsMTAwLjAwMjQ5OTk2ODc1MDc4LE5hTixOYU5dLFsiaHlwb3QiLFsyKk1hdGguTE9HMTBFLC0xMDBdLCJoeXBvdCgyKk1hdGguTE9HMTBFLCAtMTAwKSIsMTAwLjAwMzc3MjE2Mjc5NDE2LDEwMC4wMDM3NzIxNjI3OTQxOCxOYU4sTmFOXSxbImxvZyIsW25dLGBsb2coJHtufSlgLC0yLjA5NTU3MDkyMzYwOTcxOTcsTmFOLE5hTixOYU5dLFsibG9nIixbTWF0aC5QSV0sImxvZyhNYXRoLlBJKSIsMS4xNDQ3Mjk4ODU4NDk0MDAyLE5hTixOYU4sTmFOXSxbImxvZzFwIixbbl0sYGxvZzFwKCR7bn0pYCwuMTE2MDAzNjc1NzU2MzA2MTMsTmFOLE5hTixOYU5dLFsibG9nMXAiLFtNYXRoLlBJXSwibG9nMXAoTWF0aC5QSSkiLDEuNDIxMDgwNDEyNzk0MjkyNixOYU4sTmFOLE5hTl0sWyJsb2cxMCIsW25dLGBsb2cxMCgke259KWAsLS45MTAwOTQ4ODg1NjA2MDIxLE5hTixOYU4sTmFOXSxbImxvZzEwIixbTWF0aC5QSV0sImxvZzEwKE1hdGguUEkpIiwuNDk3MTQ5ODcyNjk0MTMzOCwuNDk3MTQ5ODcyNjk0MTMzODUsTmFOLE5hTl0sWyJsb2cxMCIsW01hdGguRV0sImxvZzEwKE1hdGguRSkiLC40MzQyOTQ0ODE5MDMyNTE4LE5hTixOYU4sTmFOXSxbImxvZzEwIixbMzQqTWF0aC5FXSwibG9nMTAoMzQqTWF0aC5FKSIsMS45NjU3NzMzOTg5NDU1MDY4LDEuOTY1NzczMzk4OTQ1NTA3LE5hTixOYU5dLFsibG9nMTAiLFtNYXRoLkxOMl0sImxvZzEwKE1hdGguTE4yKSIsLS4xNTkxNzQ1Mzg5NTQ4NjE2LE5hTixOYU4sTmFOXSxbImxvZzEwIixbMTEqTWF0aC5MTjJdLCJsb2cxMCgxMSpNYXRoLkxOMikiLC44ODIyMTgxNDYyMDMzNjM0LC44ODIyMTgxNDYyMDMzNjM1LE5hTixOYU5dLFsibG9nMTAiLFtNYXRoLkxPRzJFXSwibG9nMTAoTWF0aC5MT0cyRSkiLC4xNTkxNzQ1Mzg5NTQ4NjE1OCxOYU4sTmFOLE5hTl0sWyJsb2cxMCIsWzQzKk1hdGguTE9HMkVdLCJsb2cxMCg0MypNYXRoLkxPRzJFKSIsMS43OTI2NDI5OTQ1MzQ0NDgsMS43OTI2NDI5OTQ1MzQ0NDgyLE5hTixOYU5dLFsibG9nMTAiLFtNYXRoLkxPRzEwRV0sImxvZzEwKE1hdGguTE9HMTBFKSIsLS4zNjIyMTU2ODg2OTk0NjMyNSxOYU4sTmFOLE5hTl0sWyJsb2cxMCIsWzcqTWF0aC5MT0cxMEVdLCJsb2cxMCg3Kk1hdGguTE9HMTBFKSIsLjQ4Mjg4MjM1MTMxNDc5MzYsLjQ4Mjg4MjM1MTMxNDc5MzU3LE5hTixOYU5dLFsibG9nMTAiLFtNYXRoLlNRUlQxXzJdLCJsb2cxMChNYXRoLlNRUlQxXzIpIiwtLjE1MDUxNDk5NzgzMTk5MDU3LE5hTixOYU4sTmFOXSxbImxvZzEwIixbMipNYXRoLlNRUlQxXzJdLCJsb2cxMCgyKk1hdGguU1FSVDFfMikiLC4xNTA1MTQ5OTc4MzE5OTA2LC4xNTA1MTQ5OTc4MzE5OTA2MyxOYU4sTmFOXSxbImxvZzEwIixbTWF0aC5TUVJUMl0sImxvZzEwKE1hdGguU1FSVDIpIiwuMTUwNTE0OTk3ODMxOTkwNiwuMTUwNTE0OTk3ODMxOTkwNjMsTmFOLE5hTl0sWyJzaW4iLFthXSxgc2luKCR7YX0pYCwuOTk0MDc2NzMyNTM2MDY4LE5hTiwtLjIwODc2MzUwMTIxNzIwNDg4LE5hTl0sWyJzaW4iLFtNYXRoLlBJXSwic2luKE1hdGguUEkpIiwxMjI0NjQ2Nzk5MTQ3MzUzMmUtMzIsTmFOLDEyMjQ2MDYzNTM4MjIzNzczZS0zMixOYU5dLFsic2luIixbMzkqTWF0aC5FXSwic2luKDM5Kk1hdGguRSkiLC0uNzE4MTYzMDMwODU3MDY3NywtLjcxODE2MzAzMDg1NzA2NzgsTmFOLE5hTl0sWyJzaW4iLFszNSpNYXRoLkxOMl0sInNpbigzNSpNYXRoLkxOMikiLC0uNzY1OTk2NDEzODk4MDUxMSwtLjc2NTk5NjQxMzg5ODA1MSxOYU4sTmFOXSxbInNpbiIsWzExMCpNYXRoLkxPRzJFXSwic2luKDExMCpNYXRoLkxPRzJFKSIsLjk5ODk0MTAxNDAyNzM3NTYsLjk5ODk0MTAxNDAyNzM3NTcsTmFOLE5hTl0sWyJzaW4iLFs3Kk1hdGguTE9HMTBFXSwic2luKDcqTWF0aC5MT0cxMEUpIiwuMTAxMzU2OTI5MjQ5NjU2MTYsLjEwMTM1NjkyOTI0OTY1NjE0LE5hTixOYU5dLFsic2luIixbMzUqTWF0aC5TUVJUMV8yXSwic2luKDM1Kk1hdGguU1FSVDFfMikiLC0uMzc0NjM1NzU0Nzg1ODIwMiwtLjM3NDYzNTc1NDc4NTgyMDIzLE5hTixOYU5dLFsic2luIixbMjEqTWF0aC5TUVJUMl0sInNpbigyMSpNYXRoLlNRUlQyKSIsLS45ODkyNjY4MTg3NzgwNDk4LC0uOTg5MjY2ODE4Nzc4MDQ5NyxOYU4sTmFOXSxbInNpbmgiLFsxXSwic2luaCgxKSIsMS4xNzUyMDExOTM2NDM4MDE0LE5hTixOYU4sTmFOXSxbInNpbmgiLFtNYXRoLlBJXSwic2luaChNYXRoLlBJKSIsMTEuNTQ4NzM5MzU3MjU3NzQ4LE5hTixOYU4sMTEuNTQ4NzM5MzU3MjU3NzQ2XSxbInNpbmgiLFtNYXRoLkVdLCJzaW5oKE1hdGguRSkiLDcuNTQ0MTM3MTAyODE2OTc1LE5hTixOYU4sTmFOXSxbInNpbmgiLFtNYXRoLkxOMl0sInNpbmgoTWF0aC5MTjIpIiwuNzUsTmFOLE5hTixOYU5dLFsic2luaCIsW01hdGguTE9HMkVdLCJzaW5oKE1hdGguTE9HMkUpIiwxLjk5Nzg5ODAwOTEwNjI3OTUsTmFOLE5hTixOYU5dLFsic2luaCIsWzQ5MipNYXRoLkxPRzJFXSwic2luaCg0OTIqTWF0aC5MT0cyRSkiLDkxOTk4NzAzMTM4Nzc3NzJlMjkyLDkxOTk4NzAzMTM4Nzc3NzRlMjkyLE5hTixOYU5dLFsic2luaCIsW01hdGguTE9HMTBFXSwic2luaChNYXRoLkxPRzEwRSkiLC40NDgwNzU5Nzk0MTQ2OTAyNCxOYU4sTmFOLE5hTl0sWyJzaW5oIixbTWF0aC5TUVJUMV8yXSwic2luaChNYXRoLlNRUlQxXzIpIiwuNzY3NTIzMTQ1MTI2MTE2NCxOYU4sTmFOLE5hTl0sWyJzaW5oIixbTWF0aC5TUVJUMl0sInNpbmgoTWF0aC5TUVJUMikiLDEuOTM1MDY2ODIyMTc0MzU3LE5hTixOYU4sMS45MzUwNjY4MjIxNzQzNTY4XSxbInNpbmgiLFs1MDIqTWF0aC5TUVJUMl0sInNpbmgoNTAyKk1hdGguU1FSVDIpIiwxMDQ2OTE5OTY2OTAyMzEzOGUyOTIsMTA0NjkxOTk2NjkwMjMxNGUyOTMsTmFOLE5hTl0sWyJzcXJ0Iixbbl0sYHNxcnQoJHtufSlgLC4zNTA3MTM1NTgzMzUwMDM2LE5hTixOYU4sTmFOXSxbInNxcnQiLFtNYXRoLlBJXSwic3FydChNYXRoLlBJKSIsMS43NzI0NTM4NTA5MDU1MTU5LE5hTixOYU4sTmFOXSxbInRhbiIsWy0xZTMwOF0sInRhbigtMWUzMDgpIiwuNTA4Njg2MTI1OTEwNzU2OCxOYU4sTmFOLC41MDg2ODYxMjU5MTA3NTY3XSxbInRhbiIsW01hdGguUEldLCJ0YW4oTWF0aC5QSSkiLC0xMjI0NjQ2Nzk5MTQ3MzUzMmUtMzIsTmFOLE5hTixOYU5dLFsidGFuIixbNipNYXRoLkVdLCJ0YW4oNipNYXRoLkUpIiwuNjg2Njc2MTU0NjQ1MjQzMSwuNjg2Njc2MTU0NjQ1MjQzLE5hTixOYU5dLFsidGFuIixbNipNYXRoLkxOMl0sInRhbig2Kk1hdGguTE4yKSIsMS42MTgyODE3MTM1NzE1ODc3LDEuNjE4MjgxNzEzNTcxNTg4LE5hTiwxLjYxODI4MTcxMzU3MTU4NzVdLFsidGFuIixbMTAqTWF0aC5MT0cyRV0sInRhbigxMCpNYXRoLkxPRzJFKSIsLTMuMzUzNzEyODcwNTM3NjAxNCwtMy4zNTM3MTI4NzA1Mzc2MDEsTmFOLC0zLjM1MzcxMjg3MDUzNzYwMl0sWyJ0YW4iLFsxNypNYXRoLlNRUlQyXSwidGFuKDE3Kk1hdGguU1FSVDIpIiwtMS45MjIyOTU1NDYxNzk5OTgyLC0xLjkyMjI5NTU0NjE3OTk5OCxOYU4sTmFOXSxbInRhbiIsWzM0Kk1hdGguU1FSVDFfMl0sInRhbigzNCpNYXRoLlNRUlQxXzIpIiwtMS45MjIyOTU1NDYxNzk5OTgyLC0xLjkyMjI5NTU0NjE3OTk5OCxOYU4sTmFOXSxbInRhbiIsWzEwKk1hdGguTE9HMTBFXSwidGFuKDEwKk1hdGguTE9HMTBFKSIsMi41ODI0ODU2MTMwNzEyNDMyLDIuNTgyNDg1NjEzMDcxMjQzNyxOYU4sTmFOXSxbInRhbmgiLFtuXSxgdGFuaCgke259KWAsLjEyMjM4MzQ0MTg5NDQwODc1LE5hTixOYU4sLjEyMjM4MzQ0MTg5NDQwODc2XSxbInRhbmgiLFtNYXRoLlBJXSwidGFuaChNYXRoLlBJKSIsLjk5NjI3MjA3NjIyMDc1LE5hTixOYU4sTmFOXSxbInBvdyIsW24sLTEwMF0sYHBvdygke259LCAtMTAwKWAsMTAyMjA4OTMzMzU4NDUxOWU3NiwxMDIyMDg5MzMzNTg0NTE3NmU3NSxOYU4sTmFOXSxbInBvdyIsW01hdGguUEksLTEwMF0sInBvdyhNYXRoLlBJLCAtMTAwKSIsMS45Mjc1ODE0MTYwNTYwMjA0ZS01MCwxLjkyNzU4MTQxNjA1NjAxODVlLTUwLE5hTiwxLjkyNzU4MTQxNjA1NjAyMDZlLTUwXSxbInBvdyIsW01hdGguRSwtMTAwXSwicG93KE1hdGguRSwgLTEwMCkiLDM3MjAwNzU5NzYwMjA4NTU1ZS02MCwzNzIwMDc1OTc2MDIwODUxZS01OSxOYU4sTmFOXSxbInBvdyIsW01hdGguTE4yLC0xMDBdLCJwb3coTWF0aC5MTjIsIC0xMDApIiw4MjY5MDE3MjAzODAyMzk0LDgyNjkwMTcyMDM4MDI0MTAsTmFOLE5hTl0sWyJwb3ciLFtNYXRoLkxOMTAsLTEwMF0sInBvdyhNYXRoLkxOMTAsIC0xMDApIiw2MDAzODY3OTI2NzM4ODI5ZS01Miw2MDAzODY3OTI2NzM4ODExZS01MixOYU4sTmFOXSxbInBvdyIsW01hdGguTE9HMkUsLTEwMF0sInBvdyhNYXRoLkxPRzJFLCAtMTAwKSIsMTIwOTMzMzU1ODQ1NTAxZS0zMCwxMjA5MzMzNTU4NDU1MDA2MWUtMzIsTmFOLE5hTl0sWyJwb3ciLFtNYXRoLkxPRzEwRSwtMTAwXSwicG93KE1hdGguTE9HMTBFLCAtMTAwKSIsMTY2NTU5MjkzNDc1ODU5NThlMjAsMTY2NTU5MjkzNDc1ODU5MmUyMSxOYU4sMTY2NTU5MjkzNDc1ODU5NTVlMjBdLFsicG93IixbTWF0aC5TUVJUMV8yLC0xMDBdLCJwb3coTWF0aC5TUVJUMV8yLCAtMTAwKSIsMTEyNTg5OTkwNjg0MjYxNi4yLDExMjU4OTk5MDY4NDI2MTEuNSxOYU4sTmFOXSxbInBvdyIsW01hdGguU1FSVDIsLTEwMF0sInBvdyhNYXRoLlNRUlQyLCAtMTAwKSIsODg4MTc4NDE5NzAwMTE5MWUtMzEsODg4MTc4NDE5NzAwMTE1NGUtMzEsTmFOLE5hTl0sWyJwb2x5ZmlsbCIsWy4wMDIqKi0xMDBdLCJwb2x5ZmlsbCBwb3coMmUtMywgLTEwMCkiLDc4ODg2MDkwNTIyMTAxMDJlMjU0LDc4ODg2MDkwNTIyMTAxMjZlMjU0LE5hTixOYU5dXSxyPXt9O3JldHVybiBvLmZvckVhY2goKGU9PntyW2VbMl1dPU4oKCgpPT57Y29uc3QgdD0icG9seWZpbGwiIT1lWzBdP01hdGhbZVswXV0oLi4uZVsxXSk6ZVsxXTtyZXR1cm57cmVzdWx0OnQsY2hyb21lOnQ9PWVbM10sZmlyZWZveDohIWVbNF0mJnQ9PWVbNF0sdG9yQnJvd3NlcjohIWVbNV0mJnQ9PWVbNV0sc2FmYXJpOiEhZVs2XSYmdD09ZVs2XX19KSl9KSksRSh7dGltZTplLnN0b3AoKSx0ZXN0OiJtYXRoIixwYXNzZWQ6ITB9KSx7ZGF0YTpyLGxpZWQ6dH19Y2F0Y2goZSl7cmV0dXJuIEUoe3Rlc3Q6Im1hdGgiLHBhc3NlZDohMX0pLHZvaWQgUihlKX19YXN5bmMgZnVuY3Rpb24gamUoKXt0cnl7Y29uc3QgZT13KCk7ZS5zdGFydCgpO2NvbnN0IHQ9KCgpPT57dHJ5e2NvbnN0IGU9WydhdWRpby9vZ2c7IGNvZGVjcz0idm9yYmlzIicsImF1ZGlvL21wZWciLCJhdWRpby9tcGVndXJsIiwnYXVkaW8vd2F2OyBjb2RlY3M9IjEiJywiYXVkaW8veC1tNGEiLCJhdWRpby9hYWMiLCd2aWRlby9vZ2c7IGNvZGVjcz0idGhlb3JhIicsInZpZGVvL3F1aWNrdGltZSIsJ3ZpZGVvL21wNDsgY29kZWNzPSJhdmMxLjQyRTAxRSInLCd2aWRlby93ZWJtOyBjb2RlY3M9InZwOCInLCd2aWRlby93ZWJtOyBjb2RlY3M9InZwOSInLCJ2aWRlby94LW1hdHJvc2thIl0uc29ydCgpLHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgidmlkZW8iKSxuPW5ldyBBdWRpbyxhPSJNZWRpYVJlY29yZGVyImluIHdpbmRvdztyZXR1cm4gZS5yZWR1Y2UoKChlLG8pPT57Y29uc3Qgcj17bWltZVR5cGU6byxhdWRpb1BsYXlUeXBlOm4uY2FuUGxheVR5cGUobyksdmlkZW9QbGF5VHlwZTp0LmNhblBsYXlUeXBlKG8pLG1lZGlhU291cmNlOk1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChvKSxtZWRpYVJlY29yZGVyOiEhYSYmTWVkaWFSZWNvcmRlci5pc1R5cGVTdXBwb3J0ZWQobyl9O3JldHVybiByLmF1ZGlvUGxheVR5cGV8fHIudmlkZW9QbGF5VHlwZXx8ci5tZWRpYVNvdXJjZXx8ci5tZWRpYVJlY29yZGVyPyhlLnB1c2gociksZSk6ZX0pLFtdKX1jYXRjaChlKXtyZXR1cm59fSkoKTtyZXR1cm4gRSh7dGltZTplLnN0b3AoKSx0ZXN0OiJtZWRpYSIscGFzc2VkOiEwfSkse21pbWVUeXBlczp0fX1jYXRjaChlKXtyZXR1cm4gRSh7dGVzdDoibWVkaWEiLHBhc3NlZDohMX0pLHZvaWQgUihlKX19YXN5bmMgZnVuY3Rpb24gVWUoZSl7dHJ5e2NvbnN0IHQ9dygpO2F3YWl0IGsodCk7bGV0IG49YWVbIk5hdmlnYXRvci5hcHBWZXJzaW9uIl18fGFlWyJOYXZpZ2F0b3IuZGV2aWNlTWVtb3J5Il18fGFlWyJOYXZpZ2F0b3IuZG9Ob3RUcmFjayJdfHxhZVsiTmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kiXXx8YWVbIk5hdmlnYXRvci5sYW5ndWFnZSJdfHxhZVsiTmF2aWdhdG9yLmxhbmd1YWdlcyJdfHxhZVsiTmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIl18fGFlWyJOYXZpZ2F0b3Iub3NjcHUiXXx8YWVbIk5hdmlnYXRvci5wbGF0Zm9ybSJdfHxhZVsiTmF2aWdhdG9yLnVzZXJBZ2VudCJdfHxhZVsiTmF2aWdhdG9yLnZlbmRvciJdfHxhZVsiTmF2aWdhdG9yLnBsdWdpbnMiXXx8YWVbIk5hdmlnYXRvci5taW1lVHlwZXMiXXx8ITE7Y29uc3QgYT0hKCJjaHJvbWUiaW4gd2luZG93KXx8bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhuYXZpZ2F0b3IuYXBwVmVyc2lvbiksbz17cGxhdGZvcm06TigoKCk9Pntjb25zdHtwbGF0Zm9ybTp0fT1uYXZpZ2F0b3I7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0JiZbIndpbiIsImxpbnV4IiwibWFjIiwiYXJtIiwicGlrZSIsImxpbnV4IiwiaXBob25lIiwiaXBhZCIsImlwb2QiLCJhbmRyb2lkIiwieDExIl0uZmlsdGVyKChlPT50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZSkpKVswXXx8bWUoInBsYXRmb3JtIixgJHt0fSBpcyB1bnVzdWFsYCkscCE9PWgmJihuPSEwLE8oIk5hdmlnYXRvci5wbGF0Zm9ybSIsYCR7aH0gcGxhdGZvcm0gYW5kICR7cH0gdXNlciBhZ2VudCBkbyBub3QgbWF0Y2hgKSksdCE9ZS5wbGF0Zm9ybSYmKG49ITApLHR9KSksc3lzdGVtOk4oKCgpPT5kKG5hdmlnYXRvci51c2VyQWdlbnQpKSwidXNlckFnZW50IHN5c3RlbSBmYWlsZWQiKSx1c2VyQWdlbnRQYXJzZWQ6YXdhaXQgTigoYXN5bmMoKT0+e2NvbnN0IGU9SSgoKCk9Pm5hdmlnYXRvci51c2VyQWdlbnQpKSx0PWQoZSksbj1hd2FpdCBzKCk7cmV0dXJuIGIoe3VhOmUsb3M6dCxpc0JyYXZlOm59KX0pKSxkZXZpY2U6TigoKCk9PmYoe3VzZXJBZ2VudDpuYXZpZ2F0b3IudXNlckFnZW50fSkpLCJ1c2VyQWdlbnQgZGV2aWNlIGZhaWxlZCIpLHVzZXJBZ2VudDpOKCgoKT0+e2NvbnN0e3VzZXJBZ2VudDp0fT1uYXZpZ2F0b3I7YXx8bWUoInVzZXJBZ2VudCIsYCR7dH0gZG9lcyBub3QgbWF0Y2ggYXBwVmVyc2lvbmApLC9cc3syLH18XlxzfFxzJC9nLnRlc3QodCkmJm1lKCJ1c2VyQWdlbnQiLCJleHRyYSBzcGFjZXMgZGV0ZWN0ZWQiKTtyZXR1cm4gc2UodCkubGVuZ3RoJiZtZSgidXNlckFnZW50IGlzIGdpYmJlcmlzaCIsdCksdCE9ZS51c2VyQWdlbnQmJihuPSEwKSx0LnRyaW0oKS5yZXBsYWNlKC9cc3syLH0vLCIgIil9KSwidXNlckFnZW50IGZhaWxlZCIpLHVhUG9zdFJlZHVjdGlvbjpTKChuYXZpZ2F0b3J8fHt9KS51c2VyQWdlbnQpLGFwcFZlcnNpb246TigoKCk9Pntjb25zdHthcHBWZXJzaW9uOmV9PW5hdmlnYXRvcjtyZXR1cm4gYXx8bWUoImFwcFZlcnNpb24iLGAke2V9IGRvZXMgbm90IG1hdGNoIHVzZXJBZ2VudGApLCJhcHBWZXJzaW9uImluIG5hdmlnYXRvciYmIWUmJm1lKCJhcHBWZXJzaW9uIiwiTGl2aW5nIFN0YW5kYXJkIHByb3BlcnR5IHJldHVybmVkIGZhbHN5IHZhbHVlIiksL1xzezIsfXxeXHN8XHMkL2cudGVzdChlKSYmbWUoImFwcFZlcnNpb24iLCJleHRyYSBzcGFjZXMgZGV0ZWN0ZWQiKSxlLnRyaW0oKS5yZXBsYWNlKC9cc3syLH0vLCIgIil9KSwiYXBwVmVyc2lvbiBmYWlsZWQiKSxkZXZpY2VNZW1vcnk6TigoKCk9PntpZighKCJkZXZpY2VNZW1vcnkiaW4gbmF2aWdhdG9yKSlyZXR1cm47Y29uc3R7ZGV2aWNlTWVtb3J5OnR9PW5hdmlnYXRvcjsoey4yNTohMCwuNTohMCwxOiEwLDI6ITAsNDohMCw4OiEwfSlbdF18fG1lKCJkZXZpY2VNZW1vcnkiLGAke3R9IGlzIG5vdCBhIHZhbGlkIHZhbHVlIFswLjI1LCAwLjUsIDEsIDIsIDQsIDhdYCk7Y29uc3QgYT1wZXJmb3JtYW5jZT8ubWVtb3J5Py5qc0hlYXBTaXplTGltaXR8fG51bGwsbz1hPysoYS8xMDczNzQxODI0KS50b0ZpeGVkKDEpOjA7cmV0dXJuIG8+dCYmbWUoImRldmljZU1lbW9yeSIsYGF2YWlsYWJsZSBtZW1vcnkgJHtvfUdCIGlzIGdyZWF0ZXIgdGhhbiBkZXZpY2UgbWVtb3J5ICR7dH1HQmApLHQhPT1lLmRldmljZU1lbW9yeSYmKG49ITApLHR9KSwiZGV2aWNlTWVtb3J5IGZhaWxlZCIpLGRvTm90VHJhY2s6TigoKCk9Pntjb25zdHtkb05vdFRyYWNrOmV9PW5hdmlnYXRvcjtyZXR1cm57MTohMCx0cnVlOiEwLHllczohMCwwOiEwLGZhbHNlOiEwLG5vOiEwLHVuc3BlY2lmaWVkOiEwLG51bGw6ITAsdW5kZWZpbmVkOiEwfVtlXXx8bWUoImRvTm90VHJhY2sgLSB1bnVzdWFsIHJlc3VsdCIsZSksZX0pLCJkb05vdFRyYWNrIGZhaWxlZCIpLGdsb2JhbFByaXZhY3lDb250cm9sOk4oKCgpPT57aWYoISgiZ2xvYmFsUHJpdmFjeUNvbnRyb2wiaW4gbmF2aWdhdG9yKSlyZXR1cm47Y29uc3R7Z2xvYmFsUHJpdmFjeUNvbnRyb2w6ZX09bmF2aWdhdG9yO3JldHVybnsxOiEwLHRydWU6ITAseWVzOiEwLDA6ITAsZmFsc2U6ITAsbm86ITAsdW5zcGVjaWZpZWQ6ITAsbnVsbDohMCx1bmRlZmluZWQ6ITB9W2VdfHxtZSgiZ2xvYmFsUHJpdmFjeUNvbnRyb2wgLSB1bnVzdWFsIHJlc3VsdCIsZSksZX0pLCJnbG9iYWxQcml2YWN5Q29udHJvbCBmYWlsZWQiKSxoYXJkd2FyZUNvbmN1cnJlbmN5Ok4oKCgpPT57aWYoISgiaGFyZHdhcmVDb25jdXJyZW5jeSJpbiBuYXZpZ2F0b3IpKXJldHVybjtjb25zdHtoYXJkd2FyZUNvbmN1cnJlbmN5OnR9PW5hdmlnYXRvcjtyZXR1cm4gdCE9PWUuaGFyZHdhcmVDb25jdXJyZW5jeSYmKG49ITApLHR9KSwiaGFyZHdhcmVDb25jdXJyZW5jeSBmYWlsZWQiKSxsYW5ndWFnZTpOKCgoKT0+e2NvbnN0e2xhbmd1YWdlOnQsbGFuZ3VhZ2VzOmF9PW5hdmlnYXRvcjtpZih0JiZhKXtjb25zdCBlPS9eLnswLDJ9L2cuZXhlYyh0KVswXTtyZXR1cm4vXi57MCwyfS9nLmV4ZWMoYVswXSlbMF0hPWUmJm1lKCJsYW5ndWFnZS9sYW5ndWFnZXMiLGAke1t0LGFdLmpvaW4oIiAiKX0gbWlzbWF0Y2hgKSxgJHthLmpvaW4oIiwgIil9ICgke3R9KWB9cmV0dXJuIHQhPWUubGFuZ3VhZ2UmJihuPSEwLE8oIk5hdmlnYXRvci5sYW5ndWFnZSIsYCR7dH0gZG9lcyBub3QgbWF0Y2ggd29ya2VyIHNjb3BlYCkpLGEhPT1lLmxhbmd1YWdlcyYmKG49ITAsTygiTmF2aWdhdG9yLmxhbmd1YWdlcyIsYCR7YX0gZG9lcyBub3QgbWF0Y2ggd29ya2VyIHNjb3BlYCkpLGAke3R9ICR7YX1gfSksImxhbmd1YWdlKHMpIGZhaWxlZCIpLG1heFRvdWNoUG9pbnRzOk4oKCgpPT4ibWF4VG91Y2hQb2ludHMiaW4gbmF2aWdhdG9yP25hdmlnYXRvci5tYXhUb3VjaFBvaW50czpudWxsKSwibWF4VG91Y2hQb2ludHMgZmFpbGVkIiksdmVuZG9yOk4oKCgpPT5uYXZpZ2F0b3IudmVuZG9yKSwidmVuZG9yIGZhaWxlZCIpLG1pbWVUeXBlczpOKCgoKT0+e2NvbnN0e21pbWVUeXBlczplfT1uYXZpZ2F0b3I7cmV0dXJuIGU/Wy4uLmVdLm1hcCgoZT0+ZS50eXBlKSk6W119KSwibWltZVR5cGVzIGZhaWxlZCIpLG9zY3B1Ok4oKCgpPT5uYXZpZ2F0b3Iub3NjcHUpLCJvc2NwdSBmYWlsZWQiKSxwbHVnaW5zOk4oKCgpPT57Y29uc3R7cGx1Z2luczplfT1uYXZpZ2F0b3I7aWYoIShlIGluc3RhbmNlb2YgUGx1Z2luQXJyYXkpKXJldHVybjtjb25zdCB0PWU/Wy4uLmVdLm1hcCgoZT0+KHtuYW1lOmUubmFtZSxkZXNjcmlwdGlvbjplLmRlc2NyaXB0aW9uLGZpbGVuYW1lOmUuZmlsZW5hbWUsdmVyc2lvbjplLnZlcnNpb259KSkpOltdLHtsaWVzOmF9PSgoZSx0KT0+e2NvbnN0IG49W10sYT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlKS5maWx0ZXIoKGU9PmlzTmFOKCtlKSkpLG89T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCkuZmlsdGVyKChlPT5pc05hTigrZSkpKSxyPVsuLi5lXSxpPVsuLi50XSxzPW5ldyBTZXQobyksYz0obD1pLm1hcCgoZT0+ZS5lbmFibGVkUGx1Z2luKSksWy4uLm5ldyBTZXQobCldKTt2YXIgbDtjb25zdCBkPW5ldyBTZXQoYSksbT1jLm1hcCgoZT0+ZSYmZS5uYW1lKSk7cmV0dXJuWy4uLmRdLmZvckVhY2goKGU9PntuZXcgU2V0KG0pLmhhcyhlKXx8ZC5kZWxldGUoZSl9KSksci5maWx0ZXIoKGU9Pnt0cnl7Y29uc3QgdD0iTWltZVR5cGUiPT1PYmplY3QuZ2V0UHJvdG90eXBlT2YoZVswXSkuY29uc3RydWN0b3IubmFtZTtyZXR1cm4gdHx8ZC5kZWxldGUoZS5uYW1lKSwhdH1jYXRjaCh0KXtyZXR1cm4gZC5kZWxldGUoZS5uYW1lKSwhMH19KSkubGVuZ3RoJiZuLnB1c2goIm1pc3NpbmcgbWltZXR5cGUiKSxyLm1hcCgoZT0+T2JqZWN0LnZhbHVlcyhlKSkpLmZsYXQoKS5tYXAoKGU9PmUudHlwZSkpLmZvckVhY2goKGU9PntzLmhhcyhlKXx8cy5kZWxldGUoZSl9KSksci5mb3JFYWNoKChlPT5PYmplY3QudmFsdWVzKGUpLm1hcCgoZT0+ZS50eXBlKSkuZm9yRWFjaCgodD0+e2lmKCFzLmhhcyh0KSlyZXR1cm4gbi5wdXNoKCJpbnZhbGlkIG1pbWV0eXBlIiksZC5kZWxldGUoZS5uYW1lKX0pKSkpLHt2YWxpZFBsdWdpbnM6ci5maWx0ZXIoKGU9PmQuaGFzKGUubmFtZSkpKSx2YWxpZE1pbWVUeXBlczppLmZpbHRlcigoZT0+cy5oYXMoZS50eXBlKSkpLGxpZXM6Wy4uLm5ldyBTZXQobildfX0pKGUsbmF2aWdhdG9yLm1pbWVUeXBlcyk7cmV0dXJuIGEubGVuZ3RoJiYobj0hMCxhLmZvckVhY2goKGU9Pk8oIk5hdmlnYXRvci5wbHVnaW5zIixlKSkpKSx0Lmxlbmd0aCYmdC5mb3JFYWNoKChlPT57Y29uc3R7bmFtZTp0LGRlc2NyaXB0aW9uOm59PWUsYT1zZSh0KSxvPXNlKG4pO2EubGVuZ3RoJiZtZSgicGx1Z2luIG5hbWUgaXMgZ2liYmVyaXNoIix0KSxvLmxlbmd0aCYmbWUoInBsdWdpbiBkZXNjcmlwdGlvbiBpcyBnaWJiZXJpc2giLG4pfSkpLHR9KSwicGx1Z2lucyBmYWlsZWQiKSxwcm9wZXJ0aWVzOk4oKCgpPT5PYmplY3Qua2V5cyhPYmplY3QuZ2V0UHJvdG90eXBlT2YobmF2aWdhdG9yKSkpLCJuYXZpZ2F0b3Iga2V5cyBmYWlsZWQiKX0scj0oKT0+TigoKCk9PntpZihuYXZpZ2F0b3IudXNlckFnZW50RGF0YSYmbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuZ2V0SGlnaEVudHJvcHlWYWx1ZXMpcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnREYXRhLmdldEhpZ2hFbnRyb3B5VmFsdWVzKFsicGxhdGZvcm0iLCJwbGF0Zm9ybVZlcnNpb24iLCJhcmNoaXRlY3R1cmUiLCJiaXRuZXNzIiwibW9kZWwiLCJ1YUZ1bGxWZXJzaW9uIl0pLnRoZW4oKGU9Pntjb25zdHticmFuZHM6dCxtb2JpbGU6bn09bmF2aWdhdG9yLnVzZXJBZ2VudERhdGF8fHt9LGE9KGUsdD0hMSk9PmUuZmlsdGVyKChlPT4hL05vdC8udGVzdChlLmJyYW5kKSkpLm1hcCgoZT0+YCR7ZS5icmFuZH0ke3Q/YCAke2UudmVyc2lvbn1gOiIifWApKSxvPWU9PmUubGVuZ3RoPjE/ZS5maWx0ZXIoKGU9PiEvQ2hyb21pdW0vLnRlc3QoZSkpKTplO2UuYnJhbmRzfHwoZS5icmFuZHM9dCksZS5icmFuZHNWZXJzaW9uPWEoZS5icmFuZHMsITApLGUuYnJhbmRzPWEoZS5icmFuZHMpLGUuYnJhbmRzVmVyc2lvbj1vKGUuYnJhbmRzVmVyc2lvbiksZS5icmFuZHM9byhlLmJyYW5kcyksZS5tb2JpbGV8fChlLm1vYmlsZT1uKTtyZXR1cm4gT2JqZWN0LmtleXMoZSkuc29ydCgpLnJlZHVjZSgoKHQsbik9Pih0W25dPWVbbl0sdCkpLHt9KX0pKX0pLCJ1c2VyQWdlbnREYXRhIGZhaWxlZCIpLGk9KCk9Pk4oKCgpPT57aWYoImJsdWV0b290aCJpbiBuYXZpZ2F0b3ImJm5hdmlnYXRvci5ibHVldG9vdGgmJm5hdmlnYXRvci5ibHVldG9vdGguZ2V0QXZhaWxhYmlsaXR5KXJldHVybiBuYXZpZ2F0b3IuYmx1ZXRvb3RoLmdldEF2YWlsYWJpbGl0eSgpfSksImJsdWV0b290aEF2YWlsYWJpbGl0eSBmYWlsZWQiKSxjPSgpPT5OKCgoKT0+e2NvbnN0IGU9ZT0+bmF2aWdhdG9yLnBlcm1pc3Npb25zLnF1ZXJ5KHtuYW1lOmV9KS50aGVuKCh0PT4oe25hbWU6ZSxzdGF0ZTp0LnN0YXRlfSkpKS5jYXRjaCgodD0+KHtuYW1lOmUsc3RhdGU6InVua25vd24ifSkpKTtyZXR1cm4icGVybWlzc2lvbnMiaW4gbmF2aWdhdG9yP1Byb21pc2UuYWxsKFtlKCJhY2NlbGVyb21ldGVyIiksZSgiYW1iaWVudC1saWdodC1zZW5zb3IiKSxlKCJiYWNrZ3JvdW5kLWZldGNoIiksZSgiYmFja2dyb3VuZC1zeW5jIiksZSgiYmx1ZXRvb3RoIiksZSgiY2FtZXJhIiksZSgiY2xpcGJvYXJkIiksZSgiZGV2aWNlLWluZm8iKSxlKCJkaXNwbGF5LWNhcHR1cmUiKSxlKCJnYW1lcGFkIiksZSgiZ2VvbG9jYXRpb24iKSxlKCJneXJvc2NvcGUiKSxlKCJtYWduZXRvbWV0ZXIiKSxlKCJtaWNyb3Bob25lIiksZSgibWlkaSIpLGUoIm5mYyIpLGUoIm5vdGlmaWNhdGlvbnMiKSxlKCJwZXJzaXN0ZW50LXN0b3JhZ2UiKSxlKCJwdXNoIiksZSgic2NyZWVuLXdha2UtbG9jayIpLGUoInNwZWFrZXIiKSxlKCJzcGVha2VyLXNlbGVjdGlvbiIpXSkudGhlbigoZT0+ZS5yZWR1Y2UoKChlLHQpPT57Y29uc3R7c3RhdGU6bixuYW1lOmF9PXR8fHt9O3JldHVybiBlW25dPyhlW25dLnB1c2goYSksZSk6KGVbbl09W2FdLGUpfSkse30pKSkuY2F0Y2goKGU9PmNvbnNvbGUuZXJyb3IoZSkpKTp2b2lkIDB9KSwicGVybWlzc2lvbnMgZmFpbGVkIiksbD0oKT0+TigoKCk9PntpZigiZ3B1ImluIG5hdmlnYXRvcilyZXR1cm4gbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpLnRoZW4oKCh7bGltaXRzOmUsZmVhdHVyZXM6dH0pPT4oe2ZlYXR1cmVzOlsuLi50LnZhbHVlcygpXSxsaW1pdHM6KGU9Pntjb25zdCB0PXt9O2Zvcihjb25zdCBuIGluIGUpdFtuXT1lW25dO3JldHVybiB0fSkoZSl9KSkpfSksIndlYmdwdSBmYWlsZWQiKTtyZXR1cm4gYXdhaXQgayh0KSxQcm9taXNlLmFsbChbcigpLGkoKSxjKCksbCgpXSkudGhlbigoKFtlLGEscixpXSk9PihFKHt0aW1lOnQuc3RvcCgpLHRlc3Q6Im5hdmlnYXRvciIscGFzc2VkOiEwfSksey4uLm8sdXNlckFnZW50RGF0YTplLGJsdWV0b290aEF2YWlsYWJpbGl0eTphLHBlcm1pc3Npb25zOnIsd2ViZ3B1OmksbGllZDpufSkpKS5jYXRjaCgoZT0+KGNvbnNvbGUuZXJyb3IoZSksRSh7dGltZTp0LnN0b3AoKSx0ZXN0OiJuYXZpZ2F0b3IiLHBhc3NlZDohMH0pLHsuLi5vLGxpZWQ6bn0pKSl9Y2F0Y2goZSl7cmV0dXJuIEUoe3Rlc3Q6Im5hdmlnYXRvciIscGFzc2VkOiExfSksdm9pZCBSKGUsIk5hdmlnYXRvciBmYWlsZWQgb3IgYmxvY2tlZCBieSBjbGllbnQiKX19YXN5bmMgZnVuY3Rpb24gJGUoKXt0cnl7Y29uc3QgZT13KCk7YXdhaXQgayhlKTtjb25zdCB0PXtwcml2YWN5OnZvaWQgMCxzZWN1cml0eTp2b2lkIDAsbW9kZTp2b2lkIDAsZXh0ZW5zaW9uOnZvaWQgMCxlbmdpbmU6bj8iQmxpbmsiOmE/IkdlY2tvIjoiIn0sbz1lPT5uZXcgUmVnRXhwKGAke2V9KyRgKSxyPShlLHQsbik9Pm5ldyBQcm9taXNlKChhPT5zZXRUaW1lb3V0KCgoKT0+e2NvbnN0IGU9bnx8K25ldyBEYXRlLHI9byh0KS50ZXN0KGUpP28odCkuZXhlYyhlKVswXTplO3JldHVybiBhKHIpfSksZSkpKSxpPWFzeW5jKCk9Pntjb25zdCBlPStuZXcgRGF0ZSx0PSsoIiIrZSkuc2xpY2UoLTEpLG49YXdhaXQgcigwLHQsZSksYT1hd2FpdCByKDEsdCksbz1hd2FpdCByKDIsdCksaT1hd2FpdCByKDMsdCkscz1hd2FpdCByKDQsdCksYz1hd2FpdCByKDUsdCksbD1hd2FpdCByKDYsdCksZD1hd2FpdCByKDcsdCksbT1hd2FpdCByKDgsdCksdT1hd2FpdCByKDksdCksZz0oIiIrbikuc2xpY2UoLTEpLHA9KCIiK2EpLnNsaWNlKC0xKSxoPSgiIitvKS5zbGljZSgtMSksYj0oIiIraSkuc2xpY2UoLTEpLGY9KCIiK3MpLnNsaWNlKC0xKSxTPSgiIitjKS5zbGljZSgtMSkseT0oIiIrbCkuc2xpY2UoLTEpLEU9KCIiK2QpLnNsaWNlKC0xKSx3PSgiIittKS5zbGljZSgtMSksaz0oIiIrdSkuc2xpY2UoLTEpLHY9Zz09cCYmZz09aCYmZz09YiYmZz09ZiYmZz09UyYmZz09eSYmZz09RSYmZz09dyYmZz09ayxBPSgiIituKS5sZW5ndGgsRD1bbixhLG8saSxzLGMsbCxkLG0sdV07cmV0dXJue3Byb3RlY3Rpb246dixkZWxheXM6RC5tYXAoKGU9PigiIitlKS5sZW5ndGg+QT8oIiIrZSkuc2xpY2UoLUEpOmUpKSxwcmVjaXNpb246dj9NYXRoLm1pbiguLi5ELm1hcCgoZT0+KCIiK2UpLmxlbmd0aCkpKTp2b2lkIDAscHJlY2lzaW9uVmFsdWU6dj9nOnZvaWQgMH19LFtsLGRdPWF3YWl0IFByb21pc2UuYWxsKFtzKCksbj92b2lkIDA6aSgpXSk7aWYobCl7Y29uc3QgZT1jKCk7dC5wcml2YWN5PSJCcmF2ZSIsdC5zZWN1cml0eT17RmlsZVN5c3RlbVdyaXRhYmxlRmlsZVN0cmVhbToiRmlsZVN5c3RlbVdyaXRhYmxlRmlsZVN0cmVhbSJpbiB3aW5kb3csU2VyaWFsOiJTZXJpYWwiaW4gd2luZG93LFJlcG9ydGluZ09ic2VydmVyOiJSZXBvcnRpbmdPYnNlcnZlciJpbiB3aW5kb3d9LHQubW9kZT1lLmFsbG93PyJhbGxvdyI6ZS5zdGFuZGFyZD8ic3RhbmRhcmQiOmUuc3RyaWN0PyJzdHJpY3QiOiIifWNvbnN0e3Byb3RlY3Rpb246bX09ZHx8e307aWYoYSYmbSl7Y29uc3QgZT17T2ZmbGluZUF1ZGlvQ29udGV4dDoiT2ZmbGluZUF1ZGlvQ29udGV4dCJpbiB3aW5kb3csV2ViR0wyUmVuZGVyaW5nQ29udGV4dDoiV2ViR0wyUmVuZGVyaW5nQ29udGV4dCJpbiB3aW5kb3csV2ViQXNzZW1ibHk6IldlYkFzc2VtYmx5ImluIHdpbmRvdyxtYXhUb3VjaFBvaW50czoibWF4VG91Y2hQb2ludHMiaW4gbmF2aWdhdG9yLFJUQ1J0cFRyYW5zY2VpdmVyOiJSVENSdHBUcmFuc2NlaXZlciJpbiB3aW5kb3csTWVkaWFEZXZpY2VzOiJNZWRpYURldmljZXMiaW4gd2luZG93LENyZWRlbnRpYWw6IkNyZWRlbnRpYWwiaW4gd2luZG93fSxuPU9iamVjdC5rZXlzKGUpLGE9bmV3IFNldChbIlJUQ1J0cFRyYW5zY2VpdmVyIiwiTWVkaWFEZXZpY2VzIiwiQ3JlZGVudGlhbCJdKSxvPW4uZmlsdGVyKCh0PT5hLmhhcyh0KSYmIWVbdF0pKS5sZW5ndGg9PWEuc2l6ZSxyPSFlLldlYkFzc2VtYmx5O3QucHJpdmFjeT1vPyJUb3IgQnJvd3NlciI6IkZpcmVmb3giLHQuc2VjdXJpdHk9e3JlZHVjZVRpbWVyUHJlY2lzaW9uOiEwLC4uLmV9LHQubW9kZT1vP3I/InNhZmVyIjoic3RhbmRhcmQiOiJyZXNpc3RGaW5nZXJwcmludGluZyJ9Y29uc3QgdT1PYmplY3Qua2V5cyhvZSkubGVuZ3RoLGc9ImM3Njc3MTJiIixwPXtub3NjcmlwdDp7Y29udGVudERvY3VtZW50SGFzaDpbIjBiNjM3YTMzIiwiMzdlMmYzMmUiLCIzMTgzOTBkMSJdLGNvbnRlbnRXaW5kb3dIYXNoOlsiMGI2MzdhMzMiLCIzN2UyZjMyZSIsIjMxODM5MGQxIl0sZ2V0Q29udGV4dEhhc2g6WyIwYjYzN2EzMyIsIjA4MWQ2ZDFiIixnXX0sdHJhY2U6e2NvbnRlbnREb2N1bWVudEhhc2g6WyJjYTlkOWMyZiJdLGNvbnRlbnRXaW5kb3dIYXNoOlsiY2E5ZDljMmYiXSxjcmVhdGVFbGVtZW50SGFzaDpbIjc3ZGVhODM0Il0sZ2V0RWxlbWVudEJ5SWRIYXNoOlsiNzdkZWE4MzQiXSxnZXRJbWFnZURhdGFIYXNoOlsiNzdkZWE4MzQiXSx0b0Jsb2JIYXNoOlsiNzdkZWE4MzQiLGddLHRvRGF0YVVSTEhhc2g6WyI3N2RlYTgzNCIsZ119LGN5ZGVjOntjb250ZW50RG9jdW1lbnRIYXNoOlsiOTQ1YjBjNzgiLCIxNTc3MWVmYSIsIjQwM2ExYTIxIiwiNTVlOWI5NTkiXSxjb250ZW50V2luZG93SGFzaDpbIjk0NWIwYzc4IiwiMTU3NzFlZmEiLCI0MDNhMWEyMSIsIjU1ZTliOTU5Il0sY3JlYXRlRWxlbWVudEhhc2g6WyIzZGQ4NmQ2ZiIsImNjN2NiNTk4IiwiNDIzN2I0NGMiLCIxNDY2YWFmMCIsIjBjYjBjNjgyIiwiNzNjNjYyZDkiLCI3MmIxZWUyYiIsImFlM2QwMmM5Il0sZ2V0RWxlbWVudEJ5SWRIYXNoOlsiM2RkODZkNmYiLCJjYzdjYjU5OCIsIjQyMzdiNDRjIiwiMTQ2NmFhZjAiLCIwY2IwYzY4MiIsIjczYzY2MmQ5IiwiNzJiMWVlMmIiLCJhZTNkMDJjOSJdLGdldEltYWdlRGF0YUhhc2g6WyIwNDRmMTRjMiIsImRiNjBkN2Y5IiwiMTU3NzFlZmEiLCJkYjYwZDdmOSIsIjU1ZTliOTU5Il0sdG9CbG9iSGFzaDpbIjA0NGYxNGMyIiwiMTU3NzFlZmEiLCJhZmVjMzQ4ZCIsIjU1ZTliOTU5IiwiMGRiYmY0NTYiXSx0b0RhdGFVUkxIYXNoOlsiZWNiNDk4ZDkiLCIxNTc3MWVmYSIsIjZiODM4ZmI2IiwiZDE5MTA0ZWMiLCI2OTg1ZDMxNSIsIjU1ZTliOTU5IiwiZmU4ODI1OWYiXX0sY2FudmFzYmxvY2tlcjp7Y29udGVudERvY3VtZW50SGFzaDpbIjk4ZWM4NThlIiwiZGJiYWYzMWYiXSxjb250ZW50V2luZG93SGFzaDpbIjk4ZWM4NThlIiwiZGJiYWYzMWYiXSxhcHBlbmRIYXNoOlsiOThlYzg1OGUiLCJkYmJhZjMxZiJdLGdldEltYWdlRGF0YUhhc2g6WyI5OGVjODU4ZSIsImEyOTcxODg4IiwiZGJiYWYzMWYiLGddLHRvQmxvYkhhc2g6WyI5ZjFjM2RmZSIsImEyOTcxODg4IiwiZGJiYWYzMWYiLGddLHRvRGF0YVVSTEhhc2g6WyI5OGVjODU4ZSIsImEyOTcxODg4IiwiZGJiYWYzMWYiLGddfSxjaGFtZWxlb246e2FwcGVuZEhhc2g6WyI3N2RlYTgzNCJdLGluc2VydEFkamFjZW50RWxlbWVudEhhc2g6WyI3N2RlYTgzNCJdLGluc2VydEFkamFjZW50SFRNTEhhc2g6WyI3N2RlYTgzNCJdLGluc2VydEFkamFjZW50VGV4dEhhc2g6WyI3N2RlYTgzNCJdLHByZXBlbmRIYXNoOlsiNzdkZWE4MzQiXSxyZXBsYWNlV2l0aEhhc2g6WyI3N2RlYTgzNCJdLGFwcGVuZENoaWxkSGFzaDpbIjc3ZGVhODM0Il0saW5zZXJ0QmVmb3JlSGFzaDpbIjc3ZGVhODM0Il0scmVwbGFjZUNoaWxkSGFzaDpbIjc3ZGVhODM0Il19LGR1Y2tkdWNrZ286e3RvRGF0YVVSTEhhc2g6WyJmZDAwYmY1ZCIsIjhlZTdkZjIyIixnXSx0b0Jsb2JIYXNoOlsiZmQwMGJmNWQiLCI4ZWU3ZGYyMiIsZ10sZ2V0SW1hZ2VEYXRhSGFzaDpbImZkMDBiZjVkIiwiOGVlN2RmMjIiLGddLGdldEJ5dGVGcmVxdWVuY3lEYXRhSGFzaDpbImZkMDBiZjVkIiwiOGVlN2RmMjIiLGddLGdldEJ5dGVUaW1lRG9tYWluRGF0YUhhc2g6WyJmZDAwYmY1ZCIsIjhlZTdkZjIyIixnXSxnZXRGbG9hdEZyZXF1ZW5jeURhdGFIYXNoOlsiZmQwMGJmNWQiLCI4ZWU3ZGYyMiIsZ10sZ2V0RmxvYXRUaW1lRG9tYWluRGF0YUhhc2g6WyJmZDAwYmY1ZCIsIjhlZTdkZjIyIixnXSxjb3B5RnJvbUNoYW5uZWxIYXNoOlsiZmQwMGJmNWQiLCI4ZWU3ZGYyMiIsZ10sZ2V0Q2hhbm5lbERhdGFIYXNoOlsiZmQwMGJmNWQiLCI4ZWU3ZGYyMiIsZ10saGFyZHdhcmVDb25jdXJyZW5jeUhhc2g6WyJkZmQ0MWFiNCJdLGF2YWlsSGVpZ2h0SGFzaDpbImRmZDQxYWI0Il0sYXZhaWxMZWZ0SGFzaDpbImRmZDQxYWI0Il0sYXZhaWxUb3BIYXNoOlsiZGZkNDFhYjQiXSxhdmFpbFdpZHRoSGFzaDpbImRmZDQxYWI0Il0sY29sb3JEZXB0aEhhc2g6WyJkZmQ0MWFiNCJdLHBpeGVsRGVwdGhIYXNoOlsiZGZkNDFhYjQiXX0scHJpdmFjeWJhZGdlcjp7Z2V0SW1hZ2VEYXRhSGFzaDpbIjBjYjBjNjgyIl0sdG9EYXRhVVJMSGFzaDpbIjBjYjBjNjgyIl19LHByaXZhY3lwb3NzdW06e2hhcmR3YXJlQ29uY3VycmVuY3lIYXNoOlsiNDUyOTI0ZDUiXSxhdmFpbFdpZHRoSGFzaDpbIjQ1MjkyNGQ1Il0sY29sb3JEZXB0aEhhc2g6WyI0NTI5MjRkNSJdfSxqc2hlbHRlcjp7Y29udGVudERvY3VtZW50SGFzaDpbIjAwMDdhYjRlIiwiMGI2MzdhMzMiLCI4NjZmYTdlNyIsIjMxODM5MGQxIl0sY29udGVudFdpbmRvd0hhc2g6WyIwMDA3YWI0ZSIsIjBiNjM3YTMzIiwiODY2ZmE3ZTciLCIzMTgzOTBkMSJdLGFwcGVuZEhhc2g6WyIwMDA3YWI0ZSIsIjBiNjM3YTMzIiwiODY2ZmE3ZTciLCIzMTgzOTBkMSJdLGluc2VydEFkamFjZW50RWxlbWVudEhhc2g6WyIwMDA3YWI0ZSIsIjBiNjM3YTMzIiwiODY2ZmE3ZTciLCIzMTgzOTBkMSJdLGluc2VydEFkamFjZW50SFRNTEhhc2g6WyIwMDA3YWI0ZSIsIjBiNjM3YTMzIiwiODY2ZmE3ZTciLCIzMTgzOTBkMSJdLHByZXBlbmRIYXNoOlsiMDAwN2FiNGUiLCIwYjYzN2EzMyIsIjg2NmZhN2U3IiwiMzE4MzkwZDEiXSxyZXBsYWNlV2l0aEhhc2g6WyIwMDA3YWI0ZSIsIjBiNjM3YTMzIiwiODY2ZmE3ZTciLCIzMTgzOTBkMSJdLGFwcGVuZENoaWxkSGFzaDpbIjAwMDdhYjRlIiwiMGI2MzdhMzMiLCI4NjZmYTdlNyIsIjMxODM5MGQxIl0saW5zZXJ0QmVmb3JlSGFzaDpbIjAwMDdhYjRlIiwiMGI2MzdhMzMiLCI4NjZmYTdlNyIsIjMxODM5MGQxIl0scmVwbGFjZUNoaWxkSGFzaDpbIjAwMDdhYjRlIiwiMGI2MzdhMzMiLCI4NjZmYTdlNyIsIjMxODM5MGQxIl0saGFyZHdhcmVDb25jdXJyZW5jeUhhc2g6WyJkZmQ0MWFiNCJdfSxwdXBwZXRlZXJFeHRyYTp7Y29udGVudERvY3VtZW50SGFzaDpbIjU1ZTliOTU5Il0sY29udGVudFdpbmRvd0hhc2g6WyI1NWU5Yjk1OSIsIjUwYTI4MWI1Il0sY3JlYXRlRWxlbWVudEhhc2g6WyI1NWU5Yjk1OSJdLGdldEVsZW1lbnRCeUlkSGFzaDpbIjU1ZTliOTU5Il0sYXBwZW5kSGFzaDpbIjU1ZTliOTU5Il0saW5zZXJ0QWRqYWNlbnRFbGVtZW50SGFzaDpbIjU1ZTliOTU5Il0saW5zZXJ0QWRqYWNlbnRIVE1MSGFzaDpbIjU1ZTliOTU5Il0saW5zZXJ0QWRqYWNlbnRUZXh0SGFzaDpbIjU1ZTliOTU5Il0scHJlcGVuZEhhc2g6WyI1NWU5Yjk1OSJdLHJlcGxhY2VXaXRoSGFzaDpbIjU1ZTliOTU5Il0sYXBwZW5kQ2hpbGRIYXNoOlsiNTVlOWI5NTkiXSxpbnNlcnRCZWZvcmVIYXNoOlsiNTVlOWI5NTkiXSxyZXBsYWNlQ2hpbGRIYXNoOlsiNTVlOWI5NTkiXSxnZXRDb250ZXh0SGFzaDpbIjU1ZTliOTU5IixnXSx0b0RhdGFVUkxIYXNoOlsiNTVlOWI5NTkiLGddLHRvQmxvYkhhc2g6WyI1NWU5Yjk1OSIsZ10sZ2V0SW1hZ2VEYXRhSGFzaDpbIjU1ZTliOTU5Il0saGFyZHdhcmVDb25jdXJyZW5jeUhhc2g6WyJlZmJkNGNmOSIsImE2MzQ5MWZiIiwiYjAxMWZkMWMiLCIxOTRlY2YxNyIsIjU1ZTliOTU5Il19LGZha2VCcm93c2VyOnthcHBlbmRDaGlsZEhhc2g6WyI4ZGZlYzJlYyIsImY0M2U2MTM0Il0sZ2V0Q29udGV4dEhhc2g6WyI4M2I4MjVhYiIsImE2MzQ5MWZiIl0sdG9EYXRhVVJMSGFzaDpbIjgzYjgyNWFiIiwiYTYzNDkxZmIiXSx0b0Jsb2JIYXNoOlsiODNiODI1YWIiLCJhNjM0OTFmYiJdLGdldEltYWdlRGF0YUhhc2g6WyI4M2I4MjVhYiIsImE2MzQ5MWZiIl0saGFyZHdhcmVDb25jdXJyZW5jeUhhc2g6WyI4M2I4MjVhYiIsImE2MzQ5MWZiIl0sYXZhaWxIZWlnaHRIYXNoOlsiODNiODI1YWIiLCJhNjM0OTFmYiJdLGF2YWlsTGVmdEhhc2g6WyI4M2I4MjVhYiIsImE2MzQ5MWZiIl0sYXZhaWxUb3BIYXNoOlsiODNiODI1YWIiLCJhNjM0OTFmYiJdLGF2YWlsV2lkdGhIYXNoOlsiODNiODI1YWIiLCJhNjM0OTFmYiJdLGNvbG9yRGVwdGhIYXNoOlsiODNiODI1YWIiLCJhNjM0OTFmYiJdLHBpeGVsRGVwdGhIYXNoOlsiODNiODI1YWIiLCJhNjM0OTFmYiJdfX07YXdhaXQgayhlKTtjb25zdCBoPXtjb250ZW50RG9jdW1lbnRIYXNoOndlKG9lWyJIVE1MSUZyYW1lRWxlbWVudC5jb250ZW50RG9jdW1lbnQiXSksY29udGVudFdpbmRvd0hhc2g6d2Uob2VbIkhUTUxJRnJhbWVFbGVtZW50LmNvbnRlbnRXaW5kb3ciXSksY3JlYXRlRWxlbWVudEhhc2g6d2Uob2VbIkRvY3VtZW50LmNyZWF0ZUVsZW1lbnQiXSksZ2V0RWxlbWVudEJ5SWRIYXNoOndlKG9lWyJEb2N1bWVudC5nZXRFbGVtZW50QnlJZCJdKSxhcHBlbmRIYXNoOndlKG9lWyJFbGVtZW50LmFwcGVuZCJdKSxpbnNlcnRBZGphY2VudEVsZW1lbnRIYXNoOndlKG9lWyJFbGVtZW50Lmluc2VydEFkamFjZW50RWxlbWVudCJdKSxpbnNlcnRBZGphY2VudEhUTUxIYXNoOndlKG9lWyJFbGVtZW50Lmluc2VydEFkamFjZW50SFRNTCJdKSxpbnNlcnRBZGphY2VudFRleHRIYXNoOndlKG9lWyJFbGVtZW50Lmluc2VydEFkamFjZW50VGV4dCJdKSxwcmVwZW5kSGFzaDp3ZShvZVsiRWxlbWVudC5wcmVwZW5kIl0pLHJlcGxhY2VXaXRoSGFzaDp3ZShvZVsiRWxlbWVudC5yZXBsYWNlV2l0aCJdKSxhcHBlbmRDaGlsZEhhc2g6d2Uob2VbIk5vZGUuYXBwZW5kQ2hpbGQiXSksaW5zZXJ0QmVmb3JlSGFzaDp3ZShvZVsiTm9kZS5pbnNlcnRCZWZvcmUiXSkscmVwbGFjZUNoaWxkSGFzaDp3ZShvZVsiTm9kZS5yZXBsYWNlQ2hpbGQiXSksZ2V0Q29udGV4dEhhc2g6d2Uob2VbIkhUTUxDYW52YXNFbGVtZW50LmdldENvbnRleHQiXSksdG9EYXRhVVJMSGFzaDp3ZShvZVsiSFRNTENhbnZhc0VsZW1lbnQudG9EYXRhVVJMIl0pLHRvQmxvYkhhc2g6d2Uob2VbIkhUTUxDYW52YXNFbGVtZW50LnRvQmxvYiJdKSxnZXRJbWFnZURhdGFIYXNoOndlKG9lWyJDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuZ2V0SW1hZ2VEYXRhIl0pLGdldEJ5dGVGcmVxdWVuY3lEYXRhSGFzaDp3ZShvZVsiQW5hbHlzZXJOb2RlLmdldEJ5dGVGcmVxdWVuY3lEYXRhIl0pLGdldEJ5dGVUaW1lRG9tYWluRGF0YUhhc2g6d2Uob2VbIkFuYWx5c2VyTm9kZS5nZXRCeXRlVGltZURvbWFpbkRhdGEiXSksZ2V0RmxvYXRGcmVxdWVuY3lEYXRhSGFzaDp3ZShvZVsiQW5hbHlzZXJOb2RlLmdldEZsb2F0RnJlcXVlbmN5RGF0YSJdKSxnZXRGbG9hdFRpbWVEb21haW5EYXRhSGFzaDp3ZShvZVsiQW5hbHlzZXJOb2RlLmdldEZsb2F0VGltZURvbWFpbkRhdGEiXSksY29weUZyb21DaGFubmVsSGFzaDp3ZShvZVsiQXVkaW9CdWZmZXIuY29weUZyb21DaGFubmVsIl0pLGdldENoYW5uZWxEYXRhSGFzaDp3ZShvZVsiQXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEiXSksaGFyZHdhcmVDb25jdXJyZW5jeUhhc2g6d2Uob2VbIk5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5Il0pLGF2YWlsSGVpZ2h0SGFzaDp3ZShvZVsiU2NyZWVuLmF2YWlsSGVpZ2h0Il0pLGF2YWlsTGVmdEhhc2g6d2Uob2VbIlNjcmVlbi5hdmFpbExlZnQiXSksYXZhaWxUb3BIYXNoOndlKG9lWyJTY3JlZW4uYXZhaWxUb3AiXSksYXZhaWxXaWR0aEhhc2g6d2Uob2VbIlNjcmVlbi5hdmFpbFdpZHRoIl0pLGNvbG9yRGVwdGhIYXNoOndlKG9lWyJTY3JlZW4uY29sb3JEZXB0aCJdKSxwaXhlbERlcHRoSGFzaDp3ZShvZVsiU2NyZWVuLnBpeGVsRGVwdGgiXSl9O3QuZXh0ZW5zaW9uSGFzaFBhdHRlcm49T2JqZWN0LmtleXMoaCkucmVkdWNlKCgoZSx0KT0+e2NvbnN0IG49aFt0XTtyZXR1cm4gbj09Z3x8KGVbdC5yZXBsYWNlKCJIYXNoIiwiIildPW4pLGV9KSx7fSk7Y29uc3QgYj0oe3BhdHRlcm46ZSxoYXNoOnQscHJvdG90eXBlTGllc0xlbjpufSk9Pntjb25zdHtub3NjcmlwdDphLHRyYWNlOm8sY3lkZWM6cixjYW52YXNibG9ja2VyOmksY2hhbWVsZW9uOnMsZHVja2R1Y2tnbzpjLHByaXZhY3liYWRnZXI6bCxwcml2YWN5cG9zc3VtOmQsanNoZWx0ZXI6bSxwdXBwZXRlZXJFeHRyYTp1LGZha2VCcm93c2VyOmd9PWU7aWYobilyZXR1cm4gbj49NyYmby5jb250ZW50RG9jdW1lbnRIYXNoLmluY2x1ZGVzKHQuY29udGVudERvY3VtZW50SGFzaCkmJm8uY29udGVudFdpbmRvd0hhc2guaW5jbHVkZXModC5jb250ZW50V2luZG93SGFzaCkmJm8uY3JlYXRlRWxlbWVudEhhc2guaW5jbHVkZXModC5jcmVhdGVFbGVtZW50SGFzaCkmJm8uZ2V0RWxlbWVudEJ5SWRIYXNoLmluY2x1ZGVzKHQuZ2V0RWxlbWVudEJ5SWRIYXNoKSYmby50b0RhdGFVUkxIYXNoLmluY2x1ZGVzKHQudG9EYXRhVVJMSGFzaCkmJm8udG9CbG9iSGFzaC5pbmNsdWRlcyh0LnRvQmxvYkhhc2gpJiZvLmdldEltYWdlRGF0YUhhc2guaW5jbHVkZXModC5nZXRJbWFnZURhdGFIYXNoKT8iVHJhY2UiOm4+PTcmJnIuY29udGVudERvY3VtZW50SGFzaC5pbmNsdWRlcyh0LmNvbnRlbnREb2N1bWVudEhhc2gpJiZyLmNvbnRlbnRXaW5kb3dIYXNoLmluY2x1ZGVzKHQuY29udGVudFdpbmRvd0hhc2gpJiZyLmNyZWF0ZUVsZW1lbnRIYXNoLmluY2x1ZGVzKHQuY3JlYXRlRWxlbWVudEhhc2gpJiZyLmdldEVsZW1lbnRCeUlkSGFzaC5pbmNsdWRlcyh0LmdldEVsZW1lbnRCeUlkSGFzaCkmJnIudG9EYXRhVVJMSGFzaC5pbmNsdWRlcyh0LnRvRGF0YVVSTEhhc2gpJiZyLnRvQmxvYkhhc2guaW5jbHVkZXModC50b0Jsb2JIYXNoKSYmci5nZXRJbWFnZURhdGFIYXNoLmluY2x1ZGVzKHQuZ2V0SW1hZ2VEYXRhSGFzaCk/IkN5RGVjIjpuPj02JiZpLmNvbnRlbnREb2N1bWVudEhhc2guaW5jbHVkZXModC5jb250ZW50RG9jdW1lbnRIYXNoKSYmaS5jb250ZW50V2luZG93SGFzaC5pbmNsdWRlcyh0LmNvbnRlbnRXaW5kb3dIYXNoKSYmaS5hcHBlbmRIYXNoLmluY2x1ZGVzKHQuYXBwZW5kSGFzaCkmJmkudG9EYXRhVVJMSGFzaC5pbmNsdWRlcyh0LnRvRGF0YVVSTEhhc2gpJiZpLnRvQmxvYkhhc2guaW5jbHVkZXModC50b0Jsb2JIYXNoKSYmaS5nZXRJbWFnZURhdGFIYXNoLmluY2x1ZGVzKHQuZ2V0SW1hZ2VEYXRhSGFzaCk/IkNhbnZhc0Jsb2NrZXIiOm4+PTkmJnMuYXBwZW5kSGFzaC5pbmNsdWRlcyh0LmFwcGVuZEhhc2gpJiZzLmluc2VydEFkamFjZW50RWxlbWVudEhhc2guaW5jbHVkZXModC5pbnNlcnRBZGphY2VudEVsZW1lbnRIYXNoKSYmcy5pbnNlcnRBZGphY2VudEhUTUxIYXNoLmluY2x1ZGVzKHQuaW5zZXJ0QWRqYWNlbnRIVE1MSGFzaCkmJnMuaW5zZXJ0QWRqYWNlbnRUZXh0SGFzaC5pbmNsdWRlcyh0Lmluc2VydEFkamFjZW50VGV4dEhhc2gpJiZzLnByZXBlbmRIYXNoLmluY2x1ZGVzKHQucHJlcGVuZEhhc2gpJiZzLnJlcGxhY2VXaXRoSGFzaC5pbmNsdWRlcyh0LnJlcGxhY2VXaXRoSGFzaCkmJnMuYXBwZW5kQ2hpbGRIYXNoLmluY2x1ZGVzKHQuYXBwZW5kQ2hpbGRIYXNoKSYmcy5pbnNlcnRCZWZvcmVIYXNoLmluY2x1ZGVzKHQuaW5zZXJ0QmVmb3JlSGFzaCkmJnMucmVwbGFjZUNoaWxkSGFzaC5pbmNsdWRlcyh0LnJlcGxhY2VDaGlsZEhhc2gpPyJDaGFtZWxlb24iOm4+PTcmJmMudG9EYXRhVVJMSGFzaC5pbmNsdWRlcyh0LnRvRGF0YVVSTEhhc2gpJiZjLnRvQmxvYkhhc2guaW5jbHVkZXModC50b0Jsb2JIYXNoKSYmYy5nZXRJbWFnZURhdGFIYXNoLmluY2x1ZGVzKHQuZ2V0SW1hZ2VEYXRhSGFzaCkmJmMuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGFIYXNoLmluY2x1ZGVzKHQuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGFIYXNoKSYmYy5nZXRCeXRlVGltZURvbWFpbkRhdGFIYXNoLmluY2x1ZGVzKHQuZ2V0Qnl0ZVRpbWVEb21haW5EYXRhSGFzaCkmJmMuZ2V0RmxvYXRGcmVxdWVuY3lEYXRhSGFzaC5pbmNsdWRlcyh0LmdldEZsb2F0RnJlcXVlbmN5RGF0YUhhc2gpJiZjLmdldEZsb2F0VGltZURvbWFpbkRhdGFIYXNoLmluY2x1ZGVzKHQuZ2V0RmxvYXRUaW1lRG9tYWluRGF0YUhhc2gpJiZjLmNvcHlGcm9tQ2hhbm5lbEhhc2guaW5jbHVkZXModC5jb3B5RnJvbUNoYW5uZWxIYXNoKSYmYy5nZXRDaGFubmVsRGF0YUhhc2guaW5jbHVkZXModC5nZXRDaGFubmVsRGF0YUhhc2gpJiZjLmhhcmR3YXJlQ29uY3VycmVuY3lIYXNoLmluY2x1ZGVzKHQuaGFyZHdhcmVDb25jdXJyZW5jeUhhc2gpJiZjLmF2YWlsSGVpZ2h0SGFzaC5pbmNsdWRlcyh0LmF2YWlsSGVpZ2h0SGFzaCkmJmMuYXZhaWxMZWZ0SGFzaC5pbmNsdWRlcyh0LmF2YWlsTGVmdEhhc2gpJiZjLmF2YWlsVG9wSGFzaC5pbmNsdWRlcyh0LmF2YWlsVG9wSGFzaCkmJmMuYXZhaWxXaWR0aEhhc2guaW5jbHVkZXModC5hdmFpbFdpZHRoSGFzaCkmJmMuY29sb3JEZXB0aEhhc2guaW5jbHVkZXModC5jb2xvckRlcHRoSGFzaCkmJmMucGl4ZWxEZXB0aEhhc2guaW5jbHVkZXModC5waXhlbERlcHRoSGFzaCk/IkR1Y2tEdWNrR28iOm4+PTImJmwuZ2V0SW1hZ2VEYXRhSGFzaC5pbmNsdWRlcyh0LmdldEltYWdlRGF0YUhhc2gpJiZsLnRvRGF0YVVSTEhhc2guaW5jbHVkZXModC50b0RhdGFVUkxIYXNoKT8iUHJpdmFjeSBCYWRnZXIiOm4+PTMmJmQuaGFyZHdhcmVDb25jdXJyZW5jeUhhc2guaW5jbHVkZXModC5oYXJkd2FyZUNvbmN1cnJlbmN5SGFzaCkmJmQuYXZhaWxXaWR0aEhhc2guaW5jbHVkZXModC5hdmFpbFdpZHRoSGFzaCkmJmQuY29sb3JEZXB0aEhhc2guaW5jbHVkZXModC5jb2xvckRlcHRoSGFzaCk/IlByaXZhY3kgUG9zc3VtIjpuPj0yJiZhLmNvbnRlbnREb2N1bWVudEhhc2guaW5jbHVkZXModC5jb250ZW50RG9jdW1lbnRIYXNoKSYmYS5jb250ZW50V2luZG93SGFzaC5pbmNsdWRlcyh0LmNvbnRlbnREb2N1bWVudEhhc2gpJiZhLmdldENvbnRleHRIYXNoLmluY2x1ZGVzKHQuZ2V0Q29udGV4dEhhc2gpJiYiYzc2NzcxMmIiPT10LmhhcmR3YXJlQ29uY3VycmVuY3lIYXNoPyJOb1NjcmlwdCI6bj49MTQmJm0uY29udGVudERvY3VtZW50SGFzaC5pbmNsdWRlcyh0LmNvbnRlbnREb2N1bWVudEhhc2gpJiZtLmNvbnRlbnRXaW5kb3dIYXNoLmluY2x1ZGVzKHQuY29udGVudERvY3VtZW50SGFzaCkmJm0uYXBwZW5kSGFzaC5pbmNsdWRlcyh0LmFwcGVuZEhhc2gpJiZtLmluc2VydEFkamFjZW50RWxlbWVudEhhc2guaW5jbHVkZXModC5pbnNlcnRBZGphY2VudEVsZW1lbnRIYXNoKSYmbS5pbnNlcnRBZGphY2VudEhUTUxIYXNoLmluY2x1ZGVzKHQuaW5zZXJ0QWRqYWNlbnRIVE1MSGFzaCkmJm0ucHJlcGVuZEhhc2guaW5jbHVkZXModC5wcmVwZW5kSGFzaCkmJm0ucmVwbGFjZVdpdGhIYXNoLmluY2x1ZGVzKHQucmVwbGFjZVdpdGhIYXNoKSYmbS5hcHBlbmRDaGlsZEhhc2guaW5jbHVkZXModC5hcHBlbmRDaGlsZEhhc2gpJiZtLmluc2VydEJlZm9yZUhhc2guaW5jbHVkZXModC5pbnNlcnRCZWZvcmVIYXNoKSYmbS5yZXBsYWNlQ2hpbGRIYXNoLmluY2x1ZGVzKHQucmVwbGFjZUNoaWxkSGFzaCkmJm0uaGFyZHdhcmVDb25jdXJyZW5jeUhhc2guaW5jbHVkZXModC5oYXJkd2FyZUNvbmN1cnJlbmN5SGFzaCk/IkpTaGVsdGVyIjpuPj0xMyYmdS5jb250ZW50RG9jdW1lbnRIYXNoLmluY2x1ZGVzKHQuY29udGVudERvY3VtZW50SGFzaCkmJnUuY29udGVudFdpbmRvd0hhc2guaW5jbHVkZXModC5jb250ZW50V2luZG93SGFzaCkmJnUuY3JlYXRlRWxlbWVudEhhc2guaW5jbHVkZXModC5jcmVhdGVFbGVtZW50SGFzaCkmJnUuZ2V0RWxlbWVudEJ5SWRIYXNoLmluY2x1ZGVzKHQuZ2V0RWxlbWVudEJ5SWRIYXNoKSYmdS5hcHBlbmRIYXNoLmluY2x1ZGVzKHQuYXBwZW5kSGFzaCkmJnUuaW5zZXJ0QWRqYWNlbnRFbGVtZW50SGFzaC5pbmNsdWRlcyh0Lmluc2VydEFkamFjZW50RWxlbWVudEhhc2gpJiZ1Lmluc2VydEFkamFjZW50SFRNTEhhc2guaW5jbHVkZXModC5pbnNlcnRBZGphY2VudEhUTUxIYXNoKSYmdS5pbnNlcnRBZGphY2VudFRleHRIYXNoLmluY2x1ZGVzKHQuaW5zZXJ0QWRqYWNlbnRUZXh0SGFzaCkmJnUucHJlcGVuZEhhc2guaW5jbHVkZXModC5wcmVwZW5kSGFzaCkmJnUucmVwbGFjZVdpdGhIYXNoLmluY2x1ZGVzKHQucmVwbGFjZVdpdGhIYXNoKSYmdS5hcHBlbmRDaGlsZEhhc2guaW5jbHVkZXModC5hcHBlbmRDaGlsZEhhc2gpJiZ1Lmluc2VydEJlZm9yZUhhc2guaW5jbHVkZXModC5pbnNlcnRCZWZvcmVIYXNoKSYmdS5jb250ZW50RG9jdW1lbnRIYXNoLmluY2x1ZGVzKHQuY29udGVudERvY3VtZW50SGFzaCkmJnUucmVwbGFjZUNoaWxkSGFzaC5pbmNsdWRlcyh0LnJlcGxhY2VDaGlsZEhhc2gpJiZ1LmdldENvbnRleHRIYXNoLmluY2x1ZGVzKHQuZ2V0Q29udGV4dEhhc2gpJiZ1LnRvRGF0YVVSTEhhc2guaW5jbHVkZXModC50b0RhdGFVUkxIYXNoKSYmdS50b0Jsb2JIYXNoLmluY2x1ZGVzKHQudG9CbG9iSGFzaCkmJnUuZ2V0SW1hZ2VEYXRhSGFzaC5pbmNsdWRlcyh0LmdldEltYWdlRGF0YUhhc2gpJiZ1LmhhcmR3YXJlQ29uY3VycmVuY3lIYXNoLmluY2x1ZGVzKHQuaGFyZHdhcmVDb25jdXJyZW5jeUhhc2gpPyJwdXBwZXRlZXItZXh0cmEiOm4+PTEyJiZnLmFwcGVuZENoaWxkSGFzaC5pbmNsdWRlcyh0LmFwcGVuZENoaWxkSGFzaCkmJmcuZ2V0Q29udGV4dEhhc2guaW5jbHVkZXModC5nZXRDb250ZXh0SGFzaCkmJmcudG9EYXRhVVJMSGFzaC5pbmNsdWRlcyh0LnRvRGF0YVVSTEhhc2gpJiZnLnRvQmxvYkhhc2guaW5jbHVkZXModC50b0Jsb2JIYXNoKSYmZy5nZXRJbWFnZURhdGFIYXNoLmluY2x1ZGVzKHQuZ2V0SW1hZ2VEYXRhSGFzaCkmJmcuaGFyZHdhcmVDb25jdXJyZW5jeUhhc2guaW5jbHVkZXModC5oYXJkd2FyZUNvbmN1cnJlbmN5SGFzaCkmJmcuYXZhaWxIZWlnaHRIYXNoLmluY2x1ZGVzKHQuYXZhaWxIZWlnaHRIYXNoKSYmZy5hdmFpbExlZnRIYXNoLmluY2x1ZGVzKHQuYXZhaWxMZWZ0SGFzaCkmJmcuYXZhaWxUb3BIYXNoLmluY2x1ZGVzKHQuYXZhaWxUb3BIYXNoKSYmZy5hdmFpbFdpZHRoSGFzaC5pbmNsdWRlcyh0LmF2YWlsV2lkdGhIYXNoKSYmZy5jb2xvckRlcHRoSGFzaC5pbmNsdWRlcyh0LmNvbG9yRGVwdGhIYXNoKSYmZy5waXhlbERlcHRoSGFzaC5pbmNsdWRlcyh0LnBpeGVsRGVwdGhIYXNoKT8iRmFrZUJyb3dzZXIiOnZvaWQgMH07cmV0dXJuIHQuZXh0ZW5zaW9uPWIoe3BhdHRlcm46cCxoYXNoOmgscHJvdG90eXBlTGllc0xlbjp1fSksRSh7dGltZTplLnN0b3AoKSx0ZXN0OiJyZXNpc3RhbmNlIixwYXNzZWQ6ITB9KSx0fWNhdGNoKGUpe3JldHVybiBFKHt0ZXN0OiJyZXNpc3RhbmNlIixwYXNzZWQ6ITF9KSx2b2lkIFIoZSl9fWZ1bmN0aW9uIFhlKCl7dHJ5e3JldHVybiJvbnRvdWNoc3RhcnQiaW4gd2luZG93JiYhIWRvY3VtZW50LmNyZWF0ZUV2ZW50KCJUb3VjaEV2ZW50Iil9Y2F0Y2goZSl7cmV0dXJuITF9fWFzeW5jIGZ1bmN0aW9uIHFlKGU9ITApe3RyeXtjb25zdCB0PXcoKTt0LnN0YXJ0KCk7bGV0IG49YWVbIlNjcmVlbi53aWR0aCJdfHxhZVsiU2NyZWVuLmhlaWdodCJdfHxhZVsiU2NyZWVuLmF2YWlsV2lkdGgiXXx8YWVbIlNjcmVlbi5hdmFpbEhlaWdodCJdfHxhZVsiU2NyZWVuLmNvbG9yRGVwdGgiXXx8YWVbIlNjcmVlbi5waXhlbERlcHRoIl18fCExO2NvbnN0IHI9d2luZG93LnNjcmVlbnx8e30se3dpZHRoOmksaGVpZ2h0OnMsYXZhaWxXaWR0aDpjLGF2YWlsSGVpZ2h0OmwsY29sb3JEZXB0aDpkLHBpeGVsRGVwdGg6bX09cix1PXdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHwwO2lmKCEoYSYmMSE9dSkpeyFtYXRjaE1lZGlhKGAoZGV2aWNlLXdpZHRoOiAke2l9cHgpIGFuZCAoZGV2aWNlLWhlaWdodDogJHtzfXB4KWApLm1hdGNoZXMmJihuPSEwLE8oIlNjcmVlbiIsImZhaWxlZCBtYXRjaE1lZGlhIikpfWNvbnN0IGc9IW1hdGNoTWVkaWEoYChyZXNvbHV0aW9uOiAke3V9ZHBweClgKS5tYXRjaGVzOyFvJiZnJiYobj0hMCxPKCJXaW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyIsImxpZWQgZHByIikpO2k+ODAwJiYhKGktY3x8cy1sKSYmKE0uU0NSRUVOPSEwKTtjb25zdCBwPXt3aWR0aDppLGhlaWdodDpzLGF2YWlsV2lkdGg6YyxhdmFpbEhlaWdodDpsLGNvbG9yRGVwdGg6ZCxwaXhlbERlcHRoOm0sdG91Y2g6WGUoKSxsaWVkOm59O3JldHVybiBlJiZFKHt0aW1lOnQuc3RvcCgpLHRlc3Q6InNjcmVlbiIscGFzc2VkOiEwfSkscH1jYXRjaCh0KXtyZXR1cm4gZSYmRSh7dGVzdDoic2NyZWVuIixwYXNzZWQ6ITF9KSx2b2lkIFIodCl9fWFzeW5jIGZ1bmN0aW9uIEtlKCl7cmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KCgoKT0+ZSh2b2lkIDApKSw1MCkpKSxuZXcgUHJvbWlzZSgoYXN5bmMgZT0+e3RyeXtjb25zdCB0PXcoKTthd2FpdCBrKHQpO2NvbnN0IGE9InNwZWVjaFN5bnRoZXNpcyJpbiB3aW5kb3c7aWYoYSYmc3BlZWNoU3ludGhlc2lzLmdldFZvaWNlcygpLCFhKXJldHVybiBFKHt0ZXN0OiJzcGVlY2giLHBhc3NlZDohMX0pLGUobnVsbCk7Y29uc3Qgbz0hIWFlWyJTcGVlY2hTeW50aGVzaXMuZ2V0Vm9pY2VzIl0scj1zZXRUaW1lb3V0KCgoKT0+KEUoe3Rlc3Q6InNwZWVjaCIscGFzc2VkOiExfSksZShudWxsKSkpLDMwMCksaT0oKT0+e2NvbnN0IGE9c3BlZWNoU3ludGhlc2lzLmdldFZvaWNlcygpLGk9KGF8fFtdKS5maW5kKChlPT5lLmxvY2FsU2VydmljZSkpO2lmKCFhfHwhYS5sZW5ndGh8fG4mJiFpKXJldHVybjtjbGVhclRpbWVvdXQocik7Y29uc3Qgcz0oKGUsdCk9PmUuZmlsdGVyKChlPT57Y29uc3R7dm9pY2VVUkk6bn09ZTtyZXR1cm4hdC5oYXMobikmJih0LmFkZChuKSwhMCl9KSkpKGEsbmV3IFNldCksYz1zLmZpbHRlcigoZT0+ZS5sb2NhbFNlcnZpY2UpKS5tYXAoKGU9PmUubmFtZSkpLGw9cy5maWx0ZXIoKGU9PiFlLmxvY2FsU2VydmljZSkpLm1hcCgoZT0+ZS5uYW1lKSksZD1bLi4ubmV3IFNldChzLm1hcCgoZT0+ZS5sYW5nKSkpXSxtPXMuZmlsdGVyKChlPT5lLmRlZmF1bHQmJmUubG9jYWxTZXJ2aWNlKSk7bGV0IHU9IiIsZz0iIjtpZigxPT09bS5sZW5ndGgpe2NvbnN0e25hbWU6ZSxsYW5nOnR9PW1bMF07dT1lLGc9KHR8fCIiKS5yZXBsYWNlKC9fLywiLSIpfWNvbnN0e2xvY2FsZTpwfT1JbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCk7cmV0dXJuIGcmJmcuc3BsaXQoIi0iKVswXSE9PXAuc3BsaXQoIi0iKVswXSYmKEQudm9pY2VMYW5nTWlzbWF0Y2g9ITAsTS5USU1FX1pPTkU9ITApLEUoe3RpbWU6dC5zdG9wKCksdGVzdDoic3BlZWNoIixwYXNzZWQ6ITB9KSxlKHtsb2NhbDpjLHJlbW90ZTpsLGxhbmd1YWdlczpkLGRlZmF1bHRWb2ljZU5hbWU6dSxkZWZhdWx0Vm9pY2VMYW5nOmcsbGllZDpvfSl9O2lmKGkoKSxzcGVlY2hTeW50aGVzaXMuYWRkRXZlbnRMaXN0ZW5lcilyZXR1cm4gc3BlZWNoU3ludGhlc2lzLmFkZEV2ZW50TGlzdGVuZXIoInZvaWNlc2NoYW5nZWQiLGkpO3NwZWVjaFN5bnRoZXNpcy5vbnZvaWNlc2NoYW5nZWQ9aX1jYXRjaCh0KXtyZXR1cm4gRSh7dGVzdDoic3BlZWNoIixwYXNzZWQ6ITF9KSxSKHQpLGUobnVsbCl9fSkpfWFzeW5jIGZ1bmN0aW9uIFllKCl7dHJ5e2NvbnN0IGU9dygpO2F3YWl0IGsoZSk7bGV0IHQ9YWVbIlNWR1JlY3QuaGVpZ2h0Il18fGFlWyJTVkdSZWN0LndpZHRoIl18fGFlWyJTVkdSZWN0LngiXXx8YWVbIlNWR1JlY3QueSJdfHxhZVsiU3RyaW5nLmZyb21Db2RlUG9pbnQiXXx8YWVbIlNWR1JlY3RFbGVtZW50LmdldEJCb3giXXx8YWVbIlNWR1RleHRDb250ZW50RWxlbWVudC5nZXRFeHRlbnRPZkNoYXIiXXx8YWVbIlNWR1RleHRDb250ZW50RWxlbWVudC5nZXRTdWJTdHJpbmdMZW5ndGgiXXx8YWVbIlNWR1RleHRDb250ZW50RWxlbWVudC5nZXRDb21wdXRlZFRleHRMZW5ndGgiXXx8ITE7Y29uc3Qgbj1ZJiZZLmRvY3VtZW50JiZZLmRvY3VtZW50LmJvZHk/WS5kb2N1bWVudDpkb2N1bWVudCxhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImRpdiIpO24uYm9keS5hcHBlbmRDaGlsZChhKSxDKGEsVGAKCQkJPGRpdiBpZD0ic3ZnLWNvbnRhaW5lciI+CgkJCQk8c3R5bGU+CgkJCQkjc3ZnLWNvbnRhaW5lciB7CgkJCQkJcG9zaXRpb246IGFic29sdXRlOwoJCQkJCWxlZnQ6IC05OTk5cHg7CgkJCQkJaGVpZ2h0OiBhdXRvOwoJCQkJfQoJCQkJI3N2Zy1jb250YWluZXIgLnNoaWZ0LXN2ZyB7CgkJCQkJdHJhbnNmb3JtOiBzY2FsZSgxLjAwMDk5OSkgIWltcG9ydGFudDsKCQkJCX0KCQkJCS5zdmdyZWN0LWVtb2ppIHsKCQkJCQlmb250LWZhbWlseTogJHtBfTsKCQkJCQlmb250LXNpemU6IDIwMHB4ICFpbXBvcnRhbnQ7CgkJCQkJaGVpZ2h0OiBhdXRvOwoJCQkJCXBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50OwoJCQkJCXRyYW5zZm9ybTogc2NhbGUoMS4wMDA5OTkpOwoJCQkJfQoJCQkJPC9zdHlsZT4KCQkJCTxzdmc+CgkJCQkJPGcgaWQ9InN2Z0JveCI+CgkJCQkJCSR7di5tYXAoKGU9PmA8dGV4dCB4PSIzMiIgeT0iMzIiIGNsYXNzPSJzdmdyZWN0LWVtb2ppIj4ke2V9PC90ZXh0PmApKS5qb2luKCIiKX0KCQkJCQk8L2c+CgkJCQk8L3N2Zz4KCQkJPC9kaXY+CgkJYCk7Y29uc3Qgbz1lPT5PYmplY3Qua2V5cyhlLl9fcHJvdG9fXykucmVkdWNlKCgodCxuKT0+e2NvbnN0IGE9ZVtuXTtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgYT90OnsuLi50LFtuXTphfX0pLHt9KSxyPWU9Pk9iamVjdC5rZXlzKGUuX19wcm90b19fKS5yZWR1Y2UoKCh0LG4pPT57Y29uc3QgYT1lW25dO3JldHVybiBpc05hTihhKT90OnQrPWF9KSwwKSxpPWU9PmU/T2JqZWN0LmtleXMoZSkucmVkdWNlKCgodCxuKT0+dCtNYXRoLmFicyhlW25dKSksMCk6MCxzPW4uZ2V0RWxlbWVudEJ5SWQoInN2Z0JveCIpLGM9byhzLmdldEJCb3goKSksbD1uZXcgU2V0LGQ9Wy4uLnMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgic3ZncmVjdC1lbW9qaSIpXTthd2FpdCBrKGUpO2NvbnN0IG09ZC5yZWR1Y2UoKChlLHQsbik9Pntjb25zdCBhPXZbbl0sbz0iIit0LmdldENvbXB1dGVkVGV4dExlbmd0aCgpO3JldHVybiBsLmhhcyhvKXx8KGwuYWRkKG8pLGUuYWRkKGEpKSxlfSksbmV3IFNldCksdT0xZS01KlsuLi5sXS5tYXAoKGU9PmUuc3BsaXQoIiwiKS5yZWR1Y2UoKChlLHQpPT5lKygrdHx8MCkpLDApKSkucmVkdWNlKCgoZSx0KT0+ZSt0KSwwKSxnPWRbMF0scD1nLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO2cuY2xhc3NMaXN0LmFkZCgic2hpZnQtc3ZnIik7Y29uc3QgaD1nLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO2cuY2xhc3NMaXN0LnJlbW92ZSgic2hpZnQtc3ZnIik7cC1oIT1nLmdldENvbXB1dGVkVGV4dExlbmd0aCgpLWgmJih0PSEwLE8oIlNWR1RleHRDb250ZW50RWxlbWVudC5nZXRDb21wdXRlZFRleHRMZW5ndGgiLCJmYWlsZWQgdW5zaGlmdCBjYWxjdWxhdGlvbiIpKTtjb25zdCBiPXtiQm94OmkoYyksZXh0ZW50T2ZDaGFyOnIoZFswXS5nZXRFeHRlbnRPZkNoYXIodlswXSkpLHN1YlN0cmluZ0xlbmd0aDpkWzBdLmdldFN1YlN0cmluZ0xlbmd0aCgwLDEwKSxjb21wdXRlZFRleHRMZW5ndGg6ZFswXS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSxlbW9qaVNldDpbLi4ubV0sc3ZncmVjdFN5c3RlbVN1bTp1LGxpZWQ6dH07cmV0dXJuIG4uYm9keS5yZW1vdmVDaGlsZChuLmdldEVsZW1lbnRCeUlkKCJzdmctY29udGFpbmVyIikpLEUoe3RpbWU6ZS5zdG9wKCksdGVzdDoic3ZnIixwYXNzZWQ6ITB9KSxifWNhdGNoKGUpe3JldHVybiBFKHt0ZXN0OiJzdmciLHBhc3NlZDohMX0pLHZvaWQgUihlKX19ZnVuY3Rpb24gUWUoKXtjb25zdCBlPVsiVVRDIiwiR01UIiwiRXRjL0dNVCswIiwiRXRjL0dNVCsxIiwiRXRjL0dNVCsxMCIsIkV0Yy9HTVQrMTEiLCJFdGMvR01UKzEyIiwiRXRjL0dNVCsyIiwiRXRjL0dNVCszIiwiRXRjL0dNVCs0IiwiRXRjL0dNVCs1IiwiRXRjL0dNVCs2IiwiRXRjL0dNVCs3IiwiRXRjL0dNVCs4IiwiRXRjL0dNVCs5IiwiRXRjL0dNVC0xIiwiRXRjL0dNVC0xMCIsIkV0Yy9HTVQtMTEiLCJFdGMvR01ULTEyIiwiRXRjL0dNVC0xMyIsIkV0Yy9HTVQtMTQiLCJFdGMvR01ULTIiLCJFdGMvR01ULTMiLCJFdGMvR01ULTQiLCJFdGMvR01ULTUiLCJFdGMvR01ULTYiLCJFdGMvR01ULTciLCJFdGMvR01ULTgiLCJFdGMvR01ULTkiLCJFdGMvR01UIiwiQWZyaWNhL0FiaWRqYW4iLCJBZnJpY2EvQWNjcmEiLCJBZnJpY2EvQWRkaXNfQWJhYmEiLCJBZnJpY2EvQWxnaWVycyIsIkFmcmljYS9Bc21hcmEiLCJBZnJpY2EvQmFtYWtvIiwiQWZyaWNhL0Jhbmd1aSIsIkFmcmljYS9CYW5qdWwiLCJBZnJpY2EvQmlzc2F1IiwiQWZyaWNhL0JsYW50eXJlIiwiQWZyaWNhL0JyYXp6YXZpbGxlIiwiQWZyaWNhL0J1anVtYnVyYSIsIkFmcmljYS9DYWlybyIsIkFmcmljYS9DYXNhYmxhbmNhIiwiQWZyaWNhL0NldXRhIiwiQWZyaWNhL0NvbmFrcnkiLCJBZnJpY2EvRGFrYXIiLCJBZnJpY2EvRGFyX2VzX1NhbGFhbSIsIkFmcmljYS9Eamlib3V0aSIsIkFmcmljYS9Eb3VhbGEiLCJBZnJpY2EvRWxfQWFpdW4iLCJBZnJpY2EvRnJlZXRvd24iLCJBZnJpY2EvR2Fib3JvbmUiLCJBZnJpY2EvSGFyYXJlIiwiQWZyaWNhL0pvaGFubmVzYnVyZyIsIkFmcmljYS9KdWJhIiwiQWZyaWNhL0thbXBhbGEiLCJBZnJpY2EvS2hhcnRvdW0iLCJBZnJpY2EvS2lnYWxpIiwiQWZyaWNhL0tpbnNoYXNhIiwiQWZyaWNhL0xhZ29zIiwiQWZyaWNhL0xpYnJldmlsbGUiLCJBZnJpY2EvTG9tZSIsIkFmcmljYS9MdWFuZGEiLCJBZnJpY2EvTHVidW1iYXNoaSIsIkFmcmljYS9MdXNha2EiLCJBZnJpY2EvTWFsYWJvIiwiQWZyaWNhL01hcHV0byIsIkFmcmljYS9NYXNlcnUiLCJBZnJpY2EvTWJhYmFuZSIsIkFmcmljYS9Nb2dhZGlzaHUiLCJBZnJpY2EvTW9ucm92aWEiLCJBZnJpY2EvTmFpcm9iaSIsIkFmcmljYS9OZGphbWVuYSIsIkFmcmljYS9OaWFtZXkiLCJBZnJpY2EvTm91YWtjaG90dCIsIkFmcmljYS9PdWFnYWRvdWdvdSIsIkFmcmljYS9Qb3J0by1Ob3ZvIiwiQWZyaWNhL1Nhb19Ub21lIiwiQWZyaWNhL1RyaXBvbGkiLCJBZnJpY2EvVHVuaXMiLCJBZnJpY2EvV2luZGhvZWsiLCJBbWVyaWNhL0FkYWsiLCJBbWVyaWNhL0FuY2hvcmFnZSIsIkFtZXJpY2EvQW5ndWlsbGEiLCJBbWVyaWNhL0FudGlndWEiLCJBbWVyaWNhL0FyYWd1YWluYSIsIkFtZXJpY2EvQXJnZW50aW5hL0J1ZW5vc19BaXJlcyIsIkFtZXJpY2EvQXJnZW50aW5hL0NhdGFtYXJjYSIsIkFtZXJpY2EvQXJnZW50aW5hL0NvcmRvYmEiLCJBbWVyaWNhL0FyZ2VudGluYS9KdWp1eSIsIkFtZXJpY2EvQXJnZW50aW5hL0xhX1Jpb2phIiwiQW1lcmljYS9BcmdlbnRpbmEvTWVuZG96YSIsIkFtZXJpY2EvQXJnZW50aW5hL1Jpb19HYWxsZWdvcyIsIkFtZXJpY2EvQXJnZW50aW5hL1NhbHRhIiwiQW1lcmljYS9BcmdlbnRpbmEvU2FuX0p1YW4iLCJBbWVyaWNhL0FyZ2VudGluYS9TYW5fTHVpcyIsIkFtZXJpY2EvQXJnZW50aW5hL1R1Y3VtYW4iLCJBbWVyaWNhL0FyZ2VudGluYS9Vc2h1YWlhIiwiQW1lcmljYS9BcnViYSIsIkFtZXJpY2EvQXN1bmNpb24iLCJBbWVyaWNhL0F0aWtva2FuIiwiQW1lcmljYS9CYWhpYSIsIkFtZXJpY2EvQmFoaWFfQmFuZGVyYXMiLCJBbWVyaWNhL0JhcmJhZG9zIiwiQW1lcmljYS9CZWxlbSIsIkFtZXJpY2EvQmVsaXplIiwiQW1lcmljYS9CbGFuYy1TYWJsb24iLCJBbWVyaWNhL0JvYV9WaXN0YSIsIkFtZXJpY2EvQm9nb3RhIiwiQW1lcmljYS9Cb2lzZSIsIkFtZXJpY2EvQ2FtYnJpZGdlX0JheSIsIkFtZXJpY2EvQ2FtcG9fR3JhbmRlIiwiQW1lcmljYS9DYW5jdW4iLCJBbWVyaWNhL0NhcmFjYXMiLCJBbWVyaWNhL0NheWVubmUiLCJBbWVyaWNhL0NheW1hbiIsIkFtZXJpY2EvQ2hpY2FnbyIsIkFtZXJpY2EvQ2hpaHVhaHVhIiwiQW1lcmljYS9Db3N0YV9SaWNhIiwiQW1lcmljYS9DcmVzdG9uIiwiQW1lcmljYS9DdWlhYmEiLCJBbWVyaWNhL0N1cmFjYW8iLCJBbWVyaWNhL0Rhbm1hcmtzaGF2biIsIkFtZXJpY2EvRGF3c29uIiwiQW1lcmljYS9EYXdzb25fQ3JlZWsiLCJBbWVyaWNhL0RlbnZlciIsIkFtZXJpY2EvRGV0cm9pdCIsIkFtZXJpY2EvRG9taW5pY2EiLCJBbWVyaWNhL0VkbW9udG9uIiwiQW1lcmljYS9FaXJ1bmVwZSIsIkFtZXJpY2EvRWxfU2FsdmFkb3IiLCJBbWVyaWNhL0ZvcnRfTmVsc29uIiwiQW1lcmljYS9Gb3J0YWxlemEiLCJBbWVyaWNhL0dsYWNlX0JheSIsIkFtZXJpY2EvR29kdGhhYiIsIkFtZXJpY2EvR29vc2VfQmF5IiwiQW1lcmljYS9HcmFuZF9UdXJrIiwiQW1lcmljYS9HcmVuYWRhIiwiQW1lcmljYS9HdWFkZWxvdXBlIiwiQW1lcmljYS9HdWF0ZW1hbGEiLCJBbWVyaWNhL0d1YXlhcXVpbCIsIkFtZXJpY2EvR3V5YW5hIiwiQW1lcmljYS9IYWxpZmF4IiwiQW1lcmljYS9IYXZhbmEiLCJBbWVyaWNhL0hlcm1vc2lsbG8iLCJBbWVyaWNhL0luZGlhbmEvSW5kaWFuYXBvbGlzIiwiQW1lcmljYS9JbmRpYW5hL0tub3giLCJBbWVyaWNhL0luZGlhbmEvTWFyZW5nbyIsIkFtZXJpY2EvSW5kaWFuYS9QZXRlcnNidXJnIiwiQW1lcmljYS9JbmRpYW5hL1RlbGxfQ2l0eSIsIkFtZXJpY2EvSW5kaWFuYS9WZXZheSIsIkFtZXJpY2EvSW5kaWFuYS9WaW5jZW5uZXMiLCJBbWVyaWNhL0luZGlhbmEvV2luYW1hYyIsIkFtZXJpY2EvSW51dmlrIiwiQW1lcmljYS9JcWFsdWl0IiwiQW1lcmljYS9KYW1haWNhIiwiQW1lcmljYS9KdW5lYXUiLCJBbWVyaWNhL0tlbnR1Y2t5L0xvdWlzdmlsbGUiLCJBbWVyaWNhL0tlbnR1Y2t5L01vbnRpY2VsbG8iLCJBbWVyaWNhL0tyYWxlbmRpamsiLCJBbWVyaWNhL0xhX1BheiIsIkFtZXJpY2EvTGltYSIsIkFtZXJpY2EvTG9zX0FuZ2VsZXMiLCJBbWVyaWNhL0xvd2VyX1ByaW5jZXMiLCJBbWVyaWNhL01hY2VpbyIsIkFtZXJpY2EvTWFuYWd1YSIsIkFtZXJpY2EvTWFuYXVzIiwiQW1lcmljYS9NYXJpZ290IiwiQW1lcmljYS9NYXJ0aW5pcXVlIiwiQW1lcmljYS9NYXRhbW9yb3MiLCJBbWVyaWNhL01hemF0bGFuIiwiQW1lcmljYS9NZW5vbWluZWUiLCJBbWVyaWNhL01lcmlkYSIsIkFtZXJpY2EvTWV0bGFrYXRsYSIsIkFtZXJpY2EvTWV4aWNvX0NpdHkiLCJBbWVyaWNhL01pcXVlbG9uIiwiQW1lcmljYS9Nb25jdG9uIiwiQW1lcmljYS9Nb250ZXJyZXkiLCJBbWVyaWNhL01vbnRldmlkZW8iLCJBbWVyaWNhL01vbnRzZXJyYXQiLCJBbWVyaWNhL05hc3NhdSIsIkFtZXJpY2EvTmV3X1lvcmsiLCJBbWVyaWNhL05pcGlnb24iLCJBbWVyaWNhL05vbWUiLCJBbWVyaWNhL05vcm9uaGEiLCJBbWVyaWNhL05vcnRoX0Rha290YS9CZXVsYWgiLCJBbWVyaWNhL05vcnRoX0Rha290YS9DZW50ZXIiLCJBbWVyaWNhL05vcnRoX0Rha290YS9OZXdfU2FsZW0iLCJBbWVyaWNhL09qaW5hZ2EiLCJBbWVyaWNhL1BhbmFtYSIsIkFtZXJpY2EvUGFuZ25pcnR1bmciLCJBbWVyaWNhL1BhcmFtYXJpYm8iLCJBbWVyaWNhL1Bob2VuaXgiLCJBbWVyaWNhL1BvcnQtYXUtUHJpbmNlIiwiQW1lcmljYS9Qb3J0X29mX1NwYWluIiwiQW1lcmljYS9Qb3J0b19WZWxobyIsIkFtZXJpY2EvUHVlcnRvX1JpY28iLCJBbWVyaWNhL1B1bnRhX0FyZW5hcyIsIkFtZXJpY2EvUmFpbnlfUml2ZXIiLCJBbWVyaWNhL1Jhbmtpbl9JbmxldCIsIkFtZXJpY2EvUmVjaWZlIiwiQW1lcmljYS9SZWdpbmEiLCJBbWVyaWNhL1Jlc29sdXRlIiwiQW1lcmljYS9SaW9fQnJhbmNvIiwiQW1lcmljYS9TYW50YXJlbSIsIkFtZXJpY2EvU2FudGlhZ28iLCJBbWVyaWNhL1NhbnRvX0RvbWluZ28iLCJBbWVyaWNhL1Nhb19QYXVsbyIsIkFtZXJpY2EvU2NvcmVzYnlzdW5kIiwiQW1lcmljYS9TaXRrYSIsIkFtZXJpY2EvU3RfQmFydGhlbGVteSIsIkFtZXJpY2EvU3RfSm9obnMiLCJBbWVyaWNhL1N0X0tpdHRzIiwiQW1lcmljYS9TdF9MdWNpYSIsIkFtZXJpY2EvU3RfVGhvbWFzIiwiQW1lcmljYS9TdF9WaW5jZW50IiwiQW1lcmljYS9Td2lmdF9DdXJyZW50IiwiQW1lcmljYS9UZWd1Y2lnYWxwYSIsIkFtZXJpY2EvVGh1bGUiLCJBbWVyaWNhL1RodW5kZXJfQmF5IiwiQW1lcmljYS9UaWp1YW5hIiwiQW1lcmljYS9Ub3JvbnRvIiwiQW1lcmljYS9Ub3J0b2xhIiwiQW1lcmljYS9WYW5jb3V2ZXIiLCJBbWVyaWNhL1doaXRlaG9yc2UiLCJBbWVyaWNhL1dpbm5pcGVnIiwiQW1lcmljYS9ZYWt1dGF0IiwiQW1lcmljYS9ZZWxsb3drbmlmZSIsIkFudGFyY3RpY2EvQ2FzZXkiLCJBbnRhcmN0aWNhL0RhdmlzIiwiQW50YXJjdGljYS9EdW1vbnREVXJ2aWxsZSIsIkFudGFyY3RpY2EvTWFjcXVhcmllIiwiQW50YXJjdGljYS9NYXdzb24iLCJBbnRhcmN0aWNhL01jTXVyZG8iLCJBbnRhcmN0aWNhL1BhbG1lciIsIkFudGFyY3RpY2EvUm90aGVyYSIsIkFudGFyY3RpY2EvU3lvd2EiLCJBbnRhcmN0aWNhL1Ryb2xsIiwiQW50YXJjdGljYS9Wb3N0b2siLCJBcmN0aWMvTG9uZ3llYXJieWVuIiwiQXNpYS9BZGVuIiwiQXNpYS9BbG1hdHkiLCJBc2lhL0FtbWFuIiwiQXNpYS9BbmFkeXIiLCJBc2lhL0FxdGF1IiwiQXNpYS9BcXRvYmUiLCJBc2lhL0FzaGdhYmF0IiwiQXNpYS9BdHlyYXUiLCJBc2lhL0JhZ2hkYWQiLCJBc2lhL0JhaHJhaW4iLCJBc2lhL0Jha3UiLCJBc2lhL0Jhbmdrb2siLCJBc2lhL0Jhcm5hdWwiLCJBc2lhL0JlaXJ1dCIsIkFzaWEvQmlzaGtlayIsIkFzaWEvQnJ1bmVpIiwiQXNpYS9DYWxjdXR0YSIsIkFzaWEvQ2hpdGEiLCJBc2lhL0Nob2liYWxzYW4iLCJBc2lhL0NvbG9tYm8iLCJBc2lhL0RhbWFzY3VzIiwiQXNpYS9EaGFrYSIsIkFzaWEvRGlsaSIsIkFzaWEvRHViYWkiLCJBc2lhL0R1c2hhbmJlIiwiQXNpYS9GYW1hZ3VzdGEiLCJBc2lhL0dhemEiLCJBc2lhL0hlYnJvbiIsIkFzaWEvSG9fQ2hpX01pbmgiLCJBc2lhL0hvbmdfS29uZyIsIkFzaWEvSG92ZCIsIkFzaWEvSXJrdXRzayIsIkFzaWEvSmFrYXJ0YSIsIkFzaWEvSmF5YXB1cmEiLCJBc2lhL0plcnVzYWxlbSIsIkFzaWEvS2FidWwiLCJBc2lhL0thbWNoYXRrYSIsIkFzaWEvS2FyYWNoaSIsIkFzaWEvS2F0aG1hbmR1IiwiQXNpYS9LaGFuZHlnYSIsIkFzaWEvS29sa2F0YSIsIkFzaWEvS3Jhc25veWFyc2siLCJBc2lhL0t1YWxhX0x1bXB1ciIsIkFzaWEvS3VjaGluZyIsIkFzaWEvS3V3YWl0IiwiQXNpYS9NYWNhdSIsIkFzaWEvTWFnYWRhbiIsIkFzaWEvTWFrYXNzYXIiLCJBc2lhL01hbmlsYSIsIkFzaWEvTXVzY2F0IiwiQXNpYS9OaWNvc2lhIiwiQXNpYS9Ob3Zva3V6bmV0c2siLCJBc2lhL05vdm9zaWJpcnNrIiwiQXNpYS9PbXNrIiwiQXNpYS9PcmFsIiwiQXNpYS9QaG5vbV9QZW5oIiwiQXNpYS9Qb250aWFuYWsiLCJBc2lhL1B5b25neWFuZyIsIkFzaWEvUWF0YXIiLCJBc2lhL1Fvc3RhbmF5IiwiQXNpYS9ReXp5bG9yZGEiLCJBc2lhL1JpeWFkaCIsIkFzaWEvU2FraGFsaW4iLCJBc2lhL1NhbWFya2FuZCIsIkFzaWEvU2VvdWwiLCJBc2lhL1NoYW5naGFpIiwiQXNpYS9TaW5nYXBvcmUiLCJBc2lhL1NyZWRuZWtvbHltc2siLCJBc2lhL1RhaXBlaSIsIkFzaWEvVGFzaGtlbnQiLCJBc2lhL1RiaWxpc2kiLCJBc2lhL1RlaHJhbiIsIkFzaWEvVGhpbXBodSIsIkFzaWEvVG9reW8iLCJBc2lhL1RvbXNrIiwiQXNpYS9VbGFhbmJhYXRhciIsIkFzaWEvVXJ1bXFpIiwiQXNpYS9Vc3QtTmVyYSIsIkFzaWEvVmllbnRpYW5lIiwiQXNpYS9WbGFkaXZvc3RvayIsIkFzaWEvWWFrdXRzayIsIkFzaWEvWWFuZ29uIiwiQXNpYS9ZZWthdGVyaW5idXJnIiwiQXNpYS9ZZXJldmFuIiwiQXRsYW50aWMvQXpvcmVzIiwiQXRsYW50aWMvQmVybXVkYSIsIkF0bGFudGljL0NhbmFyeSIsIkF0bGFudGljL0NhcGVfVmVyZGUiLCJBdGxhbnRpYy9GYXJvZSIsIkF0bGFudGljL01hZGVpcmEiLCJBdGxhbnRpYy9SZXlramF2aWsiLCJBdGxhbnRpYy9Tb3V0aF9HZW9yZ2lhIiwiQXRsYW50aWMvU3RfSGVsZW5hIiwiQXRsYW50aWMvU3RhbmxleSIsIkF1c3RyYWxpYS9BZGVsYWlkZSIsIkF1c3RyYWxpYS9CcmlzYmFuZSIsIkF1c3RyYWxpYS9Ccm9rZW5fSGlsbCIsIkF1c3RyYWxpYS9DdXJyaWUiLCJBdXN0cmFsaWEvRGFyd2luIiwiQXVzdHJhbGlhL0V1Y2xhIiwiQXVzdHJhbGlhL0hvYmFydCIsIkF1c3RyYWxpYS9MaW5kZW1hbiIsIkF1c3RyYWxpYS9Mb3JkX0hvd2UiLCJBdXN0cmFsaWEvTWVsYm91cm5lIiwiQXVzdHJhbGlhL1BlcnRoIiwiQXVzdHJhbGlhL1N5ZG5leSIsIkV1cm9wZS9BbXN0ZXJkYW0iLCJFdXJvcGUvQW5kb3JyYSIsIkV1cm9wZS9Bc3RyYWtoYW4iLCJFdXJvcGUvQXRoZW5zIiwiRXVyb3BlL0JlbGdyYWRlIiwiRXVyb3BlL0JlcmxpbiIsIkV1cm9wZS9CcmF0aXNsYXZhIiwiRXVyb3BlL0JydXNzZWxzIiwiRXVyb3BlL0J1Y2hhcmVzdCIsIkV1cm9wZS9CdWRhcGVzdCIsIkV1cm9wZS9CdXNpbmdlbiIsIkV1cm9wZS9DaGlzaW5hdSIsIkV1cm9wZS9Db3BlbmhhZ2VuIiwiRXVyb3BlL0R1YmxpbiIsIkV1cm9wZS9HaWJyYWx0YXIiLCJFdXJvcGUvR3Vlcm5zZXkiLCJFdXJvcGUvSGVsc2lua2kiLCJFdXJvcGUvSXNsZV9vZl9NYW4iLCJFdXJvcGUvSXN0YW5idWwiLCJFdXJvcGUvSmVyc2V5IiwiRXVyb3BlL0thbGluaW5ncmFkIiwiRXVyb3BlL0tpZXYiLCJFdXJvcGUvS2lyb3YiLCJFdXJvcGUvTGlzYm9uIiwiRXVyb3BlL0xqdWJsamFuYSIsIkV1cm9wZS9Mb25kb24iLCJFdXJvcGUvTHV4ZW1ib3VyZyIsIkV1cm9wZS9NYWRyaWQiLCJFdXJvcGUvTWFsdGEiLCJFdXJvcGUvTWFyaWVoYW1uIiwiRXVyb3BlL01pbnNrIiwiRXVyb3BlL01vbmFjbyIsIkV1cm9wZS9Nb3Njb3ciLCJFdXJvcGUvT3NsbyIsIkV1cm9wZS9QYXJpcyIsIkV1cm9wZS9Qb2Rnb3JpY2EiLCJFdXJvcGUvUHJhZ3VlIiwiRXVyb3BlL1JpZ2EiLCJFdXJvcGUvUm9tZSIsIkV1cm9wZS9TYW1hcmEiLCJFdXJvcGUvU2FuX01hcmlubyIsIkV1cm9wZS9TYXJhamV2byIsIkV1cm9wZS9TYXJhdG92IiwiRXVyb3BlL1NpbWZlcm9wb2wiLCJFdXJvcGUvU2tvcGplIiwiRXVyb3BlL1NvZmlhIiwiRXVyb3BlL1N0b2NraG9sbSIsIkV1cm9wZS9UYWxsaW5uIiwiRXVyb3BlL1RpcmFuZSIsIkV1cm9wZS9VbHlhbm92c2siLCJFdXJvcGUvVXpoZ29yb2QiLCJFdXJvcGUvVmFkdXoiLCJFdXJvcGUvVmF0aWNhbiIsIkV1cm9wZS9WaWVubmEiLCJFdXJvcGUvVmlsbml1cyIsIkV1cm9wZS9Wb2xnb2dyYWQiLCJFdXJvcGUvV2Fyc2F3IiwiRXVyb3BlL1phZ3JlYiIsIkV1cm9wZS9aYXBvcm96aHllIiwiRXVyb3BlL1p1cmljaCIsIkluZGlhbi9BbnRhbmFuYXJpdm8iLCJJbmRpYW4vQ2hhZ29zIiwiSW5kaWFuL0NocmlzdG1hcyIsIkluZGlhbi9Db2NvcyIsIkluZGlhbi9Db21vcm8iLCJJbmRpYW4vS2VyZ3VlbGVuIiwiSW5kaWFuL01haGUiLCJJbmRpYW4vTWFsZGl2ZXMiLCJJbmRpYW4vTWF1cml0aXVzIiwiSW5kaWFuL01heW90dGUiLCJJbmRpYW4vUmV1bmlvbiIsIlBhY2lmaWMvQXBpYSIsIlBhY2lmaWMvQXVja2xhbmQiLCJQYWNpZmljL0JvdWdhaW52aWxsZSIsIlBhY2lmaWMvQ2hhdGhhbSIsIlBhY2lmaWMvQ2h1dWsiLCJQYWNpZmljL0Vhc3RlciIsIlBhY2lmaWMvRWZhdGUiLCJQYWNpZmljL0VuZGVyYnVyeSIsIlBhY2lmaWMvRmFrYW9mbyIsIlBhY2lmaWMvRmlqaSIsIlBhY2lmaWMvRnVuYWZ1dGkiLCJQYWNpZmljL0dhbGFwYWdvcyIsIlBhY2lmaWMvR2FtYmllciIsIlBhY2lmaWMvR3VhZGFsY2FuYWwiLCJQYWNpZmljL0d1YW0iLCJQYWNpZmljL0hvbm9sdWx1IiwiUGFjaWZpYy9LaXJpdGltYXRpIiwiUGFjaWZpYy9Lb3NyYWUiLCJQYWNpZmljL0t3YWphbGVpbiIsIlBhY2lmaWMvTWFqdXJvIiwiUGFjaWZpYy9NYXJxdWVzYXMiLCJQYWNpZmljL01pZHdheSIsIlBhY2lmaWMvTmF1cnUiLCJQYWNpZmljL05pdWUiLCJQYWNpZmljL05vcmZvbGsiLCJQYWNpZmljL05vdW1lYSIsIlBhY2lmaWMvUGFnb19QYWdvIiwiUGFjaWZpYy9QYWxhdSIsIlBhY2lmaWMvUGl0Y2Fpcm4iLCJQYWNpZmljL1BvaG5wZWkiLCJQYWNpZmljL1BvcnRfTW9yZXNieSIsIlBhY2lmaWMvUmFyb3RvbmdhIiwiUGFjaWZpYy9TYWlwYW4iLCJQYWNpZmljL1RhaGl0aSIsIlBhY2lmaWMvVGFyYXdhIiwiUGFjaWZpYy9Ub25nYXRhcHUiLCJQYWNpZmljL1dha2UiLCJQYWNpZmljL1dhbGxpcyJdLHQ9KCk9Pntjb25zdFtlLHQsbl09SlNPTi5zdHJpbmdpZnkobmV3IERhdGUpLnNsaWNlKDEsMTEpLnNwbGl0KCItIiksYT1gJHtlfS0ke3R9LSR7bn1gO3JldHVybn5+KCsoK25ldyBEYXRlKGAke3R9LyR7bn0vJHtlfWApLStuZXcgRGF0ZShhKSkvNmU0KX0sbj0oe3llYXI6ZSxjaXR5OnQ9bnVsbH0pPT57bGV0IG4sYTtpZih0KXtjb25zdCBvPXsuLi57dGltZVpvbmU6IiIseWVhcjoibnVtZXJpYyIsbW9udGg6Im51bWVyaWMiLGRheToibnVtZXJpYyIsaG91cjoibnVtZXJpYyIsbWludXRlOiJudW1lcmljIixzZWNvbmQ6Im51bWVyaWMifSx0aW1lWm9uZTp0fTtuPW5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCJlbiIsbyksYT0rbmV3IERhdGUobi5mb3JtYXQobmV3IERhdGUoYDcvMS8ke2V9YCkpKX1lbHNlIGE9K25ldyBEYXRlKGA3LzEvJHtlfWApO3JldHVybihhLStuZXcgRGF0ZShgJHtlfS0wNy0wMWApKS82ZTR9LGE9KGUsdCk9Pntjb25zdCBuPWUubGVuZ3RoLG89TWF0aC5mbG9vcihuLzIpLFtyLGldPVtlLnNsaWNlKDAsbyksZS5zbGljZShvLG4pXSxzPXQocik7cmV0dXJuIDE9PW58fHMubGVuZ3RoP3M6YShpLHQpfSxvPWU9Pnt0cnl7cmV0dXJuIGUucmVwbGFjZSgvXy8sIiAiKS5zcGxpdCgiLyIpLmpvaW4oIiwgIil9Y2F0Y2goZSl7fXJldHVybiBlfTt0cnl7Y29uc3Qgcj13KCk7ci5zdGFydCgpO2NvbnN0IGk9YWVbIkRhdGUuZ2V0VGltZXpvbmVPZmZzZXQiXXx8YWVbIkludGwuRGF0ZVRpbWVGb3JtYXQucmVzb2x2ZWRPcHRpb25zIl18fGFlWyJJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5yZXNvbHZlZE9wdGlvbnMiXXx8ITEscz0xMTEzLHt0aW1lWm9uZTpjfT1JbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCksbD0oKHt5ZWFyOnQsdGltZVpvbmU6b30pPT57Y29uc3Qgcj1uKHt5ZWFyOnR9KSxpPW4oe3llYXI6dCxjaXR5Om99KSxzPXI9PWk/W29dOmEoZSwoZT0+ZS5maWx0ZXIoKGU9PnI9PW4oe3llYXI6dCxjaXR5OmV9KSkpKSk7cmV0dXJuIDE9PXMubGVuZ3RoJiZzWzBdPT1vP286d2Uocyl9KSh7eWVhcjpzLHRpbWVab25lOmN9KSxkPStuZXcgRGF0ZShuZXcgRGF0ZShgNy8xLyR7c31gKSksbT0vLipcKHxcKS4qL2csdT17em9uZTooIiIrbmV3IERhdGUpLnJlcGxhY2UobSwiIiksbG9jYXRpb246byhjKSxsb2NhdGlvbk1lYXN1cmVkOm8obCksbG9jYXRpb25FcG9jaDpkLG9mZnNldDoobmV3IERhdGUpLmdldFRpbWV6b25lT2Zmc2V0KCksb2Zmc2V0Q29tcHV0ZWQ6dCgpLGxpZWQ6aX07cmV0dXJuIEUoe3RpbWU6ci5zdG9wKCksdGVzdDoidGltZXpvbmUiLHBhc3NlZDohMH0pLHsuLi51fX1jYXRjaChlKXtyZXR1cm4gRSh7dGVzdDoidGltZXpvbmUiLHBhc3NlZDohMX0pLHZvaWQgUihlKX19YXN5bmMgZnVuY3Rpb24gSmUoKXtjb25zdCBlPWU9Pntjb25zdCB0PSJCaWdJbnQ2NEFycmF5ImluIHdpbmRvdyYmbyYmIS8oQ3J8RngpaU9TLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO2lmKCFlfHx0KXJldHVybjtlLmNsZWFyKGUuQ09MT1JfQlVGRkVSX0JJVCk7Y29uc3Qgbj1lLmNyZWF0ZUJ1ZmZlcigpO2UuYmluZEJ1ZmZlcihlLkFSUkFZX0JVRkZFUixuKTtjb25zdCBhPW5ldyBGbG9hdDMyQXJyYXkoWy0uOSwtLjcsMCwuOCwtLjcsMCwwLC41LDBdKTtlLmJ1ZmZlckRhdGEoZS5BUlJBWV9CVUZGRVIsYSxlLlNUQVRJQ19EUkFXKTtjb25zdCByPWUuY3JlYXRlUHJvZ3JhbSgpLGk9ZS5jcmVhdGVTaGFkZXIoZS5WRVJURVhfU0hBREVSKTtlLnNoYWRlclNvdXJjZShpLCJcblx0XHRcdGF0dHJpYnV0ZSB2ZWMyIGF0dHJWZXJ0ZXg7XG5cdFx0XHR2YXJ5aW5nIHZlYzIgdmFyeWluVGV4Q29vcmRpbmF0ZTtcblx0XHRcdHVuaWZvcm0gdmVjMiB1bmlmb3JtT2Zmc2V0O1xuXHRcdFx0dm9pZCBtYWluKCl7XG5cdFx0XHRcdHZhcnlpblRleENvb3JkaW5hdGUgPSBhdHRyVmVydGV4ICsgdW5pZm9ybU9mZnNldDtcblx0XHRcdFx0Z2xfUG9zaXRpb24gPSB2ZWM0KGF0dHJWZXJ0ZXgsIDAsIDEpO1xuXHRcdFx0fVxuXHRcdCIpLGUuY29tcGlsZVNoYWRlcihpKSxlLmF0dGFjaFNoYWRlcihyLGkpO2NvbnN0IHM9ZS5jcmVhdGVTaGFkZXIoZS5GUkFHTUVOVF9TSEFERVIpO2Uuc2hhZGVyU291cmNlKHMsIlxuXHRcdFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cdFx0XHR2YXJ5aW5nIHZlYzIgdmFyeWluVGV4Q29vcmRpbmF0ZTtcblx0XHRcdHZvaWQgbWFpbigpIHtcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh2YXJ5aW5UZXhDb29yZGluYXRlLCAxLCAxKTtcblx0XHRcdH1cblx0XHQiKSxlLmNvbXBpbGVTaGFkZXIocyksZS5hdHRhY2hTaGFkZXIocixzKTtlLmxpbmtQcm9ncmFtKHIpLGUudXNlUHJvZ3JhbShyKSxyLnZlcnRleFBvc0F0dHJpYj1lLmdldEF0dHJpYkxvY2F0aW9uKHIsImF0dHJWZXJ0ZXgiKSxyLm9mZnNldFVuaWZvcm09ZS5nZXRVbmlmb3JtTG9jYXRpb24ociwidW5pZm9ybU9mZnNldCIpLGUuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoci52ZXJ0ZXhQb3NBcnJheSksZS52ZXJ0ZXhBdHRyaWJQb2ludGVyKHIudmVydGV4UG9zQXR0cmliLDMsZS5GTE9BVCwhMSwwLDApLGUudW5pZm9ybTJmKHIub2Zmc2V0VW5pZm9ybSwxLDEpO3JldHVybiBlLmRyYXdBcnJheXMoZS5MSU5FX0xPT1AsMCwzKSxlfTt0cnl7Y29uc3Qgbj13KCk7YXdhaXQgayhuKTtjb25zdCBhPWFlWyJIVE1MQ2FudmFzRWxlbWVudC50b0RhdGFVUkwiXSxvPWFlWyJIVE1MQ2FudmFzRWxlbWVudC5nZXRDb250ZXh0Il0scj1hZVsiV2ViR0xSZW5kZXJpbmdDb250ZXh0LmdldFBhcmFtZXRlciJdfHxhZVsiV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5nZXRQYXJhbWV0ZXIiXXx8YWVbIldlYkdMUmVuZGVyaW5nQ29udGV4dC5nZXRFeHRlbnNpb24iXXx8YWVbIldlYkdMMlJlbmRlcmluZ0NvbnRleHQuZ2V0RXh0ZW5zaW9uIl0scz1hfHxvfHxyfHxhZVsiV2ViR0xSZW5kZXJpbmdDb250ZXh0LmdldFN1cHBvcnRlZEV4dGVuc2lvbnMiXXx8YWVbIldlYkdMMlJlbmRlcmluZ0NvbnRleHQuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucyJdfHwhMTtsZXQgYz13aW5kb3c7IWkmJlkmJihjPVkpO2NvbnN0IGw9Yy5kb2N1bWVudDtsZXQgZCxtOyJPZmZzY3JlZW5DYW52YXMiaW4gd2luZG93PyhkPW5ldyBjLk9mZnNjcmVlbkNhbnZhcygyNTYsMjU2KSxtPW5ldyBjLk9mZnNjcmVlbkNhbnZhcygyNTYsMjU2KSk6KGQ9bC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxtPWwuY3JlYXRlRWxlbWVudCgiY2FudmFzIikpO2NvbnN0IHU9KGUsdCk9Pnt0cnl7cmV0dXJuIndlYmdsMiI9PXQ/ZS5nZXRDb250ZXh0KCJ3ZWJnbDIiKXx8ZS5nZXRDb250ZXh0KCJleHBlcmltZW50YWwtd2ViZ2wyIik6ZS5nZXRDb250ZXh0KCJ3ZWJnbCIpfHxlLmdldENvbnRleHQoImV4cGVyaW1lbnRhbC13ZWJnbCIpfHxlLmdldENvbnRleHQoIm1vei13ZWJnbCIpfHxlLmdldENvbnRleHQoIndlYmtpdC0zZCIpfWNhdGNoKGUpe3JldHVybn19LGc9dShkLCJ3ZWJnbCIpLHA9dShtLCJ3ZWJnbDIiKTtpZighZylyZXR1cm4gdm9pZCBFKHt0ZXN0OiJ3ZWJnbCIscGFzc2VkOiExfSk7Y29uc3QgaD0oZSx0KT0+e2lmKCFlKXJldHVybjtyZXR1cm57TE9XX0ZMT0FUOk4oKCgpPT5lLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChlW3RdLGUuTE9XX0ZMT0FUKSkpLE1FRElVTV9GTE9BVDpOKCgoKT0+ZS5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZVt0XSxlLk1FRElVTV9GTE9BVCkpKSxISUdIX0ZMT0FUOk4oKCgpPT5lLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChlW3RdLGUuSElHSF9GTE9BVCkpKSxISUdIX0lOVDpOKCgoKT0+ZS5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZVt0XSxlLkhJR0hfSU5UKSkpfX0sYj0oZSx0KT0+e2NvbnN0IG49e307Zm9yKGNvbnN0IGEgaW4gdCl7Y29uc3Qgbz10W2FdO25bZSsiLiIrYSsiLnByZWNpc2lvbiJdPW8/TigoKCk9Pm8ucHJlY2lzaW9uKSk6dm9pZCAwLG5bZSsiLiIrYSsiLnJhbmdlTWF4Il09bz9OKCgoKT0+by5yYW5nZU1heCkpOnZvaWQgMCxuW2UrIi4iK2ErIi5yYW5nZU1pbiJdPW8/TigoKCk9Pm8ucmFuZ2VNaW4pKTp2b2lkIDB9cmV0dXJuIG59LGY9ZT0+e2lmKCFlKXJldHVybjtjb25zdCB0PWUuZ2V0RXh0ZW5zaW9uKCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiKXx8ZS5nZXRFeHRlbnNpb24oIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiKXx8ZS5nZXRFeHRlbnNpb24oIldFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMiKTtyZXR1cm4gdD9lLmdldFBhcmFtZXRlcih0Lk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCk6dm9pZCAwfSxTPWU9PntpZighZSlyZXR1cm57fTtjb25zdCB0PW5ldyBTZXQoWyJBTElBU0VEX1BPSU5UX1NJWkVfUkFOR0UiLCJBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0UiLCJTVEVOQ0lMX1ZBTFVFX01BU0siLCJTVEVOQ0lMX1dSSVRFTUFTSyIsIlNURU5DSUxfQkFDS19WQUxVRV9NQVNLIiwiU1RFTkNJTF9CQUNLX1dSSVRFTUFTSyIsIk1BWF9URVhUVVJFX1NJWkUiLCJNQVhfVklFV1BPUlRfRElNUyIsIlNVQlBJWEVMX0JJVFMiLCJNQVhfVkVSVEVYX0FUVFJJQlMiLCJNQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyIsIk1BWF9WQVJZSU5HX1ZFQ1RPUlMiLCJNQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyIsIk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyIsIk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTIiwiTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyIsIlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTiIsIlZFTkRPUiIsIlJFTkRFUkVSIiwiVkVSU0lPTiIsIk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUiLCJNQVhfUkVOREVSQlVGRkVSX1NJWkUiLCJNQVhfM0RfVEVYVFVSRV9TSVpFIiwiTUFYX0VMRU1FTlRTX1ZFUlRJQ0VTIiwiTUFYX0VMRU1FTlRTX0lORElDRVMiLCJNQVhfVEVYVFVSRV9MT0RfQklBUyIsIk1BWF9EUkFXX0JVRkZFUlMiLCJNQVhfRlJBR01FTlRfVU5JRk9STV9DT01QT05FTlRTIiwiTUFYX1ZFUlRFWF9VTklGT1JNX0NPTVBPTkVOVFMiLCJNQVhfQVJSQVlfVEVYVFVSRV9MQVlFUlMiLCJNQVhfUFJPR1JBTV9URVhFTF9PRkZTRVQiLCJNQVhfVkFSWUlOR19DT01QT05FTlRTIiwiTUFYX1RSQU5TRk9STV9GRUVEQkFDS19TRVBBUkFURV9DT01QT05FTlRTIiwiTUFYX1RSQU5TRk9STV9GRUVEQkFDS19JTlRFUkxFQVZFRF9DT01QT05FTlRTIiwiTUFYX1RSQU5TRk9STV9GRUVEQkFDS19TRVBBUkFURV9BVFRSSUJTIiwiTUFYX0NPTE9SX0FUVEFDSE1FTlRTIiwiTUFYX1NBTVBMRVMiLCJNQVhfVkVSVEVYX1VOSUZPUk1fQkxPQ0tTIiwiTUFYX0ZSQUdNRU5UX1VOSUZPUk1fQkxPQ0tTIiwiTUFYX0NPTUJJTkVEX1VOSUZPUk1fQkxPQ0tTIiwiTUFYX1VOSUZPUk1fQlVGRkVSX0JJTkRJTkdTIiwiTUFYX1VOSUZPUk1fQkxPQ0tfU0laRSIsIk1BWF9DT01CSU5FRF9WRVJURVhfVU5JRk9STV9DT01QT05FTlRTIiwiTUFYX0NPTUJJTkVEX0ZSQUdNRU5UX1VOSUZPUk1fQ09NUE9ORU5UUyIsIk1BWF9WRVJURVhfT1VUUFVUX0NPTVBPTkVOVFMiLCJNQVhfRlJBR01FTlRfSU5QVVRfQ09NUE9ORU5UUyIsIk1BWF9TRVJWRVJfV0FJVF9USU1FT1VUIiwiTUFYX0VMRU1FTlRfSU5ERVgiLCJNQVhfQ0xJRU5UX1dBSVRfVElNRU9VVF9XRUJHTCJdLnNvcnQoKSk7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSkuZmlsdGVyKChlPT50LmhhcyhlKSkpLnJlZHVjZSgoKHQsbik9Pntjb25zdCBhPWUuZ2V0UGFyYW1ldGVyKGVbbl0pO3JldHVybiBhJiYiYnVmZmVyImluIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKT90W25dPVsuLi5hXTp0W25dPWEsdH0pLHt9KX0seT1lPT57Y29uc3QgdD1lP2UuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvIik6bnVsbDtyZXR1cm4gdD97VU5NQVNLRURfVkVORE9SX1dFQkdMOmUuZ2V0UGFyYW1ldGVyKHQuVU5NQVNLRURfVkVORE9SX1dFQkdMKSxVTk1BU0tFRF9SRU5ERVJFUl9XRUJHTDplLmdldFBhcmFtZXRlcih0LlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMKX06e319LHY9ZT0+e2lmKCFlKXJldHVybltdO2NvbnN0IHQ9TigoKCk9PmUuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpKSk7cmV0dXJuIHR8fFtdfSxBPSh0LG4pPT57aWYoIXQpcmV0dXJue2RhdGFVUkk6dm9pZCAwLHBpeGVsczp2b2lkIDB9O3RyeXtlKHQpO2NvbnN0e2RyYXdpbmdCdWZmZXJXaWR0aDphLGRyYXdpbmdCdWZmZXJIZWlnaHQ6b309dDtsZXQgcj0iIjtpZigiT2Zmc2NyZWVuQ2FudmFzIj09PXQuY2FudmFzLmNvbnN0cnVjdG9yLm5hbWUpe2NvbnN0IHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIik7ZSh1KHQsbikpLHI9dC50b0RhdGFVUkwoKX1lbHNlIHI9dC5jYW52YXMudG9EYXRhVVJMKCk7Y29uc3QgaT1hLzE1LHM9by82LGM9bmV3IFVpbnQ4QXJyYXkoaSpzKjQpO3RyeXt0LnJlYWRQaXhlbHMoMCwwLGkscyx0LlJHQkEsdC5VTlNJR05FRF9CWVRFLGMpfWNhdGNoKGUpe3JldHVybntkYXRhVVJJOnIscGl4ZWxzOnZvaWQgMH19cmV0dXJue2RhdGFVUkk6cixwaXhlbHM6Wy4uLmNdfX1jYXRjaChlKXtyZXR1cm4gUihlKX19O2F3YWl0IGsobik7Y29uc3QgQz17Li4uUyhnKSwuLi55KGcpfSxUPXsuLi5TKHApLC4uLnkocCl9LHg9e0FMSUFTRURfTElORV9XSURUSF9SQU5HRTohMCxTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT046ITAsVkVSU0lPTjohMH0sST1PYmplY3Qua2V5cyhUKS5maWx0ZXIoKGU9PiEhQ1tlXSYmIXhbZV0mJiIiK0NbZV0hPSIiK1RbZV0pKTtJLmxlbmd0aCYmbWUoIndlYmdsL3dlYmdsMiBtaXJyb3JlZCBwYXJhbXMgbWlzbWF0Y2giLEkudG9TdHJpbmcoKSksYXdhaXQgayhuKTtjb25zdHtkYXRhVVJJOkwscGl4ZWxzOlB9PUEoZywid2ViZ2wiKXx8e30se2RhdGFVUkk6TyxwaXhlbHM6Qn09QShwLCJ3ZWJnbDIiKXx8e30sSD17ZXh0ZW5zaW9uczpbLi4udihnKSwuLi52KHApXSxwaXhlbHM6UCxwaXhlbHMyOkIsZGF0YVVSSTpMLGRhdGFVUkkyOk8scGFyYW1ldGVyczp7Li4uey4uLkMsLi4uVH0sLi4ue2FudGlhbGlhczpnLmdldENvbnRleHRBdHRyaWJ1dGVzKCk/Zy5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFudGlhbGlhczp2b2lkIDAsTUFYX1ZJRVdQT1JUX0RJTVM6TigoKCk9PlsuLi5nLmdldFBhcmFtZXRlcihnLk1BWF9WSUVXUE9SVF9ESU1TKV0pKSxNQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQ6ZihnKSwuLi5iKCJWRVJURVhfU0hBREVSIixoKGcsIlZFUlRFWF9TSEFERVIiKSksLi4uYigiRlJBR01FTlRfU0hBREVSIixoKGcsIkZSQUdNRU5UX1NIQURFUiIpKSxNQVhfRFJBV19CVUZGRVJTX1dFQkdMOk4oKCgpPT57Y29uc3QgZT1nLmdldEV4dGVuc2lvbigiV0VCR0xfZHJhd19idWZmZXJzIik7cmV0dXJuIGU/Zy5nZXRQYXJhbWV0ZXIoZS5NQVhfRFJBV19CVUZGRVJTX1dFQkdMKTp2b2lkIDB9KSl9fSxwYXJhbWV0ZXJPckV4dGVuc2lvbkxpZTpyLGxpZWQ6c30sRj1bImZjYTY2NTIwIiwiYjYyMzIxYzMiLCJiMzYyYzJmNSIsIjBlYjJmYzE5IiwiNTVlODIxZjciLCI2OTUxODM4YiIsIjA4ODQ3YmE1IiwiYzAwNTgyZTkiLCI2ZWRmMTcyMCIsIjJiODBmZDk2IiwiNjM0NmNmNDkiLCIyMjU5YjcwNiIsImU3OTZiODRlIiwiNWE1NjU4ZjEiLCI1ODg3MTM4MCIsIjVhOTBhNWY4IiwiY2ZkMjAyNzQiLCI1NTgyZGViZSIsImU0NTY5YTViIiwiZjIyOTM0NDciLCJjMDQ4ODliMSIsIjFiMjUxZmQ3IiwiZWE1OWIzNDMiLCJiOGVhNmU3ZiIsIjE2YzQ4MWE2IiwiNThmZGM3MjAiLCJiZjA2MzE3ZSIsIjYyOTRkODRlIiwiZTY0NjRjOWYiLCJhMzk3YTU2OCIsIjgxYjljZDI5IiwiMWJmZDMyNmMiLCI3MDg1OWJkYiIsIjcwYTA5NWIxIiwiMjMwZDZhMGQiLCIzYmYzMjFiOCIsImMwNGUzNzRhIiwiYmUyZGZhZWEiLCJmOTcxNGIzZCIsIjQ2MWY5N2UxIiwiZDA5YzFjMDciLCJhMWM4MDhkNSIsIjBiMmQ0MzMzIiwiNWRkYjkyMzciLCIzOWVhZDUwNiIsIjgwMmUyNTQ3IiwiNDliZjczNTgiLCJjMDI2NDY5ZCIsIjU4MWYzMjgyIiwiZjBkNWEzYzciLCI2MzU3MzY1YyIsImFlMmM0Nzc3IiwiODQ5Y2NiNjQiLCJlOTY1ZDU0MSIsIjc5NGY4OTI5IiwiMjQwMmMzZDIiLCJlMTVhZmFiMCIsIjY5NmUxNTQ4IiwiYWZhNTgzYmMiLCJlYTU0ZDUyNSIsIjVjYTU1MjkyIiwiZjUxY2FiOWEiLCIwODdkNTc1OSIsIjhkMzcxMTYxIiwiZDg2MGZmNDIiLCIxNDUzZDU5YSIsIjEyZTkyZTYyIiwiYjUwNDY2MmQiLCJjZjk2NDNlNiIsImRkNjdiMDc2IiwiYTU4MWY1NWUiLCJiMjI0Y2M3YyIsIjJmMDE0YzQxIiwiMzNiYzU0OTIiLCIwZmMxMjNjNyIsImRiZGJlN2E0IiwiZDIxNzI5NDMiLCI2ODY0ZGNiMCIsIjNmZWExMTAwIiwiZDkxM2RhZmEiLCJkNmJmMzVhZCIsImEyNmU5YWE5IiwiMTcxODMxYzUiLCI1MzQwMDJhYiIsIjEyZjhhYzE0IiwiM2ZmODIzMDMiLCI5OWIxYTFjNiIsIjc0ZGFmODY2IiwiZmMzN2ZlMWYiLCI2YWExZmY3ZSIsImVjOTI4NjU1IiwiODQyOGZjOGUiLCJkOGJkOWU1YSIsIjhiZDBiOTFiIiwiNTJlMzQ4YmEiLCJjMmJjZTQ5NiIsImUxNDJkMWY5IiwiMmY1ODJlZDkiLCI0MDY1Y2Q2OSIsIjY2NjI4MzEwIiwiOTAzYzg4NDciLCIxZmY3YzdlNyIsIjQwMmUxMDY0IiwiZWI3OTlkMzQiLCJlZjhmNWRiMSIsImUxNTVjNDdlIiwiMTc3Y2MyNTgiLCI2ZjgxY2JlNyIsIjZiMjkwY2Q0IiwiZjEwNzczMzQiLCJkMWU3NmM4OSIsIjVkNzg2Y2VmIiwiZWFhMTM4MDQiLCJmYWZhMTRjMCIsIjJjMDRjMmViIiwiYzkzYjUzNjYiLCI0OTYyYWRhMSIsIjI1YTc2MGI4IiwiYmY2MTBjZGIiLCJiY2Y3MzE1ZiIsIjgwMWQ3M2FmIiwiMDBmZTFlYzkiLCIwZjM5ZDA1NyIsImY4ZTY1NDg2IiwiMzk5OWE1ZTEiLCJhZDAxYTQyMiIsImRjMjcxYzM1IiwiYjUwZWRkOTkiLCJlNjhiNWM0ZSIsIjgyYTlhMmYxIiwiMGNkYjk4NWQiLCJhMjM4MzAwMSIsImNlMmUzZDE2IiwiYzliYzRmZmQiLCJlZWQyZTVlMSIsImUxMDMzOWIzIiwiZjc0NTFjOTIiLCI0MzAzOGUzZCIsIjg1NDFhYTRjIiwiZmE5OTRmMzMiLCJiMmQ2ZmM5OCIsIjZhNzVhZTNiIiwiNjc5OTU5OTYiLCIwZjg0MDM3OSIsImU1NzRiZWY2IiwiYjU0OTQwMjciLCIzNjYwYjcxZiIsImEyMjc4OGY4IiwiZTE2YmIxYmIiLCJlNTk2MmJhMyIsImM1ZTlhODgzIiwiNWVlNDE0NTYiLCIzYTkxZDBkNiIsImMwNWY3NTk2IiwiZGVkNzQwNDQiLCJmNWQxOTkzNCIsImM3OTYzNGMyIiwiMTg1NzllODMiLCIxZThhOWE3OSIsIjUwOGQxNjI1IiwiZDA1YTY2ZWIiLCIzNDI3MDQ2OSIsImYzYzZlYTExIiwiNTVkM2FhNTYiLCI3YjJlNTI0MiIsImU5NjVkMTgwIiwiMjU4Nzg5ZDAiLCJkMmRjMjQ3NCIsImQ0OTg3OTdkIiwiZWE3ZjkwZWEiLCJhNGQzNDE3NiIsImMwNGIwNjM1IiwiMDJiM2VlYTMiLCI2YjA3ZDRmOCIsIjZjMTY4ODAxIiwiYWI0MGJlY2UiLCJhNGI5ODhkYSIsIjRjOWU4ZjVkIiwiNWFlYTFhZjEiLCI3OTVlNWM5NSIsIjI3ZGIyOTJjIiwiMDU3ODU3YWMiLCIyM2QxY2UyMCIsIjkxNzg3MWU3IiwiYmVmZmRhMjYiLCI0ODJjODFiMiIsImMwOTJmZGY4IiwiNjI0OGQ5ZTMiLCJlMzE2ZTRjMCIsImFkZTc1YzRmIiwiNzM2MGViZDEiLCIzMDBlZTkyNyIsIjViZWY5YTM5IiwiMzc0MGM0YzciLCI2NjhmMGY5MyIsIjZkZmFlM2NiIiwiOWI2N2I3ZGMiLCJkZTc5M2VhZCIsIjE0OWExZWZhIiwiNzlhNTdhYTkiLCJiZmUxYzIxMiIsIjYyYmY3ZWYxIiwiMjVmOTM4NWQiLCI0MDI3ZDE5MyIsImU5ZGJiOGQ1IiwiY2JhMTg3OGIiLCI0NTAzZTc3MSIsImNiZWFkZThjIiwiYzA3MzA3YzYiLCJjZWZiNzJjYSIsIjYyM2MzYmZkIiwiMDBiNzI1MDciLCI4MjE5ZTFhNCIsIjYxZDk0NjRlIiwiNzIzOGM1ZGQiLCJiNGQ0MGRjYyIsIjA0NjM2MjdkIiwiNTgzMWQ1ZmQiLCIwNTg2ZTIwYiIsIjQ2N2I5OWE1IiwiYjEwYzJhODUiLCJmMjIxZmVmNSIsIjdiODExY2RkIiwiOTllZjJjM2IiLCI1YjZhMTdhYSIsImE1YTQ3N2FlIiwiMTk1OTQ2NjYiLCI0NjRkNTFhYyIsImE5N2QzODU4IiwiMjA0OGJjNWEiLCI2ZTgwNmZmYyIsIjY5OGM1YzJlIiwiMjc5Mzg4MzAiLCI2NmQ5OTJlOCIsImM3ZTM3Y2EwIiwiNzg2NDA4NTkiLCI1MDJjNDAyYyIsImQ5NzBkMzQ1IiwiZWMwNTBiYjYiLCI3NDE2ODhlNCIsIjYxMTc4ZjJhIiwiOWM4MTRjMWIiLCI3OTI4NGM0NyIsImQ3MzRlYTA4IiwiMTAxZTA1ODIiLCJlYThmNWFkMCIsIjYxZWVjYWFlIiwiZGNkOWEyOWUiLCI0OGFmMDM4ZiIsImJiNzdhNDY5IiwiODU0NzliOTkiLCIwNjM5YTgxYSIsImRmOWRhZWI2IiwiOWZkNzYzNTIiLCIzYjcyNDkxNiIsIjJiYjQ4OGRhIiwiZmUwOTk3YjYiLCI5ZTJiNWU5NCIsImYzM2Q5MThlIiwiYjg5NjFkMTUiLCJhM2Y5ZWUzNCIsImE5NjQwODgwIiwiYmMwZjk2ODYiLCIyZDE1Mjg3ZiIsImFhNzNmM2E0IiwiMDBjMWI0MmQiXSxHPVstMjE0NzI4NzgxMCwtMjE0NzM4MjI1MSwtMjE0NzM2MTc2OSwtMjE0NzM4MjI3MiwtMjE0NzM2MTc5MiwtMjE0NTk3NDYxMiwtMjE0NTk3NDU5OCwtMjE0NzI4NzgzNCwtMjE0NzEzMzc0OSwtMjE0NjM4NDAyNywtMjE0NzI5NTgyMiwtMjE0NjM4NDAwMywtMTE0NzQ1MTkwMSwtMjE0NzM4MzI0NiwtMjE0NTk2NjU0NSwtMjE0NzQ0NzEzNywtMTE0NzE2MDU1MywzNDk5MTIsLTIxNDc0MjkyMDEsLTIxNDc0NTkwMzEsLTIxNDYzODQwMTEsLTExNDc0NjQxNzcsLTIxNDU5NjY1MzUsLTIxNDc0NDA0MjIsLTExNDgzMjY3MzksMTIyOTgzNSwtMjE0NzM2Mjc2MCwtMjE0NzMzNzAwMywtMjE0NzMzMzExOCwtMjE0NzQwNzgyMSwtMjE0NzQ0NzE2MSwtMjE0NzMxNjM4MywtMjE0NjI1MTY0MSwtMTE0NzQ1MTg4Myw5OTkxNTY5MjIsLTIxNDYyODY0MzgsLTIxNDYyODY0NjMsLTExNDc0NjQxNjksLTExNDcxNjg3MjQsLTIxNDcxMzYzMjgsLTIxNDczODIyMjEsLTIxNDc0NDcxNDksLTIxNDcyODc4NTQsLTIxMzA2NTk5MTIsLTIxNDYyNTM2OTMsLTExNDg2Nzg2MzEsLTIxNDczODczMzUsLTIxNDczNjE3NzUsLTExNDc2MDI5MzQsLTIxNDczNjU4NjMsLTExNDc0MTk3NzUsLTE5NjI5MTk5NzQsLTIxNDc0NjY5NzIsLTIxNDU5NjY1MjksLTExNjQyNzk4OTAsLTIxNDczODU4MjUsLTIxNDczNjE3NzQsMTE0NzcxNDQyNiwtMjE0NzI4NzgyMCwtMjE0NzMzNjk5OCwtMjE0NzQ2MTE2OSwtMjE0NzQ3NTM1MiwtMTE0ODU3MjM1NCwtMjE0NjM4NDI4MSwtMjE0NzM2MTczMSwtMjE0NzMwNDE5MywtMjE0NzM4OTkzMCwtMjE0NzM4NjI5MiwtMTk2MjkyODE3OCwtMjE0NzM0NDY4NiwtMjE0NzQ0NzExMSwtMjE0NzQ0NzEyMiw5OTg4MDQ5OTIsLTEzNDgyMzk3MSwtMjE0NzQ0Nzg3MywtMjE0NzM0Njc0NywtMjE0NjI4NjU4MywtMjE0NzM4OTk1MSwtMjEzMDE2NDM4OCwxODQ1NTU0ODMsLTIxNDczOTQxODgsMTYxMDYxODg0MSwtMTMzMjAyOTMzMiwyMTQ3NDQwNDM4LDM1MTUxMywtMjE0NjQwMDM4NCwtMjE0NjE4Nzc2NiwtMTE0NzE2MDM5OSwxMTk3MDc1LDk5ODkxMTI2OCwtMjE0NzI5NTg0OSwtMjEzMDE2NDE2MiwtMjE0NzM4NTg0OSwtMjEzMDE2NDU0NiwtMTE0Nzc2NTI3NCwtMTA3MzcxOTMzMSwtMjE0NjQxNzAyNywtMjE0NzM2NTc2MCw5OTkxNDg1OTcsLTE4NzgxMTExMjQsLTY3NzU1ODE2MCwtMTMzNzU3NDc1LC0yMTQ3MTI4Mjc1LC0yMTQ3NDUzNzAxLC0yMTMwMTcyNTczLC0xMTQ3NDE5NzUxLC0yMTQ2NTI2Nzk1LC0yMTQ2MjM2NzAzLC0yMTQ3NDEwOTQxLC0yMTQ3NDE1MDM3LC0yMTQ1OTc0NjU3LC0yMTQ3MzA2MzIxLC0yMTQ3Mzc4MTQ2LC0yMTQ2MjM3MDIwLC0yMTQ1OTY2NDE0LC0yMTQ3NDUzNzY4LC0yMTQ3MjkxODIwLC0yMTQ3NDcwMTczLC02Mzg0OTQ3NTUsLTEzNDIxNTQ3ODcsLTIxNDc0NjcxNzIsLTIxNDU5NzQ0ODksLTExNDc2NDM3NTksLTIxNDc0NDc4OTIsODM2MjUsLTIxNDYyMzI1MDMsLTIxNDcyOTU4NTcsLTIxNDYyNTM2NzEsLTIxNDczMTYzODIsLTIxNDc0MjkyMjMsLTIxNDczOTA0NjEsLTIxNDcyOTE3MTgsLTIxNDY1MjY5MzQsLTIxNDc0NDcxMjYsLTIxNDYzODQxMjAsMjE2NjcsLTIxNDU5NzQ3MjksLTIxNDcyOTMwNTgsLTIxNDYyNTE2MTksMTA5OTUzNiwtMjE0NzE0MjQyOSwtMjE0NjM3OTk1NSwtMjE0NzM2NTgyNywtMjE0NjQwMDU1NiwtMjE0NzI5NTc2OCwtMjE0NjI1MTY4MSwtMTg3ODEwMjkyMSwtMjE0NTk3NDM0MywyMTQ3NDc1MDg1LC0yMTQ3Mzk0MjUxLC0yMTQ2MjMyNzIzLC0yMTQ3NDAwMDU3LC0yMTQ3NDE0OTU2LC0yMTQ3NDM5MDIwLC0yMTQ2MzE5MjY4LC0yMTQ3NDA2Nzk4LC0xMTQ4NjgwNTA5LC0yMTQ2Mjc3MjE4LDIxNDY1OTA3MjgsLTIxNDY0MDA2MjAsLTIxNDc0MTQ3MzMsLTIxNDYzNzYwNjUsLTIxNDczODczNjQsLTIxNDczODYzMjYsLTE5NjI4OTMzNzAsLTIxMzAxNjQzODIsLTIxNDU5MzM2NDgsLTIxNDc0NDc5MjgsLTIxNDc0NDg1OTIsLTIxNDU5NzQzODAsLTIxNDcxMzM3NDcsLTIxNDU5NDE5NzcsLTIxNDc0MDc2NDMsLTIxNDc0NDcxNTcsLTIxNDczMDAwMTksMjE0NzQ3OTE4MSwtMTE2NDgwMDQ3OCwtMjE0NjIzMjMzOCwtMjE0NTk3NDYzNywtMjE0NzQ1Mzc2NywtMjE0NjQwMTkyOCwtMjE0NzM2NTczMCwtMjE0NjM4NDAzNCwtMjE0NzQ3NTM1MSwtMjE0NjIzMjQ4MCwtMjE0NjIzNjU4OCwtMjE0NzQ0Nzg5NiwtMjE0NzI5NTgyMywtOTk5OTg3MjE2LC0yMTQ1OTY2NDQxLC0yMTQ3MTM0OTc0LC0xMTQ3NDE5NzUzLC0yMTQ3Mzk0NDg0LC0xNjc0NjU0NiwtMjE0NjIzMjcyNCwtMTE0ODMzNTA3MCwtMjE0NjIzMjU5MCwtMjE0NjM5ODU2OCwtMTE2NDgwMDE5MSwtMjE0NzQ2Njk1NiwtMTE0NzY0Mzg3MiwtMTE0ODcxMzI1OSwtMTE0NzQyNzgyNiwtMjE0NzM2NTc1OSwtMjE0NzMzNzAxMiwtMjE0NTk3MDY1OCwtMjE0NzEyNTU0NCwtMjE0NzQxNDk4NywtMjE0NzM3MzkxNCwtMjE0NzM3Mzk4NCwtMTE0NzQ4ODE0NCwtNjcxMDgyNTQ2LC0yMTQ3MzYxNjUyLC0yMTQ3Mzc0MDgwLC0yMTQ3Mjg3ODM1LC0yMTQ1OTc0NTk2LDE1MDg5OTgsLTIxNDczNzgwNDEsLTIxNDczNzQwMzIsLTIxNDc0MTA5MzgsLTIxNDU5NTgyMjgsLTIxNDczMzcwMjIsLTIxNDczODIxMzAsLTIxNDcyODc4MTFdLFY9SC5wYXJhbWV0ZXJzP1suLi5uZXcgU2V0KE9iamVjdC52YWx1ZXMoSC5wYXJhbWV0ZXJzKS5maWx0ZXIoKGU9PmUmJiJzdHJpbmciIT10eXBlb2YgZSkpLmZsYXQoKS5tYXAoKGU9Pk51bWJlcihlKSkpKV0uc29ydCgoKGUsdCk9PmUtdCkpOnZvaWQgMCxfPSh0PUgucGFyYW1ldGVycz8uVU5NQVNLRURfUkVOREVSRVJfV0VCR0wsdD8vcmFkZW9uL2kudGVzdCh0KT8iQU1EIjovZ2Vmb3JjZS9pLnRlc3QodCk/Ik5WSURJQSI6KC8oYWRyZW5vfGFtZHxhcHBsZXxpbnRlbHxsbHZtfG1hbGl8bWljcm9zb2Z0fG52aWRpYXxwYXJhbGxlbHN8cG93ZXJ2cnxzYW1zdW5nfHN3aWZ0c2hhZGVyfHZpcnR1YWxib3h8dm13YXJlKS9pLmV4ZWModCk/LlswXXx8Im90aGVyIikudG9Mb2NhbGVVcHBlckNhc2UoKTpudWxsKSxXPSIiK1Ysej1fJiZXP3dlKFtfLFddKTp2b2lkIDAsaj1WP1YucmVkdWNlKCgoZSx0LG4pPT5lXit0K24pLDApOnZvaWQgMDtELndlYmdsUGFyYW1zPVcsRC53ZWJnbEJyYW5kQ2FwYWJpbGl0aWVzPXosRC53ZWJnbENhcGFiaWxpdGllcz1qO2NvbnN0IFU9eiYmIUYuaW5jbHVkZXMoeiksJD1qJiYhRy5pbmNsdWRlcyhqKTtyZXR1cm4gVSYmKE0uV0VCR0w9ITAsbWUoIldlYkdMUmVuZGVyaW5nQ29udGV4dC5nZXRQYXJhbWV0ZXIiLCJzdXNwaWNpb3VzIGdwdSIpKSwkJiYoTS5XRUJHTD0hMCxtZSgiV2ViR0xSZW5kZXJpbmdDb250ZXh0LmdldFBhcmFtZXRlciIsInN1c3BpY2lvdXMgY2FwYWJpbGl0aWVzIikpLEUoe3RpbWU6bi5zdG9wKCksdGVzdDoid2ViZ2wiLHBhc3NlZDohMH0pLHsuLi5ILGdwdTp7Li4ubGUoKEgucGFyYW1ldGVyc3x8e30pLlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMKXx8e30sY29tcHJlc3NlZEdQVTpjZSgoSC5wYXJhbWV0ZXJzfHx7fSkuVU5NQVNLRURfUkVOREVSRVJfV0VCR0wpfX19Y2F0Y2goZSl7cmV0dXJuIEUoe3Rlc3Q6IndlYmdsIixwYXNzZWQ6ITF9KSx2b2lkIFIoZSl9dmFyIHR9ZnVuY3Rpb24gWmUoKXt0cnl7Y29uc3QgZT13KCk7ZS5zdGFydCgpO2NvbnN0IHQ9WXx8d2luZG93O2xldCBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHQpLmZpbHRlcigoZT0+IS9ffFxkezMsfS8udGVzdChlKSkpO2NvbnN0IG89IkV2ZW50IixyPVsiUGVyZm9ybWFuY2VOYXZpZ2F0aW9uVGltaW5nIiwiUGVyZm9ybWFuY2UiXTtpZihhKXtjb25zdCBlPW4uaW5kZXhPZihvKTstMSE9ZSYmKG49bi5zbGljZSgwLGUpLmNvbmNhdChuLnNsaWNlKGUrMSkpLG49Wy4uLm4sb10pLHIuZm9yRWFjaCgoZT0+e2NvbnN0IHQ9bi5pbmRleE9mKGUpO3JldHVybi0xIT10JiYobj1uLnNsaWNlKDAsdCkuY29uY2F0KG4uc2xpY2UodCsxKSkpLG59KSl9Y29uc3QgaT1uLmZpbHRlcigoZT0+L21vei9pLnRlc3QoZSkpKS5sZW5ndGgscz1uLmZpbHRlcigoZT0+L3dlYmtpdC9pLnRlc3QoZSkpKS5sZW5ndGgsYz1uLmZpbHRlcigoZT0+L2FwcGxlL2kudGVzdChlKSkpLmxlbmd0aCxsPXtrZXlzOm4sYXBwbGU6Yyxtb3o6aSx3ZWJraXQ6c307cmV0dXJuIEUoe3RpbWU6ZS5zdG9wKCksdGVzdDoid2luZG93IixwYXNzZWQ6ITB9KSx7Li4ubH19Y2F0Y2goZSl7cmV0dXJuIEUoe3Rlc3Q6IndpbmRvdyIscGFzc2VkOiExfSksdm9pZCBSKGUpfX0hYXN5bmMgZnVuY3Rpb24oKXtpZigwPT1hd2FpdCB5ZSgpKXJldHVybjthd2FpdCBuZXcgUHJvbWlzZSgoZT0+c2V0VGltZW91dCgoKCk9PmUobnVsbCkpKSkpLGZ1bmN0aW9uKCl7bGV0IGU9MCx0PTAsbj0wO3RyeXtjb25zdCBlPSgpPT57bis9MSxlKCl9O2UoKX1jYXRjaHtlPW47dHJ5e249MDtjb25zdCBlPSgpPT57bis9MSxlKCl9O2UoKX1jYXRjaHt0PW59fVtlLHQsOCp0LyhlLXQpXS5qb2luKCI6Iil9KCksYXdhaXQgYXN5bmMgZnVuY3Rpb24oKXtjb25zdCBlPW47ZnVuY3Rpb24gdCgpe2NvbnN0IGU9WyJEeG5MQ0tmTnp3NTAiLCJudGUwbnZMTnpLem95RyIsInNnOVV6WWJsQjI1TmlmbjB5dzVLeXhqS2lmclBCd3UiLCJBaGpMekciLCJuZnJBc0tuV3phIiwiRGc5dERoalBCTUMiLCJxdzVLQ005UHphIiwiblphNW10Q1ludkR6eXZuYnFHIiwiQndmNHZnOTF5MkhxQjJMVURobSIsIkJ3ZjB5MkhMQ1ciLCJBdzVKQmh2S3p4bSIsIm50SzRtdEMxbWZIcUF3UGpEYSIsIkNnck12TUxMRDJ2WXJ3NUh5TVhMemEiLCJtSmEzemZucHZodnAiLCJtWnUxbVppWm1aajJyZzllQmc0IiwibXRHMEN3TFZ6MmpKIiwibXRhM25kS1huTm5WenhuSURxIiwibUptWW5KYmtCZ1Q2dGdHIiwibVphMW5ncjJ3ZkhuQ2EiLCJ5d2pWRHhxNnlNWEhCTVMiLCJuSmFYb3RxM0RManlDdmZvIiwia2hiVkF3NTB6eGk2aWd6UEJNdVAiXTtyZXR1cm4odD1mdW5jdGlvbigpe3JldHVybiBlfSkoKX1mdW5jdGlvbiBuKGUsYSl7Y29uc3Qgbz10KCk7cmV0dXJuIG49ZnVuY3Rpb24odCxhKXtsZXQgcj1vW3QtPTIzNV07dm9pZCAwPT09bi5mbWRZYlomJihuLk5iZlhpZj1mdW5jdGlvbihlKXtsZXQgdD0iIixuPSIiO2ZvcihsZXQgbixhLG89MCxyPTA7YT1lLmNoYXJBdChyKyspO35hJiYobj1vJTQ/NjQqbithOmEsbysrJTQpP3QrPVN0cmluZy5mcm9tQ2hhckNvZGUoMjU1Jm4+PigtMipvJjYpKTowKWE9ImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5Ky89Ii5pbmRleE9mKGEpO2ZvcihsZXQgZT0wLGE9dC5sZW5ndGg7ZTxhO2UrKyluKz0iJSIrKCIwMCIrdC5jaGFyQ29kZUF0KGUpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO3JldHVybiBkZWNvZGVVUklDb21wb25lbnQobil9LGU9YXJndW1lbnRzLG4uZm1kWWJaPSEwKTtjb25zdCBpPXQrb1swXSxzPWVbaV07cmV0dXJuIHM/cj1zOihyPW4uTmJmWGlmKHIpLGVbaV09cikscn0sbihlLGEpfSFmdW5jdGlvbihlLHQpe2NvbnN0IGE9bixvPWUoKTtmb3IoOzspdHJ5e2lmKDc3MDA2ND09cGFyc2VJbnQoYSgiMHhmOSIpKS8xKy1wYXJzZUludChhKCIweGZhIikpLzIqKHBhcnNlSW50KGEoIjB4ZjYiKSkvMykrLXBhcnNlSW50KGEoIjB4ZWQiKSkvNCoocGFyc2VJbnQoYSgiMHhmMCIpKS81KSstcGFyc2VJbnQoYSgiMHhmYiIpKS82KihwYXJzZUludChhKCIweDEwMCIpKS83KSstcGFyc2VJbnQoYSgiMHhmOCIpKS84KihwYXJzZUludChhKCIweGZkIikpLzkpK3BhcnNlSW50KGEoIjB4ZjQiKSkvMTArcGFyc2VJbnQoYSgiMHhmNyIpKS8xMSlicmVhaztvLnB1c2goby5zaGlmdCgpKX1jYXRjaChlKXtvLnB1c2goby5zaGlmdCgpKX19KHQpLG1hdGNoTWVkaWEoZSgiMHhmZSIpKVtlKCIweGYyIildJiYwPT09bmF2aWdhdG9yW2UoIjB4ZjEiKV0mJmUoIjB4ZjUiKWluIG5hdmlnYXRvciYmIW5hdmlnYXRvcltlKCIweGY1IildJiZuYXZpZ2F0b3JbZSgiMHhmZiIpXS5pbmNsdWRlcyhlKCIweGVmIikpJiYobmV3IERhdGUpW2UoIjB4ZWUiKV0oKVtlKCIweGYzIildKGUoIjB4ZWIiKSkmJihsb2NhdGlvbltlKCIweGVjIildPWUoIjB4ZmMiKSxhd2FpdCBuZXcgUHJvbWlzZSgoZT0+e30pKSl9KCk7Y29uc3QgZT0hIW4mJmF3YWl0IHMoKSx0PWU/YygpOnt9LGE9ZSYmKHQuc3RhbmRhcmR8fHQuc3RyaWN0KSx7ZmluZ2VycHJpbnQ6byxzdHlsZVN5c3RlbUhhc2g6cixzdHlsZUhhc2g6aSxkb21SZWN0SGFzaDpkLG1pbWVUeXBlc0hhc2g6bSxjYW52YXMyZEltYWdlSGFzaDp1LGNhbnZhczJkUGFpbnRIYXNoOmcsY2FudmFzMmRUZXh0SGFzaDpwLGNhbnZhczJkRW1vamlIYXNoOmgsY2FudmFzV2ViZ2xJbWFnZUhhc2g6YixjYW52YXNXZWJnbFBhcmFtZXRlcnNIYXNoOmYsZGV2aWNlT2ZUaW1lem9uZUhhc2g6Uyx0aW1lRW5kOnl9PWF3YWl0KGFzeW5jKCk9Pntjb25zdCBlPUwoKSx0PUwoKSxbbixvLHIsaSxzLGMsZCxtLHUsZyxwLGgsYixmLFMseSxFLHcsa109YXdhaXQgUHJvbWlzZS5hbGwoW0VlKCksS2UoKSxNZSgpLEplKCkseGUoKSxaZSgpLEllKCksUmUoKSxOZSgpLHFlKCksemUoKSxQZSgpLFFlKCksTGUoKSxiZSgpLGplKCksWWUoKSwkZSgpLFdlKCldKS5jYXRjaCgoZT0+Y29uc29sZS5lcnJvcihlLm1lc3NhZ2UpKSksdj1hd2FpdCBVZShuKS5jYXRjaCgoZT0+Y29uc29sZS5lcnJvcihlLm1lc3NhZ2UpKSksW0EsRF09YXdhaXQgUHJvbWlzZS5hbGwoW19lKHt3ZWJnbDppLHdvcmtlclNjb3BlOm59KSxGZSh7Y3NzQ29tcHV0ZWQ6bSxuYXZpZ2F0b3JDb21wdXRlZDp2LHdpbmRvd0ZlYXR1cmVzQ29tcHV0ZWQ6Y30pXSkuY2F0Y2goKGU9PmNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlKSkpLFtNLEMsVF09YXdhaXQgUHJvbWlzZS5hbGwoW3JlKCkse3RyYXNoQmluOmRlLmdldEJpbigpfSx7ZGF0YTp4LmdldEVycm9ycygpfV0pLmNhdGNoKChlPT5jb25zb2xlLmVycm9yKGUubWVzc2FnZSkpKTt0KCk7Y29uc3R7cGFyYW1ldGVyczpSfT1pfHx7fSxOPXsuLi5hP2woUik6UixSRU5ERVJFUjp2b2lkIDAsU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OOnZvaWQgMCxVTk1BU0tFRF9SRU5ERVJFUl9XRUJHTDp2b2lkIDAsVU5NQVNLRURfVkVORE9SX1dFQkdMOnZvaWQgMCxWRVJTSU9OOnZvaWQgMCxWRU5ET1I6dm9pZCAwfSxJPUwoKSxbUCxPLEIsSCxGLEcsVixfLFcseixqLFUsJCxYLHEsSyxZLEosWixlZSx0ZSxuZSxhZSxvZSxpZSxzZSxjZSxsZSxtZSx1ZSxnZSxwZSxoZSxmZSxTZSx5ZSx3ZSxrZV09YXdhaXQgUHJvbWlzZS5hbGwoW3ZlKGMpLHZlKEEpLHZlKChkfHx7fSkua2V5cyksdmUodSksdmUobSksdmUoKG18fHt9KS5jb21wdXRlZFN0eWxlKSx2ZSgobXx8e30pLnN5c3RlbSksdmUoZyksdmUobyksdmUocyksdmUoKHN8fHt9KS5kYXRhVVJJKSx2ZSgoc3x8e30pLnBhaW50VVJJKSx2ZSgoc3x8e30pLnRleHRVUkkpLHZlKChzfHx7fSkuZW1vamlVUkkpLHZlKGkpLHZlKChpfHx7fSkuZGF0YVVSSSksdmUoTiksKChpfHx7fSkucGl4ZWxzfHxbXSkubGVuZ3RoP3ZlKGkucGl4ZWxzKTp2b2lkIDAsKChpfHx7fSkucGl4ZWxzMnx8W10pLmxlbmd0aD92ZShpLnBpeGVsczIpOnZvaWQgMCx2ZSgocHx8e30pLmRhdGEpLHZlKChofHx7fSkuZXJyb3JzKSx2ZShiKSx2ZShmKSx2ZShbKGZ8fHt9KS5lbGVtZW50Qm91bmRpbmdDbGllbnRSZWN0LChmfHx7fSkuZWxlbWVudENsaWVudFJlY3RzLChmfHx7fSkucmFuZ2VCb3VuZGluZ0NsaWVudFJlY3QsKGZ8fHt9KS5yYW5nZUNsaWVudFJlY3RzXSksdmUociksdmUoUyksdmUobiksdmUoeSksdmUoKHl8fHt9KS5taW1lVHlwZXMpLHZlKHYpLHZlKE0pLHZlKEMpLHZlKFQpLHZlKEUpLHZlKHcpLHZlKGspLHZlKEQpLHZlKCgoKT0+e2NvbnN0e2JsdWV0b290aEF2YWlsYWJpbGl0eTplLGRldmljZTp0LGRldmljZU1lbW9yeTphLGhhcmR3YXJlQ29uY3VycmVuY3k6byxtYXhUb3VjaFBvaW50czpyLG9zY3B1OmkscGxhdGZvcm06cyxzeXN0ZW06Yyx1c2VyQWdlbnREYXRhOmx9PXZ8fHt9LHthcmNoaXRlY3R1cmU6ZCxiaXRuZXNzOm0sbW9iaWxlOnAsbW9kZWw6aCxwbGF0Zm9ybTpmLHBsYXRmb3JtVmVyc2lvbjpTfT1sfHx7fSx7YW55UG9pbnRlcjp5fT11fHx7fSx7Y29sb3JEZXB0aDpFLHBpeGVsRGVwdGg6dyxoZWlnaHQ6ayx3aWR0aDpBfT1nfHx7fSx7bG9jYXRpb246RCxsb2NhdGlvbkVwb2NoOk0sem9uZTpDfT1ifHx7fSx7ZGV2aWNlTWVtb3J5OlQsaGFyZHdhcmVDb25jdXJyZW5jeTp4LGdwdTpSLHBsYXRmb3JtOk4sc3lzdGVtOkksdGltZXpvbmVMb2NhdGlvbjpMLHVzZXJBZ2VudERhdGE6UH09bnx8e30se2NvbXByZXNzZWRHUFU6Tyxjb25maWRlbmNlOkJ9PVJ8fHt9LHthcmNoaXRlY3R1cmU6SCxiaXRuZXNzOkYsbW9iaWxlOkcsbW9kZWw6VixwbGF0Zm9ybTpfLHBsYXRmb3JtVmVyc2lvbjpXfT1QfHx7fTtyZXR1cm5beSxkLEgsbSxGLGUsRSwuLi5PJiYibG93IiE9Qj9bT106W10sdCxhLFQsbyx4LGssRCxMLE0scixwLEcsaCxWLGksdyxzLE4sUyxXLGMsSSxmLF8sQSxDXX0pKCkpXSkuY2F0Y2goKGU9PmNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlKSkpO0koKTtjb25zdCBBZT1lKCk7USYmUS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKFEpO3JldHVybntmaW5nZXJwcmludDp7d29ya2VyU2NvcGU6bj97Li4ubiwkaGFzaDpjZX06dm9pZCAwLG5hdmlnYXRvcjp2P3suLi52LCRoYXNoOnVlfTp2b2lkIDAsd2luZG93RmVhdHVyZXM6Yz97Li4uYywkaGFzaDpQfTp2b2lkIDAsaGVhZGxlc3M6QT97Li4uQSwkaGFzaDpPfTp2b2lkIDAsaHRtbEVsZW1lbnRWZXJzaW9uOmQ/ey4uLmQsJGhhc2g6Qn06dm9pZCAwLGNzc01lZGlhOnU/ey4uLnUsJGhhc2g6SH06dm9pZCAwLGNzczptP3suLi5tLCRoYXNoOkZ9OnZvaWQgMCxzY3JlZW46Zz97Li4uZywkaGFzaDpffTp2b2lkIDAsdm9pY2VzOm8/ey4uLm8sJGhhc2g6V306dm9pZCAwLG1lZGlhOnk/ey4uLnksJGhhc2g6bGV9OnZvaWQgMCxjYW52YXMyZDpzP3suLi5zLCRoYXNoOnp9OnZvaWQgMCxjYW52YXNXZWJnbDppP3suLi5pLHBpeGVsczpKLHBpeGVsczI6WiwkaGFzaDpxfTp2b2lkIDAsbWF0aHM6cD97Li4ucCwkaGFzaDplZX06dm9pZCAwLGNvbnNvbGVFcnJvcnM6aD97Li4uaCwkaGFzaDp0ZX06dm9pZCAwLHRpbWV6b25lOmI/ey4uLmIsJGhhc2g6bmV9OnZvaWQgMCxjbGllbnRSZWN0czpmP3suLi5mLCRoYXNoOmFlfTp2b2lkIDAsb2ZmbGluZUF1ZGlvQ29udGV4dDpyP3suLi5yLCRoYXNoOmllfTp2b2lkIDAsZm9udHM6Uz97Li4uUywkaGFzaDpzZX06dm9pZCAwLGxpZXM6TT97Li4uTSwkaGFzaDpnZX06dm9pZCAwLHRyYXNoOkM/ey4uLkMsJGhhc2g6cGV9OnZvaWQgMCxjYXB0dXJlZEVycm9yczpUP3suLi5ULCRoYXNoOmhlfTp2b2lkIDAsc3ZnOkU/ey4uLkUsJGhhc2g6ZmV9OnZvaWQgMCxyZXNpc3RhbmNlOnc/ey4uLncsJGhhc2g6U2V9OnZvaWQgMCxpbnRsOms/ey4uLmssJGhhc2g6eWV9OnZvaWQgMCxmZWF0dXJlczpEP3suLi5ELCRoYXNoOndlfTp2b2lkIDB9LHN0eWxlU3lzdGVtSGFzaDpWLHN0eWxlSGFzaDpHLGRvbVJlY3RIYXNoOm9lLG1pbWVUeXBlc0hhc2g6bWUsY2FudmFzMmRJbWFnZUhhc2g6aixjYW52YXNXZWJnbEltYWdlSGFzaDpLLGNhbnZhczJkUGFpbnRIYXNoOlUsY2FudmFzMmRUZXh0SGFzaDokLGNhbnZhczJkRW1vamlIYXNoOlgsY2FudmFzV2ViZ2xQYXJhbWV0ZXJzSGFzaDpZLGRldmljZU9mVGltZXpvbmVIYXNoOmtlLHRpbWVFbmQ6QWV9fSkoKS5jYXRjaCgoZT0+Y29uc29sZS5lcnJvcihlKSkpfHx7fTtpZighbyl0aHJvdyBuZXcgRXJyb3IoIkZpbmdlcnByaW50IGZhaWxlZCEiKTtvLmNhbnZhczJkPy50ZXh0TWV0cmljc1N5c3RlbVN1bSxvLnRyYXNoLnRyYXNoQmluLmxlbmd0aCwidG90YWxMaWVzImluIG8ubGllcyYmby5saWVzLnRvdGFsTGllcyxvLmNhcHR1cmVkRXJyb3JzLmRhdGEubGVuZ3RoO2NvbnN0IEU9KGUsdCk9PmU/ZS5sb2NhbGVFbnRyb3B5SXNUcnVzdHkmJmUubG9jYWxlSW50bEVudHJvcHlJc1RydXN0eT90OnZvaWQgMDp0LHc9by5yZXNpc3RhbmNlJiYvXih0b3IgYnJvd3NlcnxmaXJlZm94KSQvaS50ZXN0KG8ucmVzaXN0YW5jZS5wcml2YWN5KSxrPWU9Pntjb25zdHtncHU6e2NvbmZpZGVuY2U6dCxjb21wcmVzc2VkR1BVOm59fT1lO3JldHVybiJsb3ciPT10P3t9OntVTk1BU0tFRF9SRU5ERVJFUl9XRUJHTDpuLFVOTUFTS0VEX1ZFTkRPUl9XRUJHTDplLnBhcmFtZXRlcnMuVU5NQVNLRURfVkVORE9SX1dFQkdMfX0sdj17bmF2aWdhdG9yOiFvLm5hdmlnYXRvcnx8by5uYXZpZ2F0b3IubGllZD92b2lkIDA6e2JsdWV0b290aEF2YWlsYWJpbGl0eTpvLm5hdmlnYXRvci5ibHVldG9vdGhBdmFpbGFiaWxpdHksZGV2aWNlOm8ubmF2aWdhdG9yLmRldmljZSxkZXZpY2VNZW1vcnk6by5uYXZpZ2F0b3IuZGV2aWNlTWVtb3J5LGhhcmR3YXJlQ29uY3VycmVuY3k6by5uYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSxtYXhUb3VjaFBvaW50czpvLm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyxvc2NwdTpvLm5hdmlnYXRvci5vc2NwdSxwbGF0Zm9ybTpvLm5hdmlnYXRvci5wbGF0Zm9ybSxzeXN0ZW06by5uYXZpZ2F0b3Iuc3lzdGVtLHVzZXJBZ2VudERhdGE6ey4uLm8ubmF2aWdhdG9yLnVzZXJBZ2VudERhdGF8fHt9LGJyYW5kc1ZlcnNpb246dm9pZCAwLHVhRnVsbFZlcnNpb246dm9pZCAwfSx2ZW5kb3I6by5uYXZpZ2F0b3IudmVuZG9yfSxzY3JlZW46IW8uc2NyZWVufHxvLnNjcmVlbi5saWVkfHx3fHxNLlNDUkVFTj92b2lkIDA6RShvLndvcmtlclNjb3BlLHtoZWlnaHQ6by5zY3JlZW4uaGVpZ2h0LHdpZHRoOm8uc2NyZWVuLndpZHRoLHBpeGVsRGVwdGg6by5zY3JlZW4ucGl4ZWxEZXB0aCxjb2xvckRlcHRoOm8uc2NyZWVuLmNvbG9yRGVwdGgsbGllZDpvLnNjcmVlbi5saWVkfSksd29ya2VyU2NvcGU6IW8ud29ya2VyU2NvcGV8fG8ud29ya2VyU2NvcGUubGllZD92b2lkIDA6e2RldmljZU1lbW9yeTphP3ZvaWQgMDpvLndvcmtlclNjb3BlLmRldmljZU1lbW9yeSxoYXJkd2FyZUNvbmN1cnJlbmN5OmE/dm9pZCAwOm8ud29ya2VyU2NvcGUuaGFyZHdhcmVDb25jdXJyZW5jeSxsYW5ndWFnZTpNLlRJTUVfWk9ORT92b2lkIDA6by53b3JrZXJTY29wZS5sYW5ndWFnZSxwbGF0Zm9ybTpvLndvcmtlclNjb3BlLnBsYXRmb3JtLHN5c3RlbTpvLndvcmtlclNjb3BlLnN5c3RlbSxkZXZpY2U6by53b3JrZXJTY29wZS5kZXZpY2UsdGltZXpvbmVMb2NhdGlvbjpNLlRJTUVfWk9ORT92b2lkIDA6RShvLndvcmtlclNjb3BlLG8ud29ya2VyU2NvcGUudGltZXpvbmVMb2NhdGlvbiksd2ViZ2xSZW5kZXJlcjoibG93IiE9by53b3JrZXJTY29wZS5ncHUuY29uZmlkZW5jZT9vLndvcmtlclNjb3BlLmdwdS5jb21wcmVzc2VkR1BVOnZvaWQgMCx3ZWJnbFZlbmRvcjoibG93IiE9by53b3JrZXJTY29wZS5ncHUuY29uZmlkZW5jZT9vLndvcmtlclNjb3BlLndlYmdsVmVuZG9yOnZvaWQgMCx1c2VyQWdlbnREYXRhOnsuLi5vLndvcmtlclNjb3BlLnVzZXJBZ2VudERhdGEsYnJhbmRzVmVyc2lvbjp2b2lkIDAsdWFGdWxsVmVyc2lvbjp2b2lkIDB9fSxtZWRpYTpvLm1lZGlhLGNhbnZhczJkOihlPT57aWYoIWUpcmV0dXJuO2NvbnN0e2xpZWQ6dCxsaWVkVGV4dE1ldHJpY3M6bn09ZTtsZXQgYTtpZighdCl7Y29uc3R7ZGF0YVVSSTpuLHBhaW50VVJJOm8sdGV4dFVSSTpyLGVtb2ppVVJJOml9PWU7YT17bGllZDp0LGRhdGFVUkk6bixwYWludFVSSTpvLHRleHRVUkk6cixlbW9qaVVSSTppfX1pZighbil7Y29uc3R7dGV4dE1ldHJpY3NTeXN0ZW1TdW06dCxlbW9qaVNldDpufT1lO2E9ey4uLmF8fHt9LHRleHRNZXRyaWNzU3lzdGVtU3VtOnQsZW1vamlTZXQ6bn19cmV0dXJuIGF9KShvLmNhbnZhczJkKSxjYW52YXNXZWJnbDohby5jYW52YXNXZWJnbHx8by5jYW52YXNXZWJnbC5saWVkfHxNLldFQkdMP3ZvaWQgMDphP3twYXJhbWV0ZXJzOnsuLi5sKG8uY2FudmFzV2ViZ2wucGFyYW1ldGVycyksLi4uayhvLmNhbnZhc1dlYmdsKX19OnsuLi4oKGUsdCk9PntpZih0JiZ0LmxpZWR8fE0uQ0FOVkFTKXtjb25zdHtleHRlbnNpb25zOnQsZ3B1Om4sbGllZDphLHBhcmFtZXRlck9yRXh0ZW5zaW9uTGllOm99PWU7cmV0dXJue2V4dGVuc2lvbnM6dCxncHU6bixsaWVkOmEscGFyYW1ldGVyT3JFeHRlbnNpb25MaWU6b319cmV0dXJuIGV9KShvLmNhbnZhc1dlYmdsLG8uY2FudmFzMmQpLHBhcmFtZXRlcnM6ey4uLm8uY2FudmFzV2ViZ2wucGFyYW1ldGVycywuLi5rKG8uY2FudmFzV2ViZ2wpfX0sY3NzTWVkaWE6by5jc3NNZWRpYT97cmVkdWNlZE1vdGlvbjpJKCgoKT0+by5jc3NNZWRpYS5tZWRpYUNTU1sicHJlZmVycy1yZWR1Y2VkLW1vdGlvbiJdKSksY29sb3JTY2hlbWU6YT92b2lkIDA6SSgoKCk9Pm8uY3NzTWVkaWEubWVkaWFDU1NbInByZWZlcnMtY29sb3Itc2NoZW1lIl0pKSxtb25vY2hyb21lOkkoKCgpPT5vLmNzc01lZGlhLm1lZGlhQ1NTLm1vbm9jaHJvbWUpKSxpbnZlcnRlZENvbG9yczpJKCgoKT0+by5jc3NNZWRpYS5tZWRpYUNTU1siaW52ZXJ0ZWQtY29sb3JzIl0pKSxmb3JjZWRDb2xvcnM6SSgoKCk9Pm8uY3NzTWVkaWEubWVkaWFDU1NbImZvcmNlZC1jb2xvcnMiXSkpLGFueUhvdmVyOkkoKCgpPT5vLmNzc01lZGlhLm1lZGlhQ1NTWyJhbnktaG92ZXIiXSkpLGhvdmVyOkkoKCgpPT5vLmNzc01lZGlhLm1lZGlhQ1NTLmhvdmVyKSksYW55UG9pbnRlcjpJKCgoKT0+by5jc3NNZWRpYS5tZWRpYUNTU1siYW55LXBvaW50ZXIiXSkpLHBvaW50ZXI6SSgoKCk9Pm8uY3NzTWVkaWEubWVkaWFDU1MucG9pbnRlcikpLGNvbG9yR2FtdXQ6SSgoKCk9Pm8uY3NzTWVkaWEubWVkaWFDU1NbImNvbG9yLWdhbXV0Il0pKSxzY3JlZW5RdWVyeTp3fHxNLlNDUkVFTnx8TS5JRlJBTUVfU0NSRUVOP3ZvaWQgMDpFKG8ud29ya2VyU2NvcGUsSSgoKCk9Pm8uY3NzTWVkaWEuc2NyZWVuUXVlcnkpKSl9OnZvaWQgMCxjc3M6by5jc3M/by5jc3Muc3lzdGVtLmZvbnRzOnZvaWQgMCx0aW1lem9uZTohby50aW1lem9uZXx8by50aW1lem9uZS5saWVkfHxNLlRJTUVfWk9ORT92b2lkIDA6e2xvY2F0aW9uTWVhc3VyZWQ6RShvLndvcmtlclNjb3BlLG8udGltZXpvbmUubG9jYXRpb25NZWFzdXJlZCksbGllZDpvLnRpbWV6b25lLmxpZWR9LG9mZmxpbmVBdWRpb0NvbnRleHQ6by5vZmZsaW5lQXVkaW9Db250ZXh0P28ub2ZmbGluZUF1ZGlvQ29udGV4dC5saWVkfHxNLkFVRElPP3ZvaWQgMDpvLm9mZmxpbmVBdWRpb0NvbnRleHQ6dm9pZCAwLGZvbnRzOiFvLmZvbnRzfHxvLmZvbnRzLmxpZWR8fE0uRk9OVFM/dm9pZCAwOm8uZm9udHMuZm9udEZhY2VMb2FkRm9udHMsZm9yY2VSZW5ldzoxNjcyMDA1NTAzOTAxfTtsZXQgQTtkZWxldGUgdi5jc3NNZWRpYS5zY3JlZW5RdWVyeSxkZWxldGUgdi5zY3JlZW47dHJ5e0E9UmVmbGVjdC5zZXRQcm90b3R5cGVPZihuYXZpZ2F0b3IsT2JqZWN0LmNyZWF0ZShuYXZpZ2F0b3IpKX1jYXRjaChlKXtBPSEwfUE/by5oZWFkbGVzcy5oZWFkbGVzcy53ZWJEcml2ZXJJc09uPSEwOm8uaGVhZGxlc3MuaGVhZGxlc3Mud3RmbWF0ZT0hMDtjb25zdFtELENdPWF3YWl0IFByb21pc2UuYWxsKFt2ZShvKSx2ZSh2KV0pLmNhdGNoKChlPT57Y29uc29sZS5lcnJvcihlLm1lc3NhZ2UpfSkpfHxbXX0oKX0oKTsKLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlZXAuanMubWFwCg==')], { type: 'text/javascript' }))

        /// DATA

        // @ts-expect-error
const IS_WORKER_SCOPE = !self.document && self.WorkerGlobalScope;
// Detect Browser
function getEngine() {
    const x = [].constructor;
    try {
        (-1).toFixed(-1);
    }
    catch (err) {
        return err.message.length + (x + '').split(x.name).join('').length;
    }
}
const ENGINE_IDENTIFIER = getEngine();
const IS_BLINK = ENGINE_IDENTIFIER == 80;
const IS_GECKO = ENGINE_IDENTIFIER == 58;
const IS_WEBKIT = ENGINE_IDENTIFIER == 77;
const JS_ENGINE = ({
    80: 'V8',
    58: 'SpiderMonkey',
    77: 'JavaScriptCore',
})[ENGINE_IDENTIFIER] || null;
const LIKE_BRAVE = IS_BLINK && 'flat' in Array.prototype /* Chrome 69 */ && !('ReportingObserver' in self /* Brave */);
function braveBrowser() {
    const brave = ('brave' in navigator &&
        // @ts-ignore
        Object.getPrototypeOf(navigator.brave).constructor.name == 'Brave' &&
        // @ts-ignore
        navigator.brave.isBrave.toString() == 'function isBrave() { [native code] }');
    return brave;
}
function getBraveMode() {
    const mode = {
        unknown: false,
        allow: false,
        standard: false,
        strict: false,
    };
    try {
        // strict mode adds float frequency data AnalyserNode
        const strictMode = () => {
            try {
                window.OfflineAudioContext = (
                // @ts-ignore
                OfflineAudioContext || webkitOfflineAudioContext);
            }
            catch (err) { }
            if (!window.OfflineAudioContext) {
                return false;
            }
            const context = new OfflineAudioContext(1, 1, 44100);
            const analyser = context.createAnalyser();
            const data = new Float32Array(analyser.frequencyBinCount);
            analyser.getFloatFrequencyData(data);
            const strict = new Set(data).size > 1; // native only has -Infinity
            return strict;
        };
        if (strictMode()) {
            mode.strict = true;
            return mode;
        }
        // standard and strict mode do not have chrome plugins
        const chromePlugins = /(Chrom(e|ium)|Microsoft Edge) PDF (Plugin|Viewer)/;
        const pluginsList = [...navigator.plugins];
        const hasChromePlugins = pluginsList
            .filter((plugin) => chromePlugins.test(plugin.name)).length == 2;
        if (pluginsList.length && !hasChromePlugins) {
            mode.standard = true;
            return mode;
        }
        mode.allow = true;
        return mode;
    }
    catch (e) {
        mode.unknown = true;
        return mode;
    }
}
const getBraveUnprotectedParameters = (parameters) => {
    const blocked = new Set([
        'FRAGMENT_SHADER.HIGH_FLOAT.precision',
        'FRAGMENT_SHADER.HIGH_FLOAT.rangeMax',
        'FRAGMENT_SHADER.HIGH_FLOAT.rangeMin',
        'FRAGMENT_SHADER.HIGH_INT.precision',
        'FRAGMENT_SHADER.HIGH_INT.rangeMax',
        'FRAGMENT_SHADER.HIGH_INT.rangeMin',
        'FRAGMENT_SHADER.LOW_FLOAT.precision',
        'FRAGMENT_SHADER.LOW_FLOAT.rangeMax',
        'FRAGMENT_SHADER.LOW_FLOAT.rangeMin',
        'FRAGMENT_SHADER.MEDIUM_FLOAT.precision',
        'FRAGMENT_SHADER.MEDIUM_FLOAT.rangeMax',
        'FRAGMENT_SHADER.MEDIUM_FLOAT.rangeMin',
        'MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS',
        'MAX_COMBINED_UNIFORM_BLOCKS',
        'MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS',
        'MAX_DRAW_BUFFERS_WEBGL',
        'MAX_FRAGMENT_INPUT_COMPONENTS',
        'MAX_FRAGMENT_UNIFORM_BLOCKS',
        'MAX_FRAGMENT_UNIFORM_COMPONENTS',
        'MAX_TEXTURE_MAX_ANISOTROPY_EXT',
        'MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS',
        'MAX_UNIFORM_BUFFER_BINDINGS',
        'MAX_VARYING_COMPONENTS',
        'MAX_VERTEX_OUTPUT_COMPONENTS',
        'MAX_VERTEX_UNIFORM_BLOCKS',
        'MAX_VERTEX_UNIFORM_COMPONENTS',
        'SHADING_LANGUAGE_VERSION',
        'UNMASKED_RENDERER_WEBGL',
        'UNMASKED_VENDOR_WEBGL',
        'VERSION',
        'VERTEX_SHADER.HIGH_FLOAT.precision',
        'VERTEX_SHADER.HIGH_FLOAT.rangeMax',
        'VERTEX_SHADER.HIGH_FLOAT.rangeMin',
        'VERTEX_SHADER.HIGH_INT.precision',
        'VERTEX_SHADER.HIGH_INT.rangeMax',
        'VERTEX_SHADER.HIGH_INT.rangeMin',
        'VERTEX_SHADER.LOW_FLOAT.precision',
        'VERTEX_SHADER.LOW_FLOAT.rangeMax',
        'VERTEX_SHADER.LOW_FLOAT.rangeMin',
        'VERTEX_SHADER.MEDIUM_FLOAT.precision',
        'VERTEX_SHADER.MEDIUM_FLOAT.rangeMax',
        'VERTEX_SHADER.MEDIUM_FLOAT.rangeMin',
    ]);
    const safeParameters = Object.keys(parameters).reduce((acc, curr) => {
        if (blocked.has(curr)) {
            return acc;
        }
        acc[curr] = parameters[curr];
        return acc;
    }, {});
    return safeParameters;
};
// system
const getOS = (userAgent) => {
    const os = (
    // order is important
    /windows phone/ig.test(userAgent) ? 'Windows Phone' :
        /win(dows|16|32|64|95|98|nt)|wow64/ig.test(userAgent) ? 'Windows' :
            /android/ig.test(userAgent) ? 'Android' :
                /cros/ig.test(userAgent) ? 'Chrome OS' :
                    /linux/ig.test(userAgent) ? 'Linux' :
                        /ipad/ig.test(userAgent) ? 'iPad' :
                            /iphone/ig.test(userAgent) ? 'iPhone' :
                                /ipod/ig.test(userAgent) ? 'iPod' :
                                    /ios/ig.test(userAgent) ? 'iOS' :
                                        /mac/ig.test(userAgent) ? 'Mac' :
                                            'Other');
    return os;
};
function getReportedPlatform(userAgent, platform) {
    // user agent os lie
    const userAgentOS = (
    // order is important
    /win(dows|16|32|64|95|98|nt)|wow64/ig.test(userAgent) ? "Windows" /* PlatformClassifier.WINDOWS */ :
        /android|linux|cros/ig.test(userAgent) ? "Linux" /* PlatformClassifier.LINUX */ :
            /(i(os|p(ad|hone|od)))|mac/ig.test(userAgent) ? "Apple" /* PlatformClassifier.APPLE */ :
                "Other" /* PlatformClassifier.OTHER */);
    if (!platform)
        return [userAgentOS];
    const platformOS = (
    // order is important
    /win/ig.test(platform) ? "Windows" /* PlatformClassifier.WINDOWS */ :
        /android|arm|linux/ig.test(platform) ? "Linux" /* PlatformClassifier.LINUX */ :
            /(i(os|p(ad|hone|od)))|mac/ig.test(platform) ? "Apple" /* PlatformClassifier.APPLE */ :
                "Other" /* PlatformClassifier.OTHER */);
    return [userAgentOS, platformOS];
}
const { userAgent: navUserAgent, platform: navPlatform } = self.navigator || {};
const [USER_AGENT_OS, PLATFORM_OS] = getReportedPlatform(navUserAgent, navPlatform);
const decryptUserAgent = ({ ua, os, isBrave }) => {
    const apple = /ipad|iphone|ipod|ios|mac/ig.test(os);
    const isOpera = /OPR\//g.test(ua);
    const isVivaldi = /Vivaldi/g.test(ua);
    const isDuckDuckGo = /DuckDuckGo/g.test(ua);
    const isYandex = /YaBrowser/g.test(ua);
    const paleMoon = ua.match(/(palemoon)\/(\d+)./i);
    const edge = ua.match(/(edgios|edg|edge|edga)\/(\d+)./i);
    const edgios = edge && /edgios/i.test(edge[1]);
    const chromium = ua.match(/(crios|chrome)\/(\d+)./i);
    const firefox = ua.match(/(fxios|firefox)\/(\d+)./i);
    const likeSafari = (/AppleWebKit/g.test(ua) &&
        /Safari/g.test(ua));
    const safari = (likeSafari &&
        !firefox &&
        !chromium &&
        !edge &&
        ua.match(/(version)\/(\d+)\.(\d|\.)+\s(mobile|safari)/i));
    if (chromium) {
        const browser = chromium[1];
        const version = chromium[2];
        const like = (isOpera ? ' Opera' :
            isVivaldi ? ' Vivaldi' :
                isDuckDuckGo ? ' DuckDuckGo' :
                    isYandex ? ' Yandex' :
                        edge ? ' Edge' :
                            isBrave ? ' Brave' : '');
        return `${browser} ${version}${like}`;
    }
    else if (edgios) {
        const browser = edge[1];
        const version = edge[2];
        return `${browser} ${version}`;
    }
    else if (firefox) {
        const browser = paleMoon ? paleMoon[1] : firefox[1];
        const version = paleMoon ? paleMoon[2] : firefox[2];
        return `${browser} ${version}`;
    }
    else if (apple && safari) {
        const browser = 'Safari';
        const version = safari[2];
        return `${browser} ${version}`;
    }
    return 'unknown';
};
const getUserAgentPlatform = ({ userAgent, excludeBuild = true }) => {
    if (!userAgent) {
        return 'unknown';
    }
    // patterns
    const nonPlatformParenthesis = /\((khtml|unlike|vizio|like gec|internal dummy|org\.eclipse|openssl|ipv6|via translate|safari|cardamon).+|xt\d+\)/ig;
    const parenthesis = /\((.+)\)/;
    const android = /((android).+)/i;
    const androidNoise = /^(linux|[a-z]|wv|mobile|[a-z]{2}(-|_)[a-z]{2}|[a-z]{2})$|windows|(rv:|trident|webview|iemobile).+/i;
    const androidBuild = /build\/.+\s|\sbuild\/.+/i;
    const androidRelease = /android( |-)\d+/i;
    const windows = /((windows).+)/i;
    const windowsNoise = /^(windows|ms(-|)office|microsoft|compatible|[a-z]|x64|[a-z]{2}(-|_)[a-z]{2}|[a-z]{2})$|(rv:|outlook|ms(-|)office|microsoft|trident|\.net|msie|httrack|media center|infopath|aol|opera|iemobile|webbrowser).+/i;
    const windows64bitCPU = /w(ow|in)64/i;
    const cros = /cros/i;
    const crosNoise = /^([a-z]|x11|[a-z]{2}(-|_)[a-z]{2}|[a-z]{2})$|(rv:|trident).+/i;
    const crosBuild = /\d+\.\d+\.\d+/i;
    const linux = /linux|x11|ubuntu|debian/i;
    const linuxNoise = /^([a-z]|x11|unknown|compatible|[a-z]{2}(-|_)[a-z]{2}|[a-z]{2})$|(rv:|java|oracle|\+http|http|unknown|mozilla|konqueror|valve).+/i;
    const apple = /(cpu iphone|cpu os|iphone os|mac os|macos|intel os|ppc mac).+/i;
    const appleNoise = /^([a-z]|macintosh|compatible|mimic|[a-z]{2}(-|_)[a-z]{2}|[a-z]{2}|rv|\d+\.\d+)$|(rv:|silk|valve).+/i;
    const appleRelease = /(ppc |intel |)(mac|mac |)os (x |x|)(\d{2}(_|\.)\d{1,2}|\d{2,})/i;
    const otherOS = /((symbianos|nokia|blackberry|morphos|mac).+)|\/linux|freebsd|symbos|series \d+|win\d+|unix|hp-ux|bsdi|bsd|x86_64/i;
    const isDevice = (list, device) => list.filter((x) => device.test(x)).length;
    userAgent = userAgent.trim().replace(/\s{2,}/, ' ').replace(nonPlatformParenthesis, '');
    if (parenthesis.test(userAgent)) {
        const platformSection = userAgent.match(parenthesis)[0];
        const identifiers = platformSection.slice(1, -1).replace(/,/g, ';').split(';').map((x) => x.trim());
        if (isDevice(identifiers, android)) {
            return identifiers
                // @ts-ignore
                .map((x) => androidRelease.test(x) ? androidRelease.exec(x)[0].replace('-', ' ') : x)
                .filter((x) => !(androidNoise.test(x)))
                .join(' ')
                .replace((excludeBuild ? androidBuild : ''), '')
                .trim().replace(/\s{2,}/, ' ');
        }
        else if (isDevice(identifiers, windows)) {
            return identifiers
                .filter((x) => !(windowsNoise.test(x)))
                .join(' ')
                .replace(/\sNT (\d+\.\d+)/, (match, version) => {
                return (version == '10.0' ? ' 10' :
                    version == '6.3' ? ' 8.1' :
                        version == '6.2' ? ' 8' :
                            version == '6.1' ? ' 7' :
                                version == '6.0' ? ' Vista' :
                                    version == '5.2' ? ' XP Pro' :
                                        version == '5.1' ? ' XP' :
                                            version == '5.0' ? ' 2000' :
                                                version == '4.0' ? match :
                                                    ' ' + version);
            })
                .replace(windows64bitCPU, '(64-bit)')
                .trim().replace(/\s{2,}/, ' ');
        }
        else if (isDevice(identifiers, cros)) {
            return identifiers
                .filter((x) => !(crosNoise.test(x)))
                .join(' ')
                .replace((excludeBuild ? crosBuild : ''), '')
                .trim().replace(/\s{2,}/, ' ');
        }
        else if (isDevice(identifiers, linux)) {
            return identifiers
                .filter((x) => !(linuxNoise.test(x)))
                .join(' ')
                .trim().replace(/\s{2,}/, ' ');
        }
        else if (isDevice(identifiers, apple)) {
            return identifiers
                .map((x) => {
                if (appleRelease.test(x)) {
                    // @ts-ignore
                    const release = appleRelease.exec(x)[0];
                    const versionMap = {
                        '10_7': 'Lion',
                        '10_8': 'Mountain Lion',
                        '10_9': 'Mavericks',
                        '10_10': 'Yosemite',
                        '10_11': 'El Capitan',
                        '10_12': 'Sierra',
                        '10_13': 'High Sierra',
                        '10_14': 'Mojave',
                        '10_15': 'Catalina',
                        '11': 'Big Sur',
                        '12': 'Monterey',
                        '13': 'Ventura',
                    };
                    const version = ((/(\d{2}(_|\.)\d{1,2}|\d{2,})/.exec(release) || [])[0] ||
                        '').replace(/\./g, '_');
                    const isOSX = /^10/.test(version);
                    const id = isOSX ? version : (/^\d{2,}/.exec(version) || [])[0];
                    const codeName = versionMap[id];
                    return codeName ? `macOS ${codeName}` : release;
                }
                return x;
            })
                .filter((x) => !(appleNoise.test(x)))
                .join(' ')
                .replace(/\slike mac.+/ig, '')
                .trim().replace(/\s{2,}/, ' ');
        }
        else {
            const other = identifiers.filter((x) => otherOS.test(x));
            if (other.length) {
                return other.join(' ').trim().replace(/\s{2,}/, ' ');
            }
            return identifiers.join(' ');
        }
    }
    else {
        return 'unknown';
    }
};
// attempt restore from User-Agent Reduction
const isUAPostReduction = (userAgent) => {
    const matcher = /Mozilla\/5\.0 \((Macintosh; Intel Mac OS X 10_15_7|Windows NT 10\.0; Win64; x64|(X11; (CrOS|Linux) x86_64)|(Linux; Android 10(; K|)))\) AppleWebKit\/537\.36 \(KHTML, like Gecko\) Chrome\/\d+\.0\.0\.0( Mobile|) Safari\/537\.36/;
    const unifiedPlatform = (matcher.exec(userAgent) || [])[1];
    return IS_BLINK && !!unifiedPlatform;
};
const createPerformanceLogger = () => {
    const log = {};
    let total = 0;
    return {
        logTestResult: ({ test, passed, time = 0 }) => {
            total += time;
            const timeString = `${time.toFixed(2)}ms`;
            log[test] = timeString;
            return true;
        },
        getLog: () => log,
        getTotal: () => total,
    };
};
const performanceLogger = createPerformanceLogger();
const { logTestResult } = performanceLogger;
const createTimer = () => {
    let start = 0;
    const log = [];
    return {
        stop: () => {
            if (start) {
                log.push(performance.now() - start);
                return log.reduce((acc, n) => acc += n, 0);
            }
            return start;
        },
        start: () => {
            start = performance.now();
            return start;
        },
    };
};
const queueEvent = (timer, delay = 0) => {
    timer.stop();
    return new Promise((resolve) => setTimeout(() => resolve(timer.start()), delay))
        .catch((e) => { });
};
const queueTask = () => new Promise((resolve) => setTimeout(() => resolve(null)));
const EMOJIS = [
    [128512], [9786], [129333, 8205, 9794, 65039], [9832], [9784], [9895], [8265], [8505], [127987, 65039, 8205, 9895, 65039], [129394], [9785], [9760], [129489, 8205, 129456], [129487, 8205, 9794, 65039], [9975], [129489, 8205, 129309, 8205, 129489], [9752], [9968], [9961], [9972], [9992], [9201], [9928], [9730], [9969], [9731], [9732], [9976], [9823], [9937], [9000], [9993], [9999],
    [128105, 8205, 10084, 65039, 8205, 128139, 8205, 128104],
    [128104, 8205, 128105, 8205, 128103, 8205, 128102],
    [128104, 8205, 128105, 8205, 128102],
    // android 11
    [128512],
    [169], [174], [8482],
    [128065, 65039, 8205, 128488, 65039],
    // other
    [10002], [9986], [9935], [9874], [9876], [9881], [9939], [9879], [9904], [9905], [9888], [9762], [9763], [11014], [8599], [10145], [11013], [9883], [10017], [10013], [9766], [9654], [9197], [9199], [9167], [9792], [9794], [10006], [12336], [9877], [9884], [10004], [10035], [10055], [9724], [9642], [10083], [10084], [9996], [9757], [9997], [10052], [9878], [8618], [9775], [9770], [9774], [9745], [10036], [127344], [127359],
].map((emojiCode) => String.fromCodePoint(...emojiCode));
const CSS_FONT_FAMILY = `
	'Segoe Fluent Icons',
	'Ink Free',
	'Bahnschrift',
	'Segoe MDL2 Assets',
	'HoloLens MDL2 Assets',
	'Leelawadee UI',
	'Javanese Text',
	'Segoe UI Emoji',
	'Aldhabi',
	'Gadugi',
	'Myanmar Text',
	'Nirmala UI',
	'Lucida Console',
	'Cambria Math',
	'Bai Jamjuree',
	'Chakra Petch',
	'Charmonman',
	'Fahkwang',
	'K2D',
	'Kodchasan',
	'KoHo',
	'Sarabun',
	'Srisakdi',
	'Galvji',
	'MuktaMahee Regular',
	'InaiMathi Bold',
	'American Typewriter Semibold',
	'Futura Bold',
	'SignPainter-HouseScript Semibold',
	'PingFang HK Light',
	'Kohinoor Devanagari Medium',
	'Luminari',
	'Geneva',
	'Helvetica Neue',
	'Droid Sans Mono',
	'Dancing Script',
	'Roboto',
	'Ubuntu',
	'Liberation Mono',
	'Source Code Pro',
	'DejaVu Sans',
	'OpenSymbol',
	'Chilanka',
	'Cousine',
	'Arimo',
	'Jomolhari',
	'MONO',
	'Noto Color Emoji',
	sans-serif !important
`;
function getGpuBrand(gpu) {
    if (!gpu)
        return null;
    const gpuBrandMatcher = /(adreno|amd|apple|intel|llvm|mali|microsoft|nvidia|parallels|powervr|samsung|swiftshader|virtualbox|vmware)/i;
    const brand = (/radeon/i.test(gpu) ? 'AMD' :
        /geforce/i.test(gpu) ? 'NVIDIA' :
            (gpuBrandMatcher.exec(gpu)?.[0] || 'other').toLocaleUpperCase());
    return brand;
}
// collect fingerprints for analysis
const Analysis = {};
// use if needed to stable fingerprint
const LowerEntropy = {
    AUDIO: false,
    CANVAS: false,
    FONTS: false,
    SCREEN: false,
    TIME_ZONE: false,
    WEBGL: false,
};

// template views
function patch(oldEl, newEl, fn) {
    if (!oldEl)
        return null;
    oldEl.parentNode?.replaceChild(newEl, oldEl);
    return typeof fn === 'function' ? fn() : true;
}
function html(templateStr, ...expressionSet) {
    const template = document.createElement('template');
    template.innerHTML = templateStr.map((s, i) => `${s}${expressionSet[i] || ''}`).join('');
    return document.importNode(template.content, true);
}

const createErrorsCaptured = () => {
    const errors = [];
    return {
        getErrors: () => errors,
        captureError: (error, customMessage = '') => {
            const type = {
                Error: true,
                EvalError: true,
                InternalError: true,
                RangeError: true,
                ReferenceError: true,
                SyntaxError: true,
                TypeError: true,
                URIError: true,
                InvalidStateError: true,
                SecurityError: true,
            };
            const hasInnerSpace = (s) => /.+(\s).+/g.test(s); // ignore AOPR noise
            console.error(error); // log error to educate
            const { name, message } = error;
            const trustedMessage = (!hasInnerSpace(message) ? undefined :
                !customMessage ? message :
                    `${message} [${customMessage}]`);
            const trustedName = type[name] ? name : undefined;
            errors.push({ trustedName, trustedMessage });
            return undefined;
        },
    };
};
const errorsCaptured = createErrorsCaptured();
const { captureError } = errorsCaptured;
const attempt = (fn, customMessage = '') => {
    try {
        return fn();
    }
    catch (error) {
        if (customMessage) {
            return captureError(error, customMessage);
        }
        return captureError(error);
    }
};
const caniuse = (fn, objChainList = [], args = [], method = false) => {
    let api;
    try {
        api = fn();
    }
    catch (error) {
        return undefined;
    }
    let i;
    const len = objChainList.length;
    let chain = api;
    try {
        for (i = 0; i < len; i++) {
            const obj = objChainList[i];
            chain = chain[obj];
        }
    }
    catch (error) {
        return undefined;
    }
    return (method && args.length ? chain.apply(api, args) :
        method && !args.length ? chain.apply(api) :
            chain);
};
// Log performance time
const timer = (logStart) => {
    logStart && console.log(logStart);
    let start = 0;
    try {
        start = performance.now();
    }
    catch (error) {
        captureError(error);
    }
    return (logEnd) => {
        let end = 0;
        try {
            end = performance.now() - start;
            logEnd && console.log(`${logEnd}: ${end / 1000} seconds`);
            return end;
        }
        catch (error) {
            captureError(error);
            return 0;
        }
    };
};
const getCapturedErrors = () => ({ data: errorsCaptured.getErrors() });

/* eslint-disable new-cap */
// warm up while we detect lies
try {
    speechSynthesis.getVoices();
}
catch (err) { }
// Collect lies detected
function createLieRecords() {
    const records = {};
    return {
        getRecords: () => records,
        documentLie: (name, lie) => {
            const isArray = lie instanceof Array;
            if (records[name]) {
                if (isArray) {
                    return (records[name] = [...records[name], ...lie]);
                }
                return records[name].push(lie);
            }
            return isArray ? (records[name] = lie) : (records[name] = [lie]);
        },
    };
}
const lieRecords = createLieRecords();
const { documentLie } = lieRecords;
const GHOST = `
	height: 100vh;
	width: 100vw;
	position: absolute;
	left:-10000px;
	visibility: hidden;
`;
function getRandomValues() {
    return (String.fromCharCode(Math.random() * 26 + 97) +
        Math.random().toString(36).slice(-7));
}
function getBehemothIframe(win) {
    try {
        if (!IS_BLINK)
            return win;
        const div = win.document.createElement('div');
        div.setAttribute('id', getRandomValues());
        div.setAttribute('style', GHOST);
        div.innerHTML = `<div><iframe></iframe></div>`;
        win.document.body.appendChild(div);
        const iframe = [...[...div.childNodes][0].childNodes][0];
        if (!iframe)
            return null;
        const { contentWindow } = iframe || {};
        if (!contentWindow)
            return null;
        const div2 = contentWindow.document.createElement('div');
        div2.innerHTML = `<div><iframe></iframe></div>`;
        contentWindow.document.body.appendChild(div2);
        const iframe2 = [...[...div2.childNodes][0].childNodes][0];
        return iframe2.contentWindow;
    }
    catch (error) {
        captureError(error, 'client blocked behemoth iframe');
        return win;
    }
}
const RAND = getRandomValues();
const HAS_REFLECT = 'Reflect' in self;
function isTypeError(err) {
    return err.constructor.name == 'TypeError';
}
function failsTypeError({ spawnErr, withStack, final }) {
    try {
        spawnErr();
        throw Error();
    }
    catch (err) {
        if (!isTypeError(err))
            return true;
        return withStack ? withStack(err) : false;
    }
    finally {
        final && final();
    }
}
function failsWithError(fn) {
    try {
        fn();
        return false;
    }
    catch (err) {
        return true;
    }
}
function hasKnownToString(name) {
    return {
        [`function ${name}() { [native code] }`]: true,
        [`function get ${name}() { [native code] }`]: true,
        [`function () { [native code] }`]: true,
        [`function ${name}() {${'\n'}    [native code]${'\n'}}`]: true,
        [`function get ${name}() {${'\n'}    [native code]${'\n'}}`]: true,
        [`function () {${'\n'}    [native code]${'\n'}}`]: true,
    };
}
function hasValidStack(err, reg, i = 1) {
    if (i === 0)
        return reg.test(err.message);
    return reg.test(err.stack.split('\n')[i]);
}
const AT_FUNCTION = /at Function\.toString /;
const AT_OBJECT = /at Object\.toString/;
const FUNCTION_INSTANCE = /at (Function\.)?\[Symbol.hasInstance\]/; // useful if < Chrome 102
const PROXY_INSTANCE = /at (Proxy\.)?\[Symbol.hasInstance\]/; // useful if < Chrome 102
const STRICT_MODE = /strict mode/;
function queryLies({ scope, apiFunction, proto, obj, lieProps, }) {
    if (typeof apiFunction != 'function') {
        return {
            lied: 0,
            lieTypes: [],
        };
    }
    const name = apiFunction.name.replace(/get\s/, '');
    const objName = obj?.name;
    const nativeProto = Object.getPrototypeOf(apiFunction);
    let lies = {
        // custom lie string names
        ['failed illegal error']: !!obj && failsTypeError({
            spawnErr: () => obj.prototype[name],
        }),
        ['failed undefined properties']: (!!obj && /^(screen|navigator)$/i.test(objName) && !!(Object.getOwnPropertyDescriptor(self[objName.toLowerCase()], name) || (HAS_REFLECT &&
            Reflect.getOwnPropertyDescriptor(self[objName.toLowerCase()], name)))),
        ['failed call interface error']: failsTypeError({
            spawnErr: () => {
                // @ts-expect-error
                new apiFunction();
                apiFunction.call(proto);
            },
        }),
        ['failed apply interface error']: failsTypeError({
            spawnErr: () => {
                // @ts-expect-error
                new apiFunction();
                apiFunction.apply(proto);
            },
        }),
        ['failed new instance error']: failsTypeError({
            // @ts-expect-error
            spawnErr: () => new apiFunction(),
        }),
        ['failed class extends error']: !IS_WEBKIT && failsTypeError({
            spawnErr: () => {
                // @ts-expect-error
                class Fake extends apiFunction {
                }
            },
        }),
        ['failed null conversion error']: failsTypeError({
            spawnErr: () => Object.setPrototypeOf(apiFunction, null).toString(),
            final: () => Object.setPrototypeOf(apiFunction, nativeProto),
        }),
        ['failed toString']: (!hasKnownToString(name)[scope.Function.prototype.toString.call(apiFunction)] ||
            !hasKnownToString('toString')[scope.Function.prototype.toString.call(apiFunction.toString)]),
        ['failed "prototype" in function']: 'prototype' in apiFunction,
        ['failed descriptor']: !!(Object.getOwnPropertyDescriptor(apiFunction, 'arguments') ||
            Reflect.getOwnPropertyDescriptor(apiFunction, 'arguments') ||
            Object.getOwnPropertyDescriptor(apiFunction, 'caller') ||
            Reflect.getOwnPropertyDescriptor(apiFunction, 'caller') ||
            Object.getOwnPropertyDescriptor(apiFunction, 'prototype') ||
            Reflect.getOwnPropertyDescriptor(apiFunction, 'prototype') ||
            Object.getOwnPropertyDescriptor(apiFunction, 'toString') ||
            Reflect.getOwnPropertyDescriptor(apiFunction, 'toString')),
        ['failed own property']: !!(apiFunction.hasOwnProperty('arguments') ||
            apiFunction.hasOwnProperty('caller') ||
            apiFunction.hasOwnProperty('prototype') ||
            apiFunction.hasOwnProperty('toString')),
        ['failed descriptor keys']: (Object.keys(Object.getOwnPropertyDescriptors(apiFunction)).sort().toString() != 'length,name'),
        ['failed own property names']: (Object.getOwnPropertyNames(apiFunction).sort().toString() != 'length,name'),
        ['failed own keys names']: HAS_REFLECT && (Reflect.ownKeys(apiFunction).sort().toString() != 'length,name'),
        // Proxy Detection
        ['failed object toString error']: (failsTypeError({
            spawnErr: () => Object.create(apiFunction).toString(),
            withStack: (err) => IS_BLINK && !hasValidStack(err, AT_FUNCTION),
        }) ||
            failsTypeError({
                spawnErr: () => Object.create(new Proxy(apiFunction, {})).toString(),
                withStack: (err) => IS_BLINK && !hasValidStack(err, AT_OBJECT),
            })),
        ['failed at incompatible proxy error']: failsTypeError({
            spawnErr: () => {
                apiFunction.arguments;
                apiFunction.caller;
            },
            withStack: (err) => IS_GECKO && !hasValidStack(err, STRICT_MODE, 0),
        }),
        ['failed at toString incompatible proxy error']: failsTypeError({
            spawnErr: () => {
                apiFunction.toString.arguments;
                apiFunction.toString.caller;
            },
            withStack: (err) => IS_GECKO && !hasValidStack(err, STRICT_MODE, 0),
        }),
        ['failed at too much recursion error']: failsTypeError({
            spawnErr: () => {
                Object.setPrototypeOf(apiFunction, Object.create(apiFunction)).toString();
            },
            final: () => Object.setPrototypeOf(apiFunction, nativeProto),
        }),
    };
    // conditionally increase difficulty
    const detectProxies = (name == 'toString' ||
        !!lieProps['Function.toString'] ||
        !!lieProps['Permissions.query']);
    if (detectProxies) {
        const proxy1 = new Proxy(apiFunction, {});
        const proxy2 = new Proxy(apiFunction, {});
        const proxy3 = new Proxy(apiFunction, {});
        lies = {
            ...lies,
            // Advanced Proxy Detection
            ['failed at too much recursion __proto__ error']: !failsTypeError({
                spawnErr: () => {
                    // @ts-expect-error
                    apiFunction.__proto__ = proxy;
                    apiFunction++;
                },
                final: () => Object.setPrototypeOf(apiFunction, nativeProto),
            }),
            ['failed at chain cycle error']: !failsTypeError({
                spawnErr: () => {
                    Object.setPrototypeOf(proxy1, Object.create(proxy1)).toString();
                },
                final: () => Object.setPrototypeOf(proxy1, nativeProto),
            }),
            ['failed at chain cycle __proto__ error']: !failsTypeError({
                spawnErr: () => {
                    // @ts-expect-error
                    proxy2.__proto__ = proxy2;
                    proxy2++;
                },
                final: () => Object.setPrototypeOf(proxy2, nativeProto),
            }),
            ['failed at reflect set proto']: HAS_REFLECT && failsTypeError({
                spawnErr: () => {
                    Reflect.setPrototypeOf(apiFunction, Object.create(apiFunction));
                    RAND in apiFunction;
                    throw new TypeError();
                },
                final: () => Object.setPrototypeOf(apiFunction, nativeProto),
            }),
            ['failed at reflect set proto proxy']: HAS_REFLECT && !failsTypeError({
                spawnErr: () => {
                    Reflect.setPrototypeOf(proxy3, Object.create(proxy3));
                    RAND in proxy3;
                },
                final: () => Object.setPrototypeOf(proxy3, nativeProto),
            }),
            ['failed at instanceof check error']: IS_BLINK && (failsTypeError({
                spawnErr: () => {
                    apiFunction instanceof apiFunction;
                },
                withStack: (err) => !hasValidStack(err, FUNCTION_INSTANCE),
            }) ||
                failsTypeError({
                    spawnErr: () => {
                        const proxy = new Proxy(apiFunction, {});
                        proxy instanceof proxy;
                    },
                    withStack: (err) => !hasValidStack(err, PROXY_INSTANCE),
                })),
            ['failed at define properties']: IS_BLINK && HAS_REFLECT && failsWithError(() => {
                Object.defineProperty(apiFunction, '', { configurable: true }).toString();
                Reflect.deleteProperty(apiFunction, '');
            }),
        };
    }
    const lieTypes = Object.keys(lies).filter((key) => !!lies[key]);
    return {
        lied: lieTypes.length,
        lieTypes,
    };
}
function createLieDetector(scope) {
    const isSupported = (obj) => typeof obj != 'undefined' && !!obj;
    const props = {}; // lie list and detail
    const propsSearched = []; // list of properties searched
    return {
        getProps: () => props,
        getPropsSearched: () => propsSearched,
        searchLies: (fn, config) => {
            const { target, ignore } = config || {};
            let obj;
            // check if api is blocked or not supported
            try {
                obj = fn();
                if (!isSupported(obj)) {
                    return;
                }
            }
            catch (error) {
                return;
            }
            const interfaceObject = !!obj.prototype ? obj.prototype : obj;
            [...new Set([
                    ...Object.getOwnPropertyNames(interfaceObject),
                    ...Object.keys(interfaceObject), // backup
                ])].sort().forEach((name) => {
                const skip = (name == 'constructor' ||
                    (target && !new Set(target).has(name)) ||
                    (ignore && new Set(ignore).has(name)));
                if (skip)
                    return;
                const objectNameString = /\s(.+)\]/;
                const apiName = `${obj.name ? obj.name :
                    objectNameString.test(obj) ? objectNameString.exec(obj)?.[1] :
                        undefined}.${name}`;
                propsSearched.push(apiName);
                try {
                    const proto = obj.prototype ? obj.prototype : obj;
                    let res; // response from getLies
                    // search if function
                    try {
                        const apiFunction = proto[name]; // may trigger TypeError
                        if (typeof apiFunction == 'function') {
                            res = queryLies({
                                scope,
                                apiFunction: proto[name],
                                proto,
                                obj: null,
                                lieProps: props,
                            });
                            if (res.lied) {
                                documentLie(apiName, res.lieTypes);
                                return (props[apiName] = res.lieTypes);
                            }
                            return;
                        }
                        // since there is no TypeError and the typeof is not a function,
                        // handle invalid values and ignore name, length, and constants
                        if (name != 'name' &&
                            name != 'length' &&
                            name[0] !== name[0].toUpperCase()) {
                            const lie = ['failed descriptor.value undefined'];
                            documentLie(apiName, lie);
                            return (props[apiName] = lie);
                        }
                    }
                    catch (error) { }
                    // else search getter function
                    // @ts-ignore
                    const getterFunction = Object.getOwnPropertyDescriptor(proto, name).get;
                    res = queryLies({
                        scope,
                        apiFunction: getterFunction,
                        proto,
                        obj,
                        lieProps: props,
                    }); // send the obj for special tests
                    if (res.lied) {
                        documentLie(apiName, res.lieTypes);
                        return (props[apiName] = res.lieTypes);
                    }
                    return;
                }
                catch (error) {
                    const lie = `failed prototype test execution`;
                    documentLie(apiName, lie);
                    return (props[apiName] = [lie]);
                }
            });
        },
    };
}
function getPhantomIframe() {
    if (IS_WORKER_SCOPE)
        return { iframeWindow: self };
    try {
        const numberOfIframes = self.length;
        const frag = new DocumentFragment();
        const div = document.createElement('div');
        const id = getRandomValues();
        div.setAttribute('id', id);
        frag.appendChild(div);
        div.innerHTML = `<div style="${GHOST}"><iframe></iframe></div>`;
        document.body.appendChild(frag);
        const iframeWindow = self[numberOfIframes];
        const phantomWindow = getBehemothIframe(iframeWindow);
        return { iframeWindow: phantomWindow || self, div };
    }
    catch (error) {
        captureError(error, 'client blocked phantom iframe');
        return { iframeWindow: self };
    }
}
const { iframeWindow: PHANTOM_DARKNESS, div: PARENT_PHANTOM } = getPhantomIframe() || {};
function getPrototypeLies(scope) {
    const lieDetector = createLieDetector(scope);
    const { searchLies, } = lieDetector;
    // search lies: remove target to search all properties
    // test Function.toString first to determine the depth of the search
    searchLies(() => Function, {
        target: [
            'toString',
        ],
        ignore: [
            'caller',
            'arguments',
        ],
    });
    // other APIs
    searchLies(() => AnalyserNode);
    searchLies(() => AudioBuffer, {
        target: [
            'copyFromChannel',
            'getChannelData',
        ],
    });
    searchLies(() => BiquadFilterNode, {
        target: [
            'getFrequencyResponse',
        ],
    });
    searchLies(() => CanvasRenderingContext2D, {
        target: [
            'getImageData',
            'getLineDash',
            'isPointInPath',
            'isPointInStroke',
            'measureText',
            'quadraticCurveTo',
            'fillText',
            'strokeText',
            'font',
        ],
    });
    searchLies(() => CSSStyleDeclaration, {
        target: [
            'setProperty',
        ],
    });
    // @ts-expect-error
    searchLies(() => CSS2Properties, {
        target: [
            'setProperty',
        ],
    });
    searchLies(() => Date, {
        target: [
            'getDate',
            'getDay',
            'getFullYear',
            'getHours',
            'getMinutes',
            'getMonth',
            'getTime',
            'getTimezoneOffset',
            'setDate',
            'setFullYear',
            'setHours',
            'setMilliseconds',
            'setMonth',
            'setSeconds',
            'setTime',
            'toDateString',
            'toJSON',
            'toLocaleDateString',
            'toLocaleString',
            'toLocaleTimeString',
            'toString',
            'toTimeString',
            'valueOf',
        ],
    });
    searchLies(() => Intl.DateTimeFormat, {
        target: [
            'format',
            'formatRange',
            'formatToParts',
            'resolvedOptions',
        ],
    });
    searchLies(() => Document, {
        target: [
            'createElement',
            'createElementNS',
            'getElementById',
            'getElementsByClassName',
            'getElementsByName',
            'getElementsByTagName',
            'getElementsByTagNameNS',
            'referrer',
            'write',
            'writeln',
        ],
        ignore: [
            // Gecko
            'onreadystatechange',
            'onmouseenter',
            'onmouseleave',
        ],
    });
    searchLies(() => DOMRect);
    searchLies(() => DOMRectReadOnly);
    searchLies(() => Element, {
        target: [
            'append',
            'appendChild',
            'getBoundingClientRect',
            'getClientRects',
            'insertAdjacentElement',
            'insertAdjacentHTML',
            'insertAdjacentText',
            'insertBefore',
            'prepend',
            'replaceChild',
            'replaceWith',
            'setAttribute',
        ],
    });
    searchLies(() => FontFace, {
        target: [
            'family',
            'load',
            'status',
        ],
    });
    searchLies(() => HTMLCanvasElement);
    searchLies(() => HTMLElement, {
        target: [
            'clientHeight',
            'clientWidth',
            'offsetHeight',
            'offsetWidth',
            'scrollHeight',
            'scrollWidth',
        ],
        ignore: [
            // Gecko
            'onmouseenter',
            'onmouseleave',
        ],
    });
    searchLies(() => HTMLIFrameElement, {
        target: [
            'contentDocument',
            'contentWindow',
        ],
    });
    searchLies(() => IntersectionObserverEntry, {
        target: [
            'boundingClientRect',
            'intersectionRect',
            'rootBounds',
        ],
    });
    searchLies(() => Math, {
        target: [
            'acos',
            'acosh',
            'asinh',
            'atan',
            'atan2',
            'atanh',
            'cbrt',
            'cos',
            'cosh',
            'exp',
            'expm1',
            'log',
            'log10',
            'log1p',
            'sin',
            'sinh',
            'sqrt',
            'tan',
            'tanh',
        ],
    });
    searchLies(() => MediaDevices, {
        target: [
            'enumerateDevices',
            'getDisplayMedia',
            'getUserMedia',
        ],
    });
    searchLies(() => Navigator, {
        target: [
            'appCodeName',
            'appName',
            'appVersion',
            'buildID',
            'connection',
            'deviceMemory',
            'getBattery',
            'getGamepads',
            'getVRDisplays',
            'hardwareConcurrency',
            'language',
            'languages',
            'maxTouchPoints',
            'mimeTypes',
            'oscpu',
            'platform',
            'plugins',
            'product',
            'productSub',
            'sendBeacon',
            'serviceWorker',
            'userAgent',
            'vendor',
            'vendorSub',
        ],
    });
    searchLies(() => Node, {
        target: [
            'appendChild',
            'insertBefore',
            'replaceChild',
        ],
    });
    // @ts-expect-error
    searchLies(() => OffscreenCanvas, {
        target: [
            'convertToBlob',
            'getContext',
        ],
    });
    // @ts-expect-error
    searchLies(() => OffscreenCanvasRenderingContext2D, {
        target: [
            'getImageData',
            'getLineDash',
            'isPointInPath',
            'isPointInStroke',
            'measureText',
            'quadraticCurveTo',
            'font',
        ],
    });
    searchLies(() => Permissions, {
        target: [
            'query',
        ],
    });
    searchLies(() => Range, {
        target: [
            'getBoundingClientRect',
            'getClientRects',
        ],
    });
    // @ts-expect-error
    searchLies(() => Intl.RelativeTimeFormat, {
        target: [
            'resolvedOptions',
        ],
    });
    searchLies(() => Screen);
    searchLies(() => speechSynthesis, {
        target: [
            'getVoices',
        ],
    });
    searchLies(() => String, {
        target: [
            'fromCodePoint',
        ],
    });
    searchLies(() => SVGRect);
    searchLies(() => SVGRectElement, {
        target: [
            'getBBox',
        ],
    });
    searchLies(() => SVGTextContentElement, {
        target: [
            'getExtentOfChar',
            'getSubStringLength',
            'getComputedTextLength',
        ],
    });
    searchLies(() => TextMetrics);
    searchLies(() => WebGLRenderingContext, {
        target: [
            'bufferData',
            'getParameter',
            'readPixels',
        ],
    });
    searchLies(() => WebGL2RenderingContext, {
        target: [
            'bufferData',
            'getParameter',
            'readPixels',
        ],
    });
    /* potential targets:
        RTCPeerConnection
        Plugin
        PluginArray
        MimeType
        MimeTypeArray
        Worker
        History
    */
    // return lies list and detail
    const props = lieDetector.getProps();
    const propsSearched = lieDetector.getPropsSearched();
    return {
        lieDetector,
        lieList: Object.keys(props).sort(),
        lieDetail: props,
        lieCount: Object.keys(props).reduce((acc, key) => acc + props[key].length, 0),
        propsSearched,
    };
}
// start program
const start = performance.now();
const { lieDetector, lieList, lieDetail, 
// lieCount,
propsSearched, } = getPrototypeLies(PHANTOM_DARKNESS); // execute and destructure the list and detail
// disregard Function.prototype.toString lies when determining if the API can be trusted
const getNonFunctionToStringLies = (x) => !x ? x : x.filter((x) => !/object toString|toString incompatible proxy/.test(x)).length;
let lieProps;
let prototypeLies;
if (!IS_WORKER_SCOPE) {
    lieProps = (() => {
        const props = lieDetector.getProps();
        return Object.keys(props).reduce((acc, key) => {
            acc[key] = getNonFunctionToStringLies(props[key]);
            return acc;
        }, {});
    })();
    prototypeLies = JSON.parse(JSON.stringify(lieDetail));
    const perf = performance.now() - start;
    +perf.toFixed(2);
}
const getPluginLies = (plugins, mimeTypes) => {
    const lies = []; // collect lie types
    const pluginsOwnPropertyNames = Object.getOwnPropertyNames(plugins).filter((name) => isNaN(+name));
    const mimeTypesOwnPropertyNames = Object.getOwnPropertyNames(mimeTypes).filter((name) => isNaN(+name));
    // cast to array
    const pluginsList = [...plugins];
    const mimeTypesList = [...mimeTypes];
    // get initial trusted mimeType names
    const trustedMimeTypes = new Set(mimeTypesOwnPropertyNames);
    // get initial trusted plugin names
    const excludeDuplicates = (arr) => [...new Set(arr)];
    const mimeTypeEnabledPlugins = excludeDuplicates(mimeTypesList.map((mimeType) => mimeType.enabledPlugin));
    const trustedPluginNames = new Set(pluginsOwnPropertyNames);
    const mimeTypeEnabledPluginsNames = mimeTypeEnabledPlugins.map((plugin) => plugin && plugin.name);
    const trustedPluginNamesArray = [...trustedPluginNames];
    trustedPluginNamesArray.forEach((name) => {
        const validName = new Set(mimeTypeEnabledPluginsNames).has(name);
        if (!validName) {
            trustedPluginNames.delete(name);
        }
    });
    // 3. Expect MimeType object in plugins
    const invalidPlugins = pluginsList.filter((plugin) => {
        try {
            const validMimeType = Object.getPrototypeOf(plugin[0]).constructor.name == 'MimeType';
            if (!validMimeType) {
                trustedPluginNames.delete(plugin.name);
            }
            return !validMimeType;
        }
        catch (error) {
            trustedPluginNames.delete(plugin.name);
            return true; // sign of tampering
        }
    });
    if (invalidPlugins.length) {
        lies.push('missing mimetype');
    }
    // 4. Expect valid MimeType(s) in plugin
    const pluginMimeTypes = pluginsList
        .map((plugin) => Object.values(plugin)).flat();
    const pluginMimeTypesNames = pluginMimeTypes.map((mimetype) => mimetype.type);
    pluginMimeTypesNames.forEach((name) => {
        const validName = trustedMimeTypes.has(name);
        if (!validName) {
            trustedMimeTypes.delete(name);
        }
    });
    pluginsList.forEach((plugin) => {
        const pluginMimeTypes = Object.values(plugin).map((mimetype) => mimetype.type);
        return pluginMimeTypes.forEach((mimetype) => {
            if (!trustedMimeTypes.has(mimetype)) {
                lies.push('invalid mimetype');
                return trustedPluginNames.delete(plugin.name);
            }
            return;
        });
    });
    return {
        validPlugins: pluginsList.filter((plugin) => trustedPluginNames.has(plugin.name)),
        validMimeTypes: mimeTypesList.filter((mimeType) => trustedMimeTypes.has(mimeType.type)),
        lies: [...new Set(lies)], // remove duplicates
    };
};
const getLies = () => {
    const records = lieRecords.getRecords();
    const totalLies = Object.keys(records).reduce((acc, key) => {
        acc += records[key].length;
        return acc;
    }, 0);
    return { data: records, totalLies };
};

// Detect proxy behavior
const proxyBehavior = (x) => typeof x == 'function' ? true : false;
// Detect gibberish
const accept = { 'aa': 1, 'ab': 1, 'ac': 1, 'ad': 1, 'ae': 1, 'af': 1, 'ag': 1, 'ah': 1, 'ai': 1, 'aj': 1, 'ak': 1, 'al': 1, 'am': 1, 'an': 1, 'ao': 1, 'ap': 1, 'aq': 1, 'ar': 1, 'as': 1, 'at': 1, 'au': 1, 'av': 1, 'aw': 1, 'ax': 1, 'ay': 1, 'az': 1, 'ba': 1, 'bb': 1, 'bc': 1, 'bd': 1, 'be': 1, 'bf': 1, 'bg': 1, 'bh': 1, 'bi': 1, 'bj': 1, 'bk': 1, 'bl': 1, 'bm': 1, 'bn': 1, 'bo': 1, 'bp': 1, 'br': 1, 'bs': 1, 'bt': 1, 'bu': 1, 'bv': 1, 'bw': 1, 'bx': 1, 'by': 1, 'ca': 1, 'cb': 1, 'cc': 1, 'cd': 1, 'ce': 1, 'cg': 1, 'ch': 1, 'ci': 1, 'ck': 1, 'cl': 1, 'cm': 1, 'cn': 1, 'co': 1, 'cp': 1, 'cq': 1, 'cr': 1, 'cs': 1, 'ct': 1, 'cu': 1, 'cw': 1, 'cy': 1, 'cz': 1, 'da': 1, 'db': 1, 'dc': 1, 'dd': 1, 'de': 1, 'df': 1, 'dg': 1, 'dh': 1, 'di': 1, 'dj': 1, 'dk': 1, 'dl': 1, 'dm': 1, 'dn': 1, 'do': 1, 'dp': 1, 'dq': 1, 'dr': 1, 'ds': 1, 'dt': 1, 'du': 1, 'dv': 1, 'dw': 1, 'dx': 1, 'dy': 1, 'dz': 1, 'ea': 1, 'eb': 1, 'ec': 1, 'ed': 1, 'ee': 1, 'ef': 1, 'eg': 1, 'eh': 1, 'ei': 1, 'ej': 1, 'ek': 1, 'el': 1, 'em': 1, 'en': 1, 'eo': 1, 'ep': 1, 'eq': 1, 'er': 1, 'es': 1, 'et': 1, 'eu': 1, 'ev': 1, 'ew': 1, 'ex': 1, 'ey': 1, 'ez': 1, 'fa': 1, 'fb': 1, 'fc': 1, 'fd': 1, 'fe': 1, 'ff': 1, 'fg': 1, 'fh': 1, 'fi': 1, 'fj': 1, 'fk': 1, 'fl': 1, 'fm': 1, 'fn': 1, 'fo': 1, 'fp': 1, 'fr': 1, 'fs': 1, 'ft': 1, 'fu': 1, 'fw': 1, 'fy': 1, 'ga': 1, 'gb': 1, 'gc': 1, 'gd': 1, 'ge': 1, 'gf': 1, 'gg': 1, 'gh': 1, 'gi': 1, 'gj': 1, 'gk': 1, 'gl': 1, 'gm': 1, 'gn': 1, 'go': 1, 'gp': 1, 'gr': 1, 'gs': 1, 'gt': 1, 'gu': 1, 'gw': 1, 'gy': 1, 'gz': 1, 'ha': 1, 'hb': 1, 'hc': 1, 'hd': 1, 'he': 1, 'hf': 1, 'hg': 1, 'hh': 1, 'hi': 1, 'hj': 1, 'hk': 1, 'hl': 1, 'hm': 1, 'hn': 1, 'ho': 1, 'hp': 1, 'hq': 1, 'hr': 1, 'hs': 1, 'ht': 1, 'hu': 1, 'hv': 1, 'hw': 1, 'hy': 1, 'ia': 1, 'ib': 1, 'ic': 1, 'id': 1, 'ie': 1, 'if': 1, 'ig': 1, 'ih': 1, 'ii': 1, 'ij': 1, 'ik': 1, 'il': 1, 'im': 1, 'in': 1, 'io': 1, 'ip': 1, 'iq': 1, 'ir': 1, 'is': 1, 'it': 1, 'iu': 1, 'iv': 1, 'iw': 1, 'ix': 1, 'iy': 1, 'iz': 1, 'ja': 1, 'jc': 1, 'je': 1, 'ji': 1, 'jj': 1, 'jk': 1, 'jn': 1, 'jo': 1, 'ju': 1, 'ka': 1, 'kb': 1, 'kc': 1, 'kd': 1, 'ke': 1, 'kf': 1, 'kg': 1, 'kh': 1, 'ki': 1, 'kj': 1, 'kk': 1, 'kl': 1, 'km': 1, 'kn': 1, 'ko': 1, 'kp': 1, 'kr': 1, 'ks': 1, 'kt': 1, 'ku': 1, 'kv': 1, 'kw': 1, 'ky': 1, 'la': 1, 'lb': 1, 'lc': 1, 'ld': 1, 'le': 1, 'lf': 1, 'lg': 1, 'lh': 1, 'li': 1, 'lj': 1, 'lk': 1, 'll': 1, 'lm': 1, 'ln': 1, 'lo': 1, 'lp': 1, 'lq': 1, 'lr': 1, 'ls': 1, 'lt': 1, 'lu': 1, 'lv': 1, 'lw': 1, 'lx': 1, 'ly': 1, 'lz': 1, 'ma': 1, 'mb': 1, 'mc': 1, 'md': 1, 'me': 1, 'mf': 1, 'mg': 1, 'mh': 1, 'mi': 1, 'mj': 1, 'mk': 1, 'ml': 1, 'mm': 1, 'mn': 1, 'mo': 1, 'mp': 1, 'mq': 1, 'mr': 1, 'ms': 1, 'mt': 1, 'mu': 1, 'mv': 1, 'mw': 1, 'my': 1, 'na': 1, 'nb': 1, 'nc': 1, 'nd': 1, 'ne': 1, 'nf': 1, 'ng': 1, 'nh': 1, 'ni': 1, 'nj': 1, 'nk': 1, 'nl': 1, 'nm': 1, 'nn': 1, 'no': 1, 'np': 1, 'nq': 1, 'nr': 1, 'ns': 1, 'nt': 1, 'nu': 1, 'nv': 1, 'nw': 1, 'nx': 1, 'ny': 1, 'nz': 1, 'oa': 1, 'ob': 1, 'oc': 1, 'od': 1, 'oe': 1, 'of': 1, 'og': 1, 'oh': 1, 'oi': 1, 'oj': 1, 'ok': 1, 'ol': 1, 'om': 1, 'on': 1, 'oo': 1, 'op': 1, 'oq': 1, 'or': 1, 'os': 1, 'ot': 1, 'ou': 1, 'ov': 1, 'ow': 1, 'ox': 1, 'oy': 1, 'oz': 1, 'pa': 1, 'pb': 1, 'pc': 1, 'pd': 1, 'pe': 1, 'pf': 1, 'pg': 1, 'ph': 1, 'pi': 1, 'pj': 1, 'pk': 1, 'pl': 1, 'pm': 1, 'pn': 1, 'po': 1, 'pp': 1, 'pr': 1, 'ps': 1, 'pt': 1, 'pu': 1, 'pw': 1, 'py': 1, 'pz': 1, 'qa': 1, 'qe': 1, 'qi': 1, 'qo': 1, 'qr': 1, 'qs': 1, 'qt': 1, 'qu': 1, 'ra': 1, 'rb': 1, 'rc': 1, 'rd': 1, 're': 1, 'rf': 1, 'rg': 1, 'rh': 1, 'ri': 1, 'rj': 1, 'rk': 1, 'rl': 1, 'rm': 1, 'rn': 1, 'ro': 1, 'rp': 1, 'rq': 1, 'rr': 1, 'rs': 1, 'rt': 1, 'ru': 1, 'rv': 1, 'rw': 1, 'rx': 1, 'ry': 1, 'rz': 1, 'sa': 1, 'sb': 1, 'sc': 1, 'sd': 1, 'se': 1, 'sf': 1, 'sg': 1, 'sh': 1, 'si': 1, 'sj': 1, 'sk': 1, 'sl': 1, 'sm': 1, 'sn': 1, 'so': 1, 'sp': 1, 'sq': 1, 'sr': 1, 'ss': 1, 'st': 1, 'su': 1, 'sv': 1, 'sw': 1, 'sy': 1, 'sz': 1, 'ta': 1, 'tb': 1, 'tc': 1, 'td': 1, 'te': 1, 'tf': 1, 'tg': 1, 'th': 1, 'ti': 1, 'tj': 1, 'tk': 1, 'tl': 1, 'tm': 1, 'tn': 1, 'to': 1, 'tp': 1, 'tr': 1, 'ts': 1, 'tt': 1, 'tu': 1, 'tv': 1, 'tw': 1, 'tx': 1, 'ty': 1, 'tz': 1, 'ua': 1, 'ub': 1, 'uc': 1, 'ud': 1, 'ue': 1, 'uf': 1, 'ug': 1, 'uh': 1, 'ui': 1, 'uj': 1, 'uk': 1, 'ul': 1, 'um': 1, 'un': 1, 'uo': 1, 'up': 1, 'uq': 1, 'ur': 1, 'us': 1, 'ut': 1, 'uu': 1, 'uv': 1, 'uw': 1, 'ux': 1, 'uy': 1, 'uz': 1, 'va': 1, 'vc': 1, 'vd': 1, 've': 1, 'vg': 1, 'vi': 1, 'vl': 1, 'vn': 1, 'vo': 1, 'vr': 1, 'vs': 1, 'vt': 1, 'vu': 1, 'vv': 1, 'vy': 1, 'vz': 1, 'wa': 1, 'wb': 1, 'wc': 1, 'wd': 1, 'we': 1, 'wf': 1, 'wg': 1, 'wh': 1, 'wi': 1, 'wj': 1, 'wk': 1, 'wl': 1, 'wm': 1, 'wn': 1, 'wo': 1, 'wp': 1, 'wr': 1, 'ws': 1, 'wt': 1, 'wu': 1, 'ww': 1, 'wy': 1, 'wz': 1, 'xa': 1, 'xb': 1, 'xc': 1, 'xe': 1, 'xf': 1, 'xg': 1, 'xh': 1, 'xi': 1, 'xl': 1, 'xm': 1, 'xn': 1, 'xo': 1, 'xp': 1, 'xq': 1, 'xs': 1, 'xt': 1, 'xu': 1, 'xv': 1, 'xw': 1, 'xx': 1, 'xy': 1, 'ya': 1, 'yb': 1, 'yc': 1, 'yd': 1, 'ye': 1, 'yf': 1, 'yg': 1, 'yh': 1, 'yi': 1, 'yj': 1, 'yk': 1, 'yl': 1, 'ym': 1, 'yn': 1, 'yo': 1, 'yp': 1, 'yr': 1, 'ys': 1, 'yt': 1, 'yu': 1, 'yv': 1, 'yw': 1, 'yx': 1, 'yz': 1, 'za': 1, 'zb': 1, 'zc': 1, 'zd': 1, 'ze': 1, 'zg': 1, 'zh': 1, 'zi': 1, 'zj': 1, 'zk': 1, 'zl': 1, 'zm': 1, 'zn': 1, 'zo': 1, 'zp': 1, 'zq': 1, 'zs': 1, 'zt': 1, 'zu': 1, 'zv': 1, 'zw': 1, 'zy': 1, 'zz': 1 };
const gibberish = (str, { strict = false } = {}) => {
    if (!str) {
        return [];
    }
    // test letter case sequence
    const letterCaseSequenceGibbers = [];
    const tests = [
        /([A-Z]{3,}[a-z])/g,
        /([a-z][A-Z]{3,})/g,
        /([a-z][A-Z]{2,}[a-z])/g,
        /([a-z][\d]{2,}[a-z])/g,
        /([A-Z][\d]{2,}[a-z])/g,
        /([a-z][\d]{2,}[A-Z])/g, // a##...B
    ];
    tests.forEach((regExp) => {
        const match = str.match(regExp);
        if (match) {
            return letterCaseSequenceGibbers.push(match.join(', '));
        }
        return;
    });
    // test letter sequence
    const letterSequenceGibbers = [];
    const clean = str.toLowerCase().replace(/\d|\W|_/g, ' ').replace(/\s+/g, ' ').trim().split(' ').join('_');
    const len = clean.length;
    const arr = [...clean];
    arr.forEach((char, index) => {
        const next = index + 1;
        if (arr[next] == '_' || char == '_' || next == len) {
            return true;
        }
        const combo = char + arr[index + 1];
        const acceptable = !!accept[combo];
        !acceptable && letterSequenceGibbers.push(combo);
        return;
    });
    const gibbers = [
        // ignore sequence if less than 3 exist
        ...(!strict && (letterSequenceGibbers.length < 3) ? [] : letterSequenceGibbers),
        ...(!strict && (letterCaseSequenceGibbers.length < 4) ? [] : letterCaseSequenceGibbers),
    ];
    const allow = [
        // known gibbers
        'bz',
        'cf',
        'fx',
        'mx',
        'vb',
        'xd',
        'gx',
        'PCIe',
        'vm',
        'NVIDIAGa',
    ];
    return gibbers.filter((x) => !allow.includes(x));
};
// WebGL Renderer helpers
function compressWebGLRenderer(x) {
    if (!x)
        return;
    return ('' + x)
        .replace(/ANGLE \(|\sDirect3D.+|\sD3D.+|\svs_.+\)|\((DRM|POLARIS|LLVM).+|Mesa.+|(ATI|INTEL)-.+|Metal\s-\s.+|NVIDIA\s[\d|\.]+/ig, '')
        .replace(/(\s(ti|\d{1,2}GB|super)$)/ig, '')
        .replace(/\s{2,}/g, ' ')
        .trim()
        .replace(/((r|g)(t|)(x|s|\d) |Graphics |GeForce |Radeon (HD |Pro |))(\d+)/i, (...args) => {
        return `${args[1]}${args[6][0]}${args[6].slice(1).replace(/\d/g, '0')}s`;
    });
}
const getWebGLRendererParts = (x) => {
    const knownParts = [
        'AMD',
        'ANGLE',
        'ASUS',
        'ATI',
        'ATI Radeon',
        'ATI Technologies Inc',
        'Adreno',
        'Android Emulator',
        'Apple',
        'Apple GPU',
        'Apple M1',
        'Chipset',
        'D3D11',
        'Direct3D',
        'Express Chipset',
        'GeForce',
        'Generation',
        'Generic Renderer',
        'Google',
        'Google SwiftShader',
        'Graphics',
        'Graphics Media Accelerator',
        'HD Graphics Family',
        'Intel',
        'Intel(R) HD Graphics',
        'Intel(R) UHD Graphics',
        'Iris',
        'KBL Graphics',
        'Mali',
        'Mesa',
        'Mesa DRI',
        'Metal',
        'Microsoft',
        'Microsoft Basic Render Driver',
        'Microsoft Corporation',
        'NVIDIA',
        'NVIDIA Corporation',
        'NVIDIAGameReadyD3D',
        'OpenGL',
        'OpenGL Engine',
        'Open Source Technology Center',
        'Parallels',
        'Parallels Display Adapter',
        'PCIe',
        'Plus Graphics',
        'PowerVR',
        'Pro Graphics',
        'Quadro',
        'Radeon',
        'Radeon Pro',
        'Radeon Pro Vega',
        'Samsung',
        'SSE2',
        'VMware',
        'VMware SVGA 3D',
        'Vega',
        'VirtualBox',
        'VirtualBox Graphics Adapter',
        'Vulkan',
        'Xe Graphics',
        'llvmpipe',
    ];
    const parts = [...knownParts].filter((name) => ('' + x).includes(name));
    return [...new Set(parts)].sort().join(', ');
};
const getWebGLRendererConfidence = (x) => {
    if (!x) {
        return;
    }
    const parts = getWebGLRendererParts(x);
    const hasKnownParts = parts.length;
    const hasBlankSpaceNoise = /\s{2,}|^\s|\s$/.test(x);
    const hasBrokenAngleStructure = /^ANGLE/.test(x) && !(/^ANGLE \((.+)\)/.exec(x) || [])[1];
    // https://chromium.googlesource.com/angle/angle/+/83fa18905d8fed4f394e4f30140a83a3e76b1577/src/gpu_info_util/SystemInfo.cpp
    // https://chromium.googlesource.com/angle/angle/+/83fa18905d8fed4f394e4f30140a83a3e76b1577/src/gpu_info_util/SystemInfo.h
    // https://chromium.googlesource.com/chromium/src/+/refs/heads/main/ui/gl/gl_version_info.cc
    /*
    const knownVendors = [
        'AMD',
        'ARM',
        'Broadcom',
        'Google',
        'ImgTec',
        'Intel',
        'Kazan',
        'NVIDIA',
        'Qualcomm',
        'VeriSilicon',
        'Vivante',
        'VMWare',
        'Apple',
        'Unknown'
    ]
    const angle = {
        vendorId: (/^ANGLE \(([^,]+),/.exec(x)||[])[1] || knownVendors.find(vendor => x.includes(vendor)),
        deviceId: (
            (x.match(/,/g)||[]).length == 2 ? (/^ANGLE \(([^,]+), ([^,]+)[,|\)]/.exec(x)||[])[2] :
                (/^ANGLE \(([^,]+), ([^,]+)[,|\)]/.exec(x)||[])[1] || (/^ANGLE \((.+)\)$/.exec(x)||[])[1]
        ).replace(/\sDirect3D.+/, '')
    }
    */
    const gibbers = gibberish(x, { strict: true }).join(', ');
    const valid = (hasKnownParts && !hasBlankSpaceNoise && !hasBrokenAngleStructure);
    const confidence = (valid && !gibbers.length ? 'high' :
        valid && gibbers.length ? 'moderate' :
            'low');
    const grade = (confidence == 'high' ? 'A' :
        confidence == 'moderate' ? 'C' :
            'F');
    const warnings = new Set([
        (hasBlankSpaceNoise ? 'found extra spaces' : undefined),
        (hasBrokenAngleStructure ? 'broken angle structure' : undefined),
    ]);
    warnings.delete(undefined);
    return {
        parts,
        warnings: [...warnings],
        gibbers,
        confidence,
        grade,
    };
};
// Collect trash values
const createTrashBin = () => {
    const bin = [];
    return {
        getBin: () => bin,
        sendToTrash: (name, val, response = undefined) => {
            const proxyLike = proxyBehavior(val);
            const value = !proxyLike ? val : 'proxy behavior detected';
            bin.push({ name, value });
            return response;
        },
    };
};
const trashBin = createTrashBin();
const { sendToTrash } = trashBin;
const getTrash = () => ({ trashBin: trashBin.getBin() });

function isFontOSBad(userAgentOS, fonts) {
    if (!userAgentOS || !fonts || !fonts.length)
        return false;
    const fontMap = fonts.reduce((acc, x) => {
        acc[x] = true;
        return acc;
    }, {});
    const isLikeWindows = ('Cambria Math' in fontMap ||
        'Nirmala UI' in fontMap ||
        'Leelawadee UI' in fontMap ||
        'HoloLens MDL2 Assets' in fontMap ||
        'Segoe Fluent Icons' in fontMap);
    const isLikeApple = ('Helvetica Neue' in fontMap ||
        'Luminari' in fontMap ||
        'PingFang HK Light' in fontMap ||
        'Futura Bold' in fontMap ||
        'InaiMathi Bold' in fontMap ||
        'Galvji' in fontMap ||
        'Chakra Petch' in fontMap);
    const isLikeLinux = ('Arimo' in fontMap ||
        'MONO' in fontMap ||
        'Ubuntu' in fontMap ||
        'Noto Color Emoji' in fontMap ||
        'Dancing Script' in fontMap ||
        'Droid Sans Mono' in fontMap ||
        'Roboto' in fontMap);
    if (isLikeWindows && userAgentOS != "Windows" /* PlatformClassifier.WINDOWS */) {
        return true;
    }
    else if (isLikeApple && userAgentOS != "Apple" /* PlatformClassifier.APPLE */) {
        return true;
    }
    else if (isLikeLinux && userAgentOS != "Linux" /* PlatformClassifier.LINUX */) {
        return true;
    }
    return false;
}
// inspired by Lalit Patel's fontdetect.js
// https://www.lalit.org/wordpress/wp-content/uploads/2008/05/fontdetect.js?ver=0.3
const WindowsFonts = {
    // https://docs.microsoft.com/en-us/typography/fonts/windows_11_font_list
    '7': [
        'Cambria Math',
        'Lucida Console',
    ],
    '8': [
        'Aldhabi',
        'Gadugi',
        'Myanmar Text',
        'Nirmala UI',
    ],
    '8.1': [
        'Leelawadee UI',
        'Javanese Text',
        'Segoe UI Emoji',
    ],
    '10': [
        'HoloLens MDL2 Assets',
        'Segoe MDL2 Assets',
        'Bahnschrift',
        'Ink Free', // 10 (v1803) +-
    ],
    '11': ['Segoe Fluent Icons'],
};
const MacOSFonts = {
    // Mavericks and below
    '10.9': [
        'Helvetica Neue',
        'Geneva', // mac (not iOS)
    ],
    // Yosemite
    '10.10': [
        'Kohinoor Devanagari Medium',
        'Luminari',
    ],
    // El Capitan
    '10.11': [
        'PingFang HK Light',
    ],
    // Sierra: https://support.apple.com/en-ie/HT206872
    '10.12': [
        'American Typewriter Semibold',
        'Futura Bold',
        'SignPainter-HouseScript Semibold',
    ],
    // High Sierra: https://support.apple.com/en-me/HT207962
    // Mojave: https://support.apple.com/en-us/HT208968
    '10.13-10.14': [
        'InaiMathi Bold',
    ],
    // Catalina: https://support.apple.com/en-us/HT210192
    // Big Sur: https://support.apple.com/en-sg/HT211240
    '10.15-11': [
        'Galvji',
        'MuktaMahee Regular',
    ],
    // Monterey: https://support.apple.com/en-us/HT212587
    '12': [
        'Bai Jamjuree',
        'Chakra Petch',
        'Charmonman',
        'Kodchasan',
    ],
};
const DesktopAppFonts = {
    // docs.microsoft.com/en-us/typography/font-list/ms-outlook
    'Microsoft Outlook': ['MS Outlook'],
    // https://community.adobe.com/t5/postscript-discussions/zwadobef-font/m-p/3730427#M785
    'Adobe Acrobat': ['ZWAdobeF'],
    // https://wiki.documentfoundation.org/Fonts
    'LibreOffice': [
        'Amiri',
        'KACSTOffice',
        'Liberation Mono',
        'Source Code Pro',
    ],
    // https://superuser.com/a/611804
    'OpenOffice': [
        'DejaVu Sans',
        'Gentium Book Basic',
        'OpenSymbol',
    ],
};
const APPLE_FONTS = Object.keys(MacOSFonts).map((key) => MacOSFonts[key]).flat();
const WINDOWS_FONTS = Object.keys(WindowsFonts).map((key) => WindowsFonts[key]).flat();
const DESKTOP_APP_FONTS = (Object.keys(DesktopAppFonts).map((key) => DesktopAppFonts[key]).flat());
const LINUX_FONTS = [
    'Arimo',
    'Chilanka',
    'Cousine',
    'Jomolhari',
    'MONO',
    'Noto Color Emoji',
    'Ubuntu', // ubuntu (not TB)
];
const ANDROID_FONTS = [
    'Dancing Script',
    'Droid Sans Mono',
    'Roboto', // Android, Chrome OS
];
const FONT_LIST = [
    ...APPLE_FONTS,
    ...WINDOWS_FONTS,
    ...LINUX_FONTS,
    ...ANDROID_FONTS,
    ...DESKTOP_APP_FONTS,
].sort();
async function getFonts() {
    const getPixelEmojis = ({ doc, id, emojis }) => {
        try {
            patch(doc.getElementById(id), html `
				<div id="pixel-emoji-container">
				<style>
					.pixel-emoji {
						font-family: ${CSS_FONT_FAMILY};
						font-size: 200px !important;
						height: auto;
						position: absolute !important;
						transform: scale(1.000999);
					}
					</style>
					${emojis.map((emoji) => {
                return `<div class="pixel-emoji">${emoji}</div>`;
            }).join('')}
				</div>
			`);
            // get emoji set and system
            const getEmojiDimensions = (style) => {
                return {
                    width: style.inlineSize,
                    height: style.blockSize,
                };
            };
            const pattern = new Set();
            const emojiElems = [...doc.getElementsByClassName('pixel-emoji')];
            const emojiSet = emojiElems.reduce((emojiSet, el, i) => {
                const style = getComputedStyle(el);
                const emoji = emojis[i];
                const { height, width } = getEmojiDimensions(style);
                const dimensions = `${width},${height}`;
                if (!pattern.has(dimensions)) {
                    pattern.add(dimensions);
                    emojiSet.add(emoji);
                }
                return emojiSet;
            }, new Set());
            const pixelToNumber = (pixels) => +(pixels.replace('px', ''));
            const pixelSizeSystemSum = 0.00001 * [...pattern].map((x) => {
                return x.split(',').map((x) => pixelToNumber(x)).reduce((acc, x) => acc += (+x || 0), 0);
            }).reduce((acc, x) => acc += x, 0);
            doc.body.removeChild(doc.getElementById('pixel-emoji-container'));
            return {
                emojiSet: [...emojiSet],
                pixelSizeSystemSum,
            };
        }
        catch (error) {
            console.error(error);
            return {
                emojiSet: [],
                pixelSizeSystemSum: 0,
            };
        }
    };
    const getFontFaceLoadFonts = async (fontList) => {
        try {
            let fontsChecked = [];
            if (!document.fonts.check(`0px "${getRandomValues()}"`)) {
                fontsChecked = fontList.reduce((acc, font) => {
                    const found = document.fonts.check(`0px "${font}"`);
                    if (found)
                        acc.push(font);
                    return acc;
                }, []);
            }
            const fontFaceList = fontList.map((font) => new FontFace(font, `local("${font}")`));
            const responseCollection = await Promise
                .allSettled(fontFaceList.map((font) => font.load()));
            const fontsLoaded = responseCollection.reduce((acc, font) => {
                if (font.status == 'fulfilled') {
                    acc.push(font.value.family);
                }
                return acc;
            }, []);
            return [...new Set([...fontsChecked, ...fontsLoaded])].sort();
        }
        catch (error) {
            console.error(error);
            return [];
        }
    };
    const getPlatformVersion = (fonts) => {
        const getWindows = ({ fonts, fontMap }) => {
            const fontVersion = {
                ['11']: fontMap['11'].find((x) => fonts.includes(x)),
                ['10']: fontMap['10'].find((x) => fonts.includes(x)),
                ['8.1']: fontMap['8.1'].find((x) => fonts.includes(x)),
                ['8']: fontMap['8'].find((x) => fonts.includes(x)),
                // require complete set of Windows 7 fonts
                ['7']: fontMap['7'].filter((x) => fonts.includes(x)).length == fontMap['7'].length,
            };
            const hash = ('' + Object.keys(fontVersion).sort().filter((key) => !!fontVersion[key]));
            const hashMap = {
                '10,11,7,8,8.1': '11',
                '10,7,8,8.1': '10',
                '7,8,8.1': '8.1',
                '11,7,8,8.1': '8.1',
                '7,8': '8',
                '10,7,8': '8',
                '10,11,7,8': '8',
                '7': '7',
                '7,8.1': '7',
                '10,7,8.1': '7',
                '10,11,7,8.1': '7', // missing 8
            };
            const version = hashMap[hash];
            return version ? `Windows ${version}` : undefined;
        };
        const getMacOS = ({ fonts, fontMap }) => {
            const fontVersion = {
                ['12']: fontMap['12'].find((x) => fonts.includes(x)),
                ['10.15-11']: fontMap['10.15-11'].find((x) => fonts.includes(x)),
                ['10.13-10.14']: fontMap['10.13-10.14'].find((x) => fonts.includes(x)),
                ['10.12']: fontMap['10.12'].find((x) => fonts.includes(x)),
                ['10.11']: fontMap['10.11'].find((x) => fonts.includes(x)),
                ['10.10']: fontMap['10.10'].find((x) => fonts.includes(x)),
                // require complete set of 10.9 fonts
                ['10.9']: fontMap['10.9'].filter((x) => fonts.includes(x)).length == fontMap['10.9'].length,
            };
            const hash = ('' + Object.keys(fontVersion).sort().filter((key) => !!fontVersion[key]));
            const hashMap = {
                '10.10,10.11,10.12,10.13-10.14,10.15-11,10.9,12': 'Monterey',
                '10.10,10.11,10.12,10.13-10.14,10.15-11,10.9': '10.15-11',
                '10.10,10.11,10.12,10.13-10.14,10.9': '10.13-10.14',
                '10.10,10.11,10.12,10.9': 'Sierra',
                '10.10,10.11,10.9': 'El Capitan',
                '10.10,10.9': 'Yosemite',
                '10.9': 'Mavericks', // 10.9
            };
            const version = hashMap[hash];
            return version ? `macOS ${version}` : undefined;
        };
        return (getWindows({ fonts, fontMap: WindowsFonts }) ||
            getMacOS({ fonts, fontMap: MacOSFonts }));
    };
    const getDesktopApps = (fonts) => {
        // @ts-ignore
        const apps = Object.keys(DesktopAppFonts).reduce((acc, key) => {
            const appFontSet = DesktopAppFonts[key];
            const match = appFontSet.filter((x) => fonts.includes(x)).length == appFontSet.length;
            return match ? [...acc, key] : acc;
        }, []);
        return apps;
    };
    try {
        const timer = createTimer();
        await queueEvent(timer);
        const doc = (PHANTOM_DARKNESS &&
            PHANTOM_DARKNESS.document &&
            PHANTOM_DARKNESS.document.body ? PHANTOM_DARKNESS.document :
            document);
        const id = `font-fingerprint`;
        const div = doc.createElement('div');
        div.setAttribute('id', id);
        doc.body.appendChild(div);
        const { emojiSet, pixelSizeSystemSum, } = getPixelEmojis({
            doc,
            id,
            emojis: EMOJIS,
        }) || {};
        const fontList = FONT_LIST;
        const fontFaceLoadFonts = await getFontFaceLoadFonts(fontList);
        const platformVersion = getPlatformVersion(fontFaceLoadFonts);
        const apps = getDesktopApps(fontFaceLoadFonts);
        // detect lies
        const lied = (lieProps['FontFace.load'] ||
            lieProps['FontFace.family'] ||
            lieProps['FontFace.status'] ||
            lieProps['String.fromCodePoint'] ||
            lieProps['CSSStyleDeclaration.setProperty'] ||
            lieProps['CSS2Properties.setProperty']);
        if (isFontOSBad(USER_AGENT_OS, fontFaceLoadFonts)) {
            LowerEntropy.FONTS = true,
                Analysis.FontOsIsBad = true;
            sendToTrash('platform', `${USER_AGENT_OS} system and fonts are suspicious`);
        }
        logTestResult({ time: timer.stop(), test: 'fonts', passed: true });
        return {
            fontFaceLoadFonts,
            platformVersion,
            apps,
            emojiSet,
            pixelSizeSystemSum,
            lied,
        };
    }
    catch (error) {
        logTestResult({ test: 'fonts', passed: false });
        captureError(error);
        return;
    }
}

let WORKER_TYPE = '';
let WORKER_NAME = '';
async function spawnWorker() {
    const ask = (fn) => {
        try {
            return fn();
        }
        catch (e) {
            return;
        }
    };
    function getWorkerPrototypeLies(scope) {
        const lieDetector = createLieDetector(scope);
        const { searchLies, } = lieDetector;
        searchLies(() => Function, {
            target: [
                'toString',
            ],
            ignore: [
                'caller',
                'arguments',
            ],
        });
        // @ts-expect-error
        searchLies(() => WorkerNavigator, {
            target: [
                'deviceMemory',
                'hardwareConcurrency',
                'language',
                'languages',
                'platform',
                'userAgent',
            ],
        });
        // return lies list and detail
        const props = lieDetector.getProps();
        const propsSearched = lieDetector.getPropsSearched();
        return {
            lieDetector,
            lieList: Object.keys(props).sort(),
            lieDetail: props,
            lieCount: Object.keys(props).reduce((acc, key) => acc + props[key].length, 0),
            propsSearched,
        };
    }
    const getUserAgentData = async (navigator) => {
        if (!('userAgentData' in navigator)) {
            return;
        }
        const data = await navigator.userAgentData.getHighEntropyValues(['platform', 'platformVersion', 'architecture', 'bitness', 'model', 'uaFullVersion']);
        const { brands, mobile } = navigator.userAgentData || {};
        const compressedBrands = (brands, captureVersion = false) => brands
            .filter((obj) => !/Not/.test(obj.brand)).map((obj) => `${obj.brand}${captureVersion ? ` ${obj.version}` : ''}`);
        const removeChromium = (brands) => (brands.length > 1 ? brands.filter((brand) => !/Chromium/.test(brand)) : brands);
        // compress brands
        if (!data.brands) {
            data.brands = brands;
        }
        data.brandsVersion = compressedBrands(data.brands, true);
        data.brands = compressedBrands(data.brands);
        data.brandsVersion = removeChromium(data.brandsVersion);
        data.brands = removeChromium(data.brands);
        if (!data.mobile) {
            data.mobile = mobile;
        }
        const dataSorted = Object.keys(data).sort().reduce((acc, key) => {
            acc[key] = data[key];
            return acc;
        }, {});
        return dataSorted;
    };
    const getWebglData = () => ask(() => {
        // @ts-ignore
        const canvasOffscreenWebgl = new OffscreenCanvas(256, 256);
        const contextWebgl = canvasOffscreenWebgl.getContext('webgl');
        const rendererInfo = contextWebgl.getExtension('WEBGL_debug_renderer_info');
        return {
            webglVendor: contextWebgl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL),
            webglRenderer: contextWebgl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL),
        };
    });
    const computeTimezoneOffset = () => {
        const date = new Date().getDate();
        const month = new Date().getMonth();
        // @ts-ignore
        const year = Date().split ` `[3]; // current year
        const format = (n) => ('' + n).length == 1 ? `0${n}` : n;
        const dateString = `${month + 1}/${format(date)}/${year}`;
        const dateStringUTC = `${year}-${format(month + 1)}-${format(date)}`;
        // @ts-ignore
        const utc = Date.parse(new Date(dateString));
        const now = +new Date(dateStringUTC);
        return +(((utc - now) / 60000).toFixed(0));
    };
    const getLocale = () => {
        const constructors = [
            'Collator',
            'DateTimeFormat',
            'DisplayNames',
            'ListFormat',
            'NumberFormat',
            'PluralRules',
            'RelativeTimeFormat',
        ];
        // @ts-ignore
        const locale = constructors.reduce((acc, name) => {
            try {
                const obj = new Intl[name];
                if (!obj) {
                    return acc;
                }
                const { locale } = obj.resolvedOptions() || {};
                return [...acc, locale];
            }
            catch (error) {
                return acc;
            }
        }, []);
        return [...new Set(locale)];
    };
    const getWorkerData = async () => {
        const timer = createTimer();
        await queueEvent(timer);
        const userAgentData = await getUserAgentData(navigator).catch((error) => console.error(error));
        // webgl
        const { webglVendor, webglRenderer } = getWebglData() || {};
        // timezone & locale
        const timezoneOffset = computeTimezoneOffset();
        // eslint-disable-next-line new-cap
        const timezoneLocation = Intl.DateTimeFormat().resolvedOptions().timeZone;
        const locale = getLocale();
        // navigator
        const { hardwareConcurrency, language, languages, platform, userAgent, 
        // @ts-expect-error
        deviceMemory, } = navigator || {};
        // prototype lies
        await queueEvent(timer);
        const { 
        // lieDetector: lieProps,
        lieList, lieDetail,
        // lieCount,
        // propsSearched,
         } = getWorkerPrototypeLies(self); // execute and destructure the list and detail
        // const prototypeLies = JSON.parse(JSON.stringify(lieDetail))
        const protoLieLen = lieList.length;
        // match engine locale to system locale to determine if locale entropy is trusty
        let systemCurrencyLocale;
        const lang = ('' + language).split(',')[0];
        try {
            systemCurrencyLocale = (1).toLocaleString((lang || undefined), {
                style: 'currency',
                currency: 'USD',
                currencyDisplay: 'name',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0,
            });
        }
        catch (e) { }
        const engineCurrencyLocale = (1).toLocaleString(undefined, {
            style: 'currency',
            currency: 'USD',
            currencyDisplay: 'name',
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
        });
        const localeEntropyIsTrusty = engineCurrencyLocale == systemCurrencyLocale;
        const localeIntlEntropyIsTrusty = new Set(('' + language).split(',')).has('' + locale);
        const { href, pathname } = self.location || {};
        const locationPathNameLie = (!href ||
            !pathname ||
            !/^\/(docs|creepjs|public)|\/creep.js$/.test(pathname) ||
            !new RegExp(`${pathname}$`).test(href));
        return {
            lied: protoLieLen || +locationPathNameLie,
            lies: {
                proto: protoLieLen ? lieDetail : false,
            },
            locale: '' + locale,
            systemCurrencyLocale,
            engineCurrencyLocale,
            localeEntropyIsTrusty,
            localeIntlEntropyIsTrusty,
            timezoneOffset,
            timezoneLocation,
            deviceMemory,
            hardwareConcurrency,
            language,
            languages: '' + languages,
            platform,
            userAgent,
            webglRenderer,
            webglVendor,
            userAgentData,
        };
    };
    // Compute and communicate from worker scope
    const onEvent = (eventType, fn) => addEventListener(eventType, fn);
    const send = (source) => {
        return getWorkerData().then((data) => source.postMessage(data));
    };
    if (IS_WORKER_SCOPE) {
        globalThis.ServiceWorkerGlobalScope ? onEvent('message', (e) => send(e.source)) :
            globalThis.SharedWorkerGlobalScope ? onEvent('connect', (e) => send(e.ports[0])) :
                send(self); // DedicatedWorkerGlobalScope
    }
    return IS_WORKER_SCOPE ? 0 /* Scope.WORKER */ : 1 /* Scope.WINDOW */;
}
async function getBestWorkerScope() {
    try {
        const timer = createTimer();
        await queueEvent(timer);
        const ask = (fn) => {
            try {
                return fn();
            }
            catch (e) {
                return;
            }
        };
        const hasConstructor = (x, name) => x && x.__proto__.constructor.name == name;
        const getDedicatedWorker = ({ scriptSource }) => new Promise((resolve) => {
            const giveUpOnWorker = setTimeout(() => {
                return resolve(null);
            }, 3000);
            const dedicatedWorker = ask(() => new Worker(workerBlob));
            if (!hasConstructor(dedicatedWorker, 'Worker'))
                return resolve(null);
            dedicatedWorker.onmessage = (event) => {
                dedicatedWorker.terminate();
                clearTimeout(giveUpOnWorker);
                return resolve(event.data);
            };
        });
        const getSharedWorker = ({ scriptSource }) => new Promise((resolve) => {
            const giveUpOnWorker = setTimeout(() => {
                return resolve(null);
            }, 3000);
            const sharedWorker = ask(() => new SharedWorker(workerBlob));
            if (!hasConstructor(sharedWorker, 'SharedWorker'))
                return resolve(null);
            sharedWorker.port.start();
            sharedWorker.port.onmessage = (event) => {
                sharedWorker.port.close();
                clearTimeout(giveUpOnWorker);
                return resolve(event.data);
            };
        });
        const getServiceWorker = ({ scriptSource }) => new Promise((resolve) => {
            const giveUpOnWorker = setTimeout(() => {
                return resolve(null);
            }, 400);
            if (!ask(() => navigator.serviceWorker.register))
                return resolve(null);
            return navigator.serviceWorker.register(scriptSource).then((registration) => {
                if (!hasConstructor(registration, 'ServiceWorkerRegistration'))
                    return resolve(null);
                return navigator.serviceWorker.ready.then((registration) => {
                    // @ts-ignore
                    registration.active.postMessage(undefined);
                    navigator.serviceWorker.onmessage = (event) => {
                        registration.unregister();
                        clearTimeout(giveUpOnWorker);
                        return resolve(event.data);
                    };
                });
            }).catch((error) => {
                console.error(error);
                clearTimeout(giveUpOnWorker);
                return resolve(null);
            });
        });
        const scriptSource = './creep.js';
        let workerScope;
        /*
        WORKER_NAME = 'ServiceWorkerGlobalScope'
        WORKER_TYPE = 'service' // loads fast but is not available in frames
        workerScope = await getServiceWorker({ scriptSource }).catch((error) => {
            captureError(error)
            console.error(error.message)
            return
        })
        */
        if (!(workerScope || {}).userAgent) {
            WORKER_NAME = 'SharedWorkerGlobalScope';
            WORKER_TYPE = 'shared'; // no support in Safari, iOS, and Chrome Android
            workerScope = await getSharedWorker({ scriptSource }).catch((error) => {
                captureError(error);
                console.error(error.message);
                return;
            });
        }
        if (!(workerScope || {}).userAgent) {
            WORKER_NAME = 'DedicatedWorkerGlobalScope';
            WORKER_TYPE = 'dedicated'; // device emulators can easily spoof dedicated scope
            workerScope = await getDedicatedWorker({ scriptSource }).catch((error) => {
                captureError(error);
                console.error(error.message);
                return;
            });
        }
        if (!(workerScope || {}).userAgent) {
            return;
        }
        workerScope.system = getOS(workerScope.userAgent);
        workerScope.device = getUserAgentPlatform({ userAgent: workerScope.userAgent });
        // detect lies
        const { system, userAgent, userAgentData, platform, deviceMemory, hardwareConcurrency, } = workerScope || {};
        // navigator lies
        // skip language and languages to respect valid engine language switching bug in Chrome
        // these are more likely navigator lies, so don't trigger lied worker scope
        const workerScopeMatchLie = 'does not match worker scope';
        if (platform != navigator.platform) {
            documentLie('Navigator.platform', workerScopeMatchLie);
        }
        if (userAgent != navigator.userAgent) {
            documentLie('Navigator.userAgent', workerScopeMatchLie);
        }
        if (hardwareConcurrency && (hardwareConcurrency != navigator.hardwareConcurrency)) {
            documentLie('Navigator.hardwareConcurrency', workerScopeMatchLie);
        }
        // @ts-ignore
        if (deviceMemory && (deviceMemory != navigator.deviceMemory)) {
            documentLie('Navigator.deviceMemory', workerScopeMatchLie);
        }
        // prototype lies
        if (workerScope.lies.proto) {
            const { proto } = workerScope.lies;
            const keys = Object.keys(proto);
            keys.forEach((key) => {
                const api = `WorkerGlobalScope.${key}`;
                const lies = proto[key];
                lies.forEach((lie) => documentLie(api, lie));
            });
        }
        // user agent os lie
        const [userAgentOS, platformOS] = getReportedPlatform(userAgent, platform);
        if (userAgentOS != platformOS) {
            workerScope.lied = true;
            workerScope.lies.os = `${platformOS} platform and ${userAgentOS} user agent do not match`;
            documentLie('WorkerGlobalScope', workerScope.lies.os);
        }
        // user agent engine lie
        const decryptedName = decryptUserAgent({
            ua: userAgent,
            os: system,
            isBrave: false, // default false since we are only looking for JS runtime and version
        });
        const userAgentEngine = ((/safari/i.test(decryptedName) || /iphone|ipad/i.test(userAgent)) ? 'JavaScriptCore' :
            /firefox/i.test(userAgent) ? 'SpiderMonkey' :
                /chrome/i.test(userAgent) ? 'V8' :
                    undefined);
        if (userAgentEngine != JS_ENGINE) {
            workerScope.lied = true;
            workerScope.lies.engine = `${JS_ENGINE} JS runtime and ${userAgentEngine} user agent do not match`;
            documentLie('WorkerGlobalScope', workerScope.lies.engine);
        }
        // user agent version lie
        const getVersion = (x) => (/\d+/.exec(x) || [])[0];
        const userAgentVersion = getVersion(decryptedName);
        const userAgentDataVersion = getVersion(userAgentData ? userAgentData.uaFullVersion : '');
        const versionSupported = userAgentDataVersion && userAgentVersion;
        const versionMatch = userAgentDataVersion == userAgentVersion;
        if (versionSupported && !versionMatch) {
            workerScope.lied = true;
            workerScope.lies.version = `userAgentData version ${userAgentDataVersion} and user agent version ${userAgentVersion} do not match`;
            documentLie('WorkerGlobalScope', workerScope.lies.version);
        }
        // platformVersion lie
        const FEATURE_CASE = IS_BLINK && CSS.supports('accent-color: initial');
        const getPlatformVersionLie = (device, userAgentData) => {
            if (!/windows|mac/i.test(device) || !userAgentData?.platformVersion) {
                return false;
            }
            if (userAgentData.platform == 'macOS') {
                return FEATURE_CASE ? /_/.test(userAgentData.platformVersion) : false;
            }
            const reportedVersionNumber = (/windows ([\d|\.]+)/i.exec(device) || [])[1];
            const windows10OrHigherReport = +reportedVersionNumber == 10;
            const { platformVersion } = userAgentData;
            const versionMap = {
                '6.1': '7',
                '6.2': '8',
                '6.3': '8.1',
                '10.0': '10',
            };
            const version = versionMap[platformVersion];
            if (!FEATURE_CASE && version) {
                return version != reportedVersionNumber;
            }
            const parts = platformVersion.split('.');
            if (parts.length != 3)
                return true;
            const windows10OrHigherPlatform = +parts[0] > 0;
            return ((windows10OrHigherPlatform && !windows10OrHigherReport) ||
                (!windows10OrHigherPlatform && windows10OrHigherReport));
        };
        const windowsVersionLie = getPlatformVersionLie(workerScope.device, userAgentData);
        if (windowsVersionLie) {
            workerScope.lied = true;
            workerScope.lies.platformVersion = `platform version is fake`;
            documentLie('WorkerGlobalScope', workerScope.lies.platformVersion);
        }
        // capture userAgent version
        workerScope.userAgentVersion = userAgentVersion;
        workerScope.userAgentDataVersion = userAgentDataVersion;
        workerScope.userAgentEngine = userAgentEngine;
        const gpu = {
            ...(getWebGLRendererConfidence(workerScope.webglRenderer) || {}),
            compressedGPU: compressWebGLRenderer(workerScope.webglRenderer),
        };
        logTestResult({ time: timer.stop(), test: `${WORKER_TYPE} worker`, passed: true });
        return {
            ...workerScope,
            gpu,
            uaPostReduction: isUAPostReduction(workerScope.userAgent),
        };
    }
    catch (error) {
        logTestResult({ test: 'worker', passed: false });
        captureError(error, 'workers failed or blocked by client');
        return;
    }
}

// https://stackoverflow.com/a/22429679
const hashMini = (x) => {
    const json = `${JSON.stringify(x)}`;
    const hash = json.split('').reduce((hash, char, i) => {
        return Math.imul(31, hash) + json.charCodeAt(i) | 0;
    }, 0x811c9dc5);
    return ('0000000' + (hash >>> 0).toString(16)).substr(-8);
};
// instance id
const instanceId = (String.fromCharCode(Math.random() * 26 + 97) +
    Math.random().toString(36).slice(-7));
// https://stackoverflow.com/a/53490958
// https://stackoverflow.com/a/43383990
// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest
const hashify = (x, algorithm = 'SHA-256') => {
    const json = `${JSON.stringify(x)}`;
    const jsonBuffer = new TextEncoder().encode(json);
    return crypto.subtle.digest(algorithm, jsonBuffer).then((hashBuffer) => {
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map((b) => ('00' + b.toString(16)).slice(-2)).join('');
        return hashHex;
    });
};

const AUDIO_TRAP = Math.random();
async function hasFakeAudio() {
    const context = new OfflineAudioContext(1, 100, 44100);
    const oscillator = context.createOscillator();
    oscillator.frequency.value = 0;
    oscillator.start(0);
    context.startRendering();
    return new Promise((resolve) => {
        context.oncomplete = (event) => {
            const channelData = event.renderedBuffer.getChannelData?.(0);
            if (!channelData)
                resolve(false);
            resolve('' + [...new Set(channelData)] !== '0');
        };
    }).finally(() => oscillator.disconnect());
}
async function getOfflineAudioContext() {
    try {
        const timer = createTimer();
        await queueEvent(timer);
        try {
            // @ts-expect-error if unsupported
            window.OfflineAudioContext = OfflineAudioContext || webkitOfflineAudioContext;
        }
        catch (err) { }
        if (!window.OfflineAudioContext) {
            logTestResult({ test: 'audio', passed: false });
            return;
        }
        // detect lies
        const channelDataLie = lieProps['AudioBuffer.getChannelData'];
        const copyFromChannelLie = lieProps['AudioBuffer.copyFromChannel'];
        let lied = (channelDataLie || copyFromChannelLie) || false;
        const bufferLen = 5000;
        const context = new OfflineAudioContext(1, bufferLen, 44100);
        const analyser = context.createAnalyser();
        const oscillator = context.createOscillator();
        const dynamicsCompressor = context.createDynamicsCompressor();
        const biquadFilter = context.createBiquadFilter();
        // detect lie
        const dataArray = new Float32Array(analyser.frequencyBinCount);
        analyser.getFloatFrequencyData?.(dataArray);
        const floatFrequencyUniqueDataSize = new Set(dataArray).size;
        if (floatFrequencyUniqueDataSize > 1) {
            lied = true;
            const floatFrequencyDataLie = `expected -Infinity (silence) and got ${floatFrequencyUniqueDataSize} frequencies`;
            documentLie(`AnalyserNode.getFloatFrequencyData`, floatFrequencyDataLie);
        }
        const values = {
            ['AnalyserNode.channelCount']: attempt(() => analyser.channelCount),
            ['AnalyserNode.channelCountMode']: attempt(() => analyser.channelCountMode),
            ['AnalyserNode.channelInterpretation']: attempt(() => analyser.channelInterpretation),
            ['AnalyserNode.context.sampleRate']: attempt(() => analyser.context.sampleRate),
            ['AnalyserNode.fftSize']: attempt(() => analyser.fftSize),
            ['AnalyserNode.frequencyBinCount']: attempt(() => analyser.frequencyBinCount),
            ['AnalyserNode.maxDecibels']: attempt(() => analyser.maxDecibels),
            ['AnalyserNode.minDecibels']: attempt(() => analyser.minDecibels),
            ['AnalyserNode.numberOfInputs']: attempt(() => analyser.numberOfInputs),
            ['AnalyserNode.numberOfOutputs']: attempt(() => analyser.numberOfOutputs),
            ['AnalyserNode.smoothingTimeConstant']: attempt(() => analyser.smoothingTimeConstant),
            ['AnalyserNode.context.listener.forwardX.maxValue']: attempt(() => {
                return caniuse(() => analyser.context.listener.forwardX.maxValue);
            }),
            ['BiquadFilterNode.gain.maxValue']: attempt(() => biquadFilter.gain.maxValue),
            ['BiquadFilterNode.frequency.defaultValue']: attempt(() => biquadFilter.frequency.defaultValue),
            ['BiquadFilterNode.frequency.maxValue']: attempt(() => biquadFilter.frequency.maxValue),
            ['DynamicsCompressorNode.attack.defaultValue']: attempt(() => dynamicsCompressor.attack.defaultValue),
            ['DynamicsCompressorNode.knee.defaultValue']: attempt(() => dynamicsCompressor.knee.defaultValue),
            ['DynamicsCompressorNode.knee.maxValue']: attempt(() => dynamicsCompressor.knee.maxValue),
            ['DynamicsCompressorNode.ratio.defaultValue']: attempt(() => dynamicsCompressor.ratio.defaultValue),
            ['DynamicsCompressorNode.ratio.maxValue']: attempt(() => dynamicsCompressor.ratio.maxValue),
            ['DynamicsCompressorNode.release.defaultValue']: attempt(() => dynamicsCompressor.release.defaultValue),
            ['DynamicsCompressorNode.release.maxValue']: attempt(() => dynamicsCompressor.release.maxValue),
            ['DynamicsCompressorNode.threshold.defaultValue']: attempt(() => dynamicsCompressor.threshold.defaultValue),
            ['DynamicsCompressorNode.threshold.minValue']: attempt(() => dynamicsCompressor.threshold.minValue),
            ['OscillatorNode.detune.maxValue']: attempt(() => oscillator.detune.maxValue),
            ['OscillatorNode.detune.minValue']: attempt(() => oscillator.detune.minValue),
            ['OscillatorNode.frequency.defaultValue']: attempt(() => oscillator.frequency.defaultValue),
            ['OscillatorNode.frequency.maxValue']: attempt(() => oscillator.frequency.maxValue),
            ['OscillatorNode.frequency.minValue']: attempt(() => oscillator.frequency.minValue),
        };
        const getRenderedBuffer = (context) => (new Promise((resolve) => {
            const analyser = context.createAnalyser();
            const oscillator = context.createOscillator();
            const dynamicsCompressor = context.createDynamicsCompressor();
            try {
                oscillator.type = 'triangle';
                oscillator.frequency.value = 10000;
                dynamicsCompressor.threshold.value = -50;
                dynamicsCompressor.knee.value = 40;
                dynamicsCompressor.attack.value = 0;
            }
            catch (err) { }
            oscillator.connect(dynamicsCompressor);
            dynamicsCompressor.connect(analyser);
            dynamicsCompressor.connect(context.destination);
            oscillator.start(0);
            context.startRendering();
            return context.addEventListener('complete', (event) => {
                try {
                    dynamicsCompressor.disconnect();
                    oscillator.disconnect();
                    const floatFrequencyData = new Float32Array(analyser.frequencyBinCount);
                    analyser.getFloatFrequencyData?.(floatFrequencyData);
                    const floatTimeDomainData = new Float32Array(analyser.fftSize);
                    if ('getFloatTimeDomainData' in analyser) {
                        analyser.getFloatTimeDomainData(floatTimeDomainData);
                    }
                    return resolve({
                        floatFrequencyData,
                        floatTimeDomainData,
                        buffer: event.renderedBuffer,
                        compressorGainReduction: (
                        // @ts-expect-error if unsupported
                        dynamicsCompressor.reduction.value || // webkit
                            dynamicsCompressor.reduction),
                    });
                }
                catch (error) {
                    return resolve(null);
                }
            });
        }));
        await queueEvent(timer);
        const [audioData, audioIsFake,] = await Promise.all([
            getRenderedBuffer(new OfflineAudioContext(1, bufferLen, 44100)),
            hasFakeAudio().catch(() => false),
        ]);
        const { floatFrequencyData, floatTimeDomainData, buffer, compressorGainReduction, } = audioData || {};
        await queueEvent(timer);
        const getSnapshot = (arr, start, end) => {
            const collection = [];
            for (let i = start; i < end; i++) {
                collection.push(arr[i]);
            }
            return collection;
        };
        const getSum = (arr) => !arr ? 0 : [...arr]
            .reduce((acc, curr) => (acc += Math.abs(curr)), 0);
        const floatFrequencyDataSum = getSum(floatFrequencyData);
        const floatTimeDomainDataSum = getSum(floatTimeDomainData);
        const copy = new Float32Array(bufferLen);
        let bins = new Float32Array();
        if (buffer) {
            buffer.copyFromChannel?.(copy, 0);
            bins = buffer.getChannelData?.(0) || [];
        }
        const copySample = getSnapshot([...copy], 4500, 4600);
        const binsSample = getSnapshot([...bins], 4500, 4600);
        const sampleSum = getSum(getSnapshot([...bins], 4500, bufferLen));
        // detect lies
        if (audioIsFake) {
            lied = true;
            documentLie('AudioBuffer', 'audio is fake');
        }
        // sample matching
        const matching = '' + binsSample == '' + copySample;
        const copyFromChannelSupported = ('copyFromChannel' in AudioBuffer.prototype);
        if (copyFromChannelSupported && !matching) {
            lied = true;
            const audioSampleLie = 'getChannelData and copyFromChannel samples mismatch';
            documentLie('AudioBuffer', audioSampleLie);
        }
        // sample uniqueness
        const totalUniqueSamples = new Set([...bins]).size;
        if (totalUniqueSamples == bufferLen) {
            const audioUniquenessTrash = `${totalUniqueSamples} unique samples of ${bufferLen} is too high`;
            sendToTrash('AudioBuffer', audioUniquenessTrash);
        }
        // sample noise factor
        const getRandFromRange = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const getCopyFrom = (rand, buffer, copy) => {
            const { length } = buffer;
            const max = 20;
            const start = getRandFromRange(275, length - (max + 1));
            const mid = start + max / 2;
            const end = start + max;
            buffer.getChannelData(0)[start] = rand;
            buffer.getChannelData(0)[mid] = rand;
            buffer.getChannelData(0)[end] = rand;
            buffer.copyFromChannel(copy, 0);
            const attack = [
                buffer.getChannelData(0)[start] === 0 ? Math.random() : 0,
                buffer.getChannelData(0)[mid] === 0 ? Math.random() : 0,
                buffer.getChannelData(0)[end] === 0 ? Math.random() : 0,
            ];
            return [...new Set([...buffer.getChannelData(0), ...copy, ...attack])].filter((x) => x !== 0);
        };
        const getCopyTo = (rand, buffer, copy) => {
            buffer.copyToChannel(copy.map(() => rand), 0);
            const frequency = buffer.getChannelData(0)[0];
            const dataAttacked = [...buffer.getChannelData(0)]
                .map((x) => x !== frequency || !x ? Math.random() : x);
            return dataAttacked.filter((x) => x !== frequency);
        };
        const getNoiseFactor = () => {
            const length = 2000;
            try {
                const result = [...new Set([
                        ...getCopyFrom(AUDIO_TRAP, new AudioBuffer({ length, sampleRate: 44100 }), new Float32Array(length)),
                        ...getCopyTo(AUDIO_TRAP, new AudioBuffer({ length, sampleRate: 44100 }), new Float32Array(length)),
                    ])];
                return +(result.length !== 1 &&
                    result.reduce((acc, n) => acc += +n, 0));
            }
            catch (error) {
                console.error(error);
                return 0;
            }
        };
        const noiseFactor = getNoiseFactor();
        const noise = (noiseFactor || [...new Set(bins.slice(0, 100))]
            .reduce((acc, n) => acc += n, 0));
        // Locked Patterns
        const known = {
            /* BLINK */
            // 124.04347527516074/124.04347518575378
            '-20.538286209106445,164537.64796829224,502.5999283068122': [124.04347527516074],
            '-20.538288116455078,164537.64796829224,502.5999283068122': [124.04347527516074],
            '-20.538288116455078,164537.64795303345,502.5999283068122': [
                124.04347527516074,
                124.04347518575378,
                // sus:
                124.04347519320436,
                124.04347523045726,
            ],
            '-20.538286209106445,164537.64805984497,502.5999283068122': [124.04347527516074],
            '-20.538288116455078,164537.64805984497,502.5999283068122': [
                124.04347527516074,
                124.04347518575378,
                // sus
                124.04347520065494,
                124.04347523790784,
                124.043475252809,
                124.04347526025958,
                124.04347522300668,
                124.04347523045726,
                124.04347524535842,
            ],
            // 124.04344884395687
            '-20.538288116455078,164881.9727935791,502.59990317908887': [124.04344884395687],
            '-20.538288116455078,164881.9729309082,502.59990317908887': [124.04344884395687],
            // 124.0434488439787
            '-20.538286209106445,164882.2082748413,502.59990317911434': [124.0434488439787],
            '-20.538288116455078,164882.20836639404,502.59990317911434': [124.0434488439787],
            // 124.04344968475198
            '-20.538286209106445,164863.45319366455,502.5999033495791': [124.04344968475198],
            '-20.538288116455078,164863.45319366455,502.5999033495791': [
                124.04344968475198,
                124.04375314689969,
                // sus
                124.04341541208123,
            ],
            // 124.04347503720783 (rare)
            '-20.538288116455078,164531.82670593262,502.59992767886797': [
                124.04347503720783,
                // sus
                124.04347494780086,
                124.04347495525144,
                124.04347499250434,
                124.0434750074055,
            ],
            // 124.04347657808103
            '-20.538286209106445,164540.1567993164,502.59992209258417': [124.04347657808103],
            '-20.538288116455078,164540.1567993164,502.59992209258417': [
                124.04347657808103,
                124.0434765110258,
                124.04347656317987,
                // sus
                124.04347657063045,
                124.04378004022874,
            ],
            '-20.538288116455078,164540.1580810547,502.59992209258417': [124.04347657808103],
            // 124.080722568091/124.04347730590962 (rare)
            '-20.535268783569336,164940.360786438,502.69695458233764': [124.080722568091],
            '-20.538288116455078,164538.55073928833,502.5999307175407': [124.04347730590962],
            // Android/Linux
            '-20.535268783569336,164948.14596557617,502.6969545823631': [124.08072256811283],
            '-20.535268783569336,164926.65912628174,502.6969610930064': [124.08072766105033],
            '-20.535268783569336,164932.96168518066,502.69696179985476': [124.08072787802666],
            '-20.535268783569336,164931.54252624512,502.6969617998802': [124.08072787804849],
            '-20.535268783569336,164591.9659729004,502.6969925059784': [124.08074500028306],
            '-20.535268783569336,164590.4111480713,502.6969947774742': [124.0807470110085],
            '-20.535268783569336,164590.41115570068,502.6969947774742': [124.0807470110085],
            '-20.535268783569336,164593.64263916016,502.69700490119067': [124.08075528279005],
            '-20.535268783569336,164595.0285797119,502.69700578315314': [124.08075643483608],
            // sus
            '-20.538288116455078,164860.96576690674,502.6075748118915': [124.0434496279413],
            '-20.538288116455078,164860.9938583374,502.6073723861407': [124.04344962817413],
            '-20.538288116455078,164862.14078521729,502.59991004130643': [124.04345734833623],
            '-20.538288116455078,164534.50047683716,502.61542110471055': [124.04347520368174],
            '-20.538288116455078,164535.1324043274,502.6079200572931': [124.04347521997988],
            '-20.538288116455078,164535.51135635376,502.60633126448374': [124.04347522952594],
            /* GECKO */
            '-31.509262084960938,167722.6894454956,148.42717787250876': [35.7383295930922],
            '-31.509262084960938,167728.72756958008,148.427184343338': [35.73833402246237],
            '-31.50218963623047,167721.27517700195,148.47537828609347': [35.74996031448245],
            '-31.502185821533203,167727.52931976318,148.47542023658752': [35.7499681673944],
            /* WEBKIT */
            '-20.538288116455078,164873.80361557007,502.59989904452596': [124.0434485301812],
            '-20.538288116455078,164863.47760391235,502.5999033453372': [124.0434496849557],
            '-20.538288116455078,164876.62466049194,502.5998911961724': [124.043453265891],
            '-20.538288116455078,164862.14879989624,502.59991004130643': [124.04345734833623],
            '-20.538288116455078,164896.54167175293,502.5999054916465': [124.04345808873768],
            '-29.837873458862305,163206.43050384521,0': [35.10892717540264],
            '-29.837873458862305,163224.69785308838,0': [35.10892752557993],
            '-29.83786964416504,163209.17245483398,0': [35.10893232002854],
            '-29.83786964416504,163202.77336883545,0': [35.10893253237009],
        };
        if (noise) {
            lied = true;
            documentLie('AudioBuffer', 'sample noise detected');
        }
        const pattern = '' + [
            compressorGainReduction,
            floatFrequencyDataSum,
            floatTimeDomainDataSum,
        ];
        const knownPattern = known[pattern];
        if (knownPattern && !knownPattern.includes(sampleSum)) {
            LowerEntropy.AUDIO = true;
            sendToTrash('AudioBuffer', 'suspicious frequency data');
        }
        logTestResult({ time: timer.stop(), test: 'audio', passed: true });
        return {
            totalUniqueSamples,
            compressorGainReduction,
            floatFrequencyDataSum,
            floatTimeDomainDataSum,
            sampleSum,
            binsSample,
            copySample: copyFromChannelSupported ? copySample : [undefined],
            values,
            noise,
            lied,
        };
    }
    catch (error) {
        logTestResult({ test: 'audio', passed: false });
        captureError(error, 'OfflineAudioContext failed or blocked by client');
        return;
    }
}

// inspired by https://arkenfox.github.io/TZP/tests/canvasnoise.html
let pixelImageRandom = '';
const getPixelMods = () => {
    const pattern1 = [];
    const pattern2 = [];
    const len = 8; // canvas dimensions
    const alpha = 255;
    const visualMultiplier = 5;
    try {
        // create 2 canvas contexts
        const options = {
            willReadFrequently: true,
            desynchronized: true,
        };
        const canvasDisplay1 = document.createElement('canvas');
        const canvasDisplay2 = document.createElement('canvas');
        const canvas1 = document.createElement('canvas');
        const canvas2 = document.createElement('canvas');
        const contextDisplay1 = canvasDisplay1.getContext('2d', options);
        const contextDisplay2 = canvasDisplay2.getContext('2d', options);
        const context1 = canvas1.getContext('2d', options);
        const context2 = canvas2.getContext('2d', options);
        if (!contextDisplay1 || !contextDisplay2 || !context1 || !context2) {
            throw new Error('canvas context blocked');
        }
        // set the dimensions
        canvasDisplay1.width = len * visualMultiplier;
        canvasDisplay1.height = len * visualMultiplier;
        canvasDisplay2.width = len * visualMultiplier;
        canvasDisplay2.height = len * visualMultiplier;
        canvas1.width = len;
        canvas1.height = len;
        canvas2.width = len;
        canvas2.height = len;
        [...Array(len)].forEach((e, x) => [...Array(len)].forEach((e, y) => {
            const red = ~~(Math.random() * 256);
            const green = ~~(Math.random() * 256);
            const blue = ~~(Math.random() * 256);
            const colors = `${red}, ${green}, ${blue}, ${alpha}`;
            context1.fillStyle = `rgba(${colors})`;
            context1.fillRect(x, y, 1, 1);
            // capture data in visuals
            contextDisplay1.fillStyle = `rgba(${colors})`;
            contextDisplay1.fillRect(x * visualMultiplier, y * visualMultiplier, 1 * visualMultiplier, 1 * visualMultiplier);
            return pattern1.push(colors); // collect the pixel pattern
        }));
        [...Array(len)].forEach((e, x) => [...Array(len)].forEach((e, y) => {
            // get context1 pixel data and mirror to context2
            const { data: [red, green, blue, alpha], } = context1.getImageData(x, y, 1, 1) || {};
            const colors = `${red}, ${green}, ${blue}, ${alpha}`;
            context2.fillStyle = `rgba(${colors})`;
            context2.fillRect(x, y, 1, 1);
            // capture noise in visuals
            const { data: [red2, green2, blue2, alpha2], } = context2.getImageData(x, y, 1, 1) || {};
            const colorsDisplay = `
				${red != red2 ? red2 : 255},
				${green != green2 ? green2 : 255},
				${blue != blue2 ? blue2 : 255},
				${alpha != alpha2 ? alpha2 : 1}
			`;
            contextDisplay2.fillStyle = `rgba(${colorsDisplay})`;
            contextDisplay2.fillRect(x * visualMultiplier, y * visualMultiplier, 1 * visualMultiplier, 1 * visualMultiplier);
            return pattern2.push(colors); // collect the pixel pattern
        }));
        // compare the pattern collections and collect diffs
        const patternDiffs = [];
        const rgbaChannels = new Set();
        [...Array(pattern1.length)].forEach((e, i) => {
            const pixelColor1 = pattern1[i];
            const pixelColor2 = pattern2[i];
            if (pixelColor1 != pixelColor2) {
                const rgbaValues1 = pixelColor1.split(',');
                const rgbaValues2 = pixelColor2.split(',');
                const colors = [
                    rgbaValues1[0] != rgbaValues2[0] ? 'r' : '',
                    rgbaValues1[1] != rgbaValues2[1] ? 'g' : '',
                    rgbaValues1[2] != rgbaValues2[2] ? 'b' : '',
                    rgbaValues1[3] != rgbaValues2[3] ? 'a' : '',
                ].join('');
                rgbaChannels.add(colors);
                patternDiffs.push([i, colors]);
            }
        });
        pixelImageRandom = canvasDisplay1.toDataURL(); // template use only
        const pixelImage = canvasDisplay2.toDataURL();
        const rgba = rgbaChannels.size ? [...rgbaChannels].sort().join(', ') : undefined;
        const pixels = patternDiffs.length || undefined;
        return { rgba, pixels, pixelImage };
    }
    catch (error) {
        return console.error(error);
    }
};
// based on and inspired by https://github.com/antoinevastel/picasso-like-canvas-fingerprinting
const paintCanvas = ({ canvas, context, strokeText = false, cssFontFamily = '', area = { width: 50, height: 50 }, rounds = 10, maxShadowBlur = 50, seed = 500, offset = 2001000001, multiplier = 15000, }) => {
    if (!context) {
        return;
    }
    context.clearRect(0, 0, canvas.width, canvas.height);
    canvas.width = area.width;
    canvas.height = area.height;
    if (canvas.style) {
        canvas.style.display = 'none';
    }
    const createPicassoSeed = ({ seed, offset, multiplier }) => {
        let current = Number(seed) % Number(offset);
        const getNextSeed = () => {
            current = (Number(multiplier) * current) % Number(offset);
            return current;
        };
        return {
            getNextSeed,
        };
    };
    const picassoSeed = createPicassoSeed({ seed, offset, multiplier });
    const { getNextSeed } = picassoSeed;
    const patchSeed = (current, offset, maxBound, computeFloat) => {
        const result = (((current - 1) / offset) * (maxBound || 1)) || 0;
        return computeFloat ? result : Math.floor(result);
    };
    const addRandomCanvasGradient = (context, offset, area, colors, getNextSeed) => {
        const { width, height } = area;
        const canvasGradient = context.createRadialGradient(patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height), patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height), patchSeed(getNextSeed(), offset, width));
        canvasGradient.addColorStop(0, colors[patchSeed(getNextSeed(), offset, colors.length)]);
        canvasGradient.addColorStop(1, colors[patchSeed(getNextSeed(), offset, colors.length)]);
        context.fillStyle = canvasGradient;
    };
    const colors = [
        '#FF6633', '#FFB399', '#FF33FF', '#FFFF99', '#00B3E6',
        '#E6B333', '#3366E6', '#999966', '#99FF99', '#B34D4D',
        '#80B300', '#809900', '#E6B3B3', '#6680B3', '#66991A',
        '#FF99E6', '#CCFF1A', '#FF1A66', '#E6331A', '#33FFCC',
        '#66994D', '#B366CC', '#4D8000', '#B33300', '#CC80CC',
        '#66664D', '#991AFF', '#E666FF', '#4DB3FF', '#1AB399',
        '#E666B3', '#33991A', '#CC9999', '#B3B31A', '#00E680',
        '#4D8066', '#809980', '#E6FF80', '#1AFF33', '#999933',
        '#FF3380', '#CCCC00', '#66E64D', '#4D80CC', '#9900B3',
        '#E64D66', '#4DB380', '#FF4D4D', '#99E6E6', '#6666FF',
    ];
    const drawOutlineOfText = (context, offset, area, getNextSeed) => {
        const { width, height } = area;
        const fontSize = 2.99;
        context.font = `${height / fontSize}px ${cssFontFamily.replace(/!important/gm, '')}`;
        context.strokeText('👾A', patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height), patchSeed(getNextSeed(), offset, width));
    };
    const createCircularArc = (context, offset, area, getNextSeed) => {
        const { width, height } = area;
        context.beginPath();
        context.arc(patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height), patchSeed(getNextSeed(), offset, Math.min(width, height)), patchSeed(getNextSeed(), offset, 2 * Math.PI, true), patchSeed(getNextSeed(), offset, 2 * Math.PI, true));
        context.stroke();
    };
    const createBezierCurve = (context, offset, area, getNextSeed) => {
        const { width, height } = area;
        context.beginPath();
        context.moveTo(patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height));
        context.bezierCurveTo(patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height), patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height), patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height));
        context.stroke();
    };
    const createQuadraticCurve = (context, offset, area, getNextSeed) => {
        const { width, height } = area;
        context.beginPath();
        context.moveTo(patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height));
        context.quadraticCurveTo(patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height), patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height));
        context.stroke();
    };
    const createEllipticalArc = (context, offset, area, getNextSeed) => {
        if (!('ellipse' in context)) {
            return;
        }
        const { width, height } = area;
        context.beginPath();
        context.ellipse(patchSeed(getNextSeed(), offset, width), patchSeed(getNextSeed(), offset, height), patchSeed(getNextSeed(), offset, Math.floor(width / 2)), patchSeed(getNextSeed(), offset, Math.floor(height / 2)), patchSeed(getNextSeed(), offset, 2 * Math.PI, true), patchSeed(getNextSeed(), offset, 2 * Math.PI, true), patchSeed(getNextSeed(), offset, 2 * Math.PI, true));
        context.stroke();
    };
    const methods = [
        createCircularArc,
        createBezierCurve,
        createQuadraticCurve,
    ];
    if (!IS_WEBKIT)
        methods.push(createEllipticalArc); // unstable in webkit
    if (strokeText)
        methods.push(drawOutlineOfText);
    [...Array(rounds)].forEach((x) => {
        addRandomCanvasGradient(context, offset, area, colors, getNextSeed);
        context.shadowBlur = patchSeed(getNextSeed(), offset, maxShadowBlur, true);
        context.shadowColor = colors[patchSeed(getNextSeed(), offset, colors.length)];
        const nextMethod = methods[patchSeed(getNextSeed(), offset, methods.length)];
        nextMethod(context, offset, area, getNextSeed);
        context.fill();
    });
    return;
};
async function getCanvas2d() {
    try {
        const timer = createTimer();
        await queueEvent(timer);
        const dataLie = lieProps['HTMLCanvasElement.toDataURL'];
        const contextLie = lieProps['HTMLCanvasElement.getContext'];
        const imageDataLie = (lieProps['CanvasRenderingContext2D.fillText'] ||
            lieProps['CanvasRenderingContext2D.font'] ||
            lieProps['CanvasRenderingContext2D.getImageData'] ||
            lieProps['CanvasRenderingContext2D.strokeText']);
        const codePointLie = lieProps['String.fromCodePoint'];
        let textMetricsLie = (lieProps['CanvasRenderingContext2D.measureText'] ||
            lieProps['TextMetrics.actualBoundingBoxAscent'] ||
            lieProps['TextMetrics.actualBoundingBoxDescent'] ||
            lieProps['TextMetrics.actualBoundingBoxLeft'] ||
            lieProps['TextMetrics.actualBoundingBoxRight'] ||
            lieProps['TextMetrics.fontBoundingBoxAscent'] ||
            lieProps['TextMetrics.fontBoundingBoxDescent'] ||
            lieProps['TextMetrics.width']);
        let lied = (dataLie ||
            contextLie ||
            imageDataLie ||
            textMetricsLie ||
            codePointLie) || false;
        // create canvas context
        let win = window;
        if (!LIKE_BRAVE && PHANTOM_DARKNESS) {
            win = PHANTOM_DARKNESS;
        }
        const doc = win.document;
        const canvas = doc.createElement('canvas');
        const context = canvas.getContext('2d');
        const canvasCPU = doc.createElement('canvas');
        const contextCPU = canvasCPU.getContext('2d', {
            desynchronized: true,
            willReadFrequently: true,
        });
        if (!context) {
            throw new Error('canvas context blocked');
        }
        await queueEvent(timer);
        const imageSizeMax = IS_WEBKIT ? 50 : 75; // webkit is unstable
        paintCanvas({
            canvas,
            context,
            strokeText: true,
            cssFontFamily: CSS_FONT_FAMILY,
            area: { width: imageSizeMax, height: imageSizeMax },
            rounds: 10,
        });
        const dataURI = canvas.toDataURL();
        await queueEvent(timer);
        const mods = getPixelMods();
        // TextMetrics: get emoji set and system
        await queueEvent(timer);
        context.font = `10px ${CSS_FONT_FAMILY.replace(/!important/gm, '')}`;
        const pattern = new Set();
        const emojiSet = EMOJIS.reduce((emojiSet, emoji) => {
            const { actualBoundingBoxAscent, actualBoundingBoxDescent, actualBoundingBoxLeft, actualBoundingBoxRight, fontBoundingBoxAscent, fontBoundingBoxDescent, width, } = context.measureText(emoji) || {};
            const dimensions = [
                actualBoundingBoxAscent,
                actualBoundingBoxDescent,
                actualBoundingBoxLeft,
                actualBoundingBoxRight,
                fontBoundingBoxAscent,
                fontBoundingBoxDescent,
                width,
            ].join(',');
            if (!pattern.has(dimensions)) {
                pattern.add(dimensions);
                emojiSet.add(emoji);
            }
            return emojiSet;
        }, new Set());
        // textMetrics System Sum
        const textMetricsSystemSum = 0.00001 * [...pattern].map((x) => {
            return x.split(',').reduce((acc, x) => acc += (+x || 0), 0);
        }).reduce((acc, x) => acc += x, 0);
        // Paint
        const maxSize = 75;
        await queueEvent(timer);
        paintCanvas({
            canvas,
            context,
            area: { width: maxSize, height: maxSize },
        }); // clears image
        const paintURI = canvas.toDataURL();
        // Paint with CPU
        await queueEvent(timer);
        paintCanvas({
            canvas: canvasCPU,
            context: contextCPU,
            area: { width: maxSize, height: maxSize },
        }); // clears image
        const paintCpuURI = canvasCPU.toDataURL();
        // Text
        context.restore();
        context.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = 50;
        canvas.height = 50;
        context.font = `50px ${CSS_FONT_FAMILY.replace(/!important/gm, '')}`;
        context.fillText('A', 7, 37);
        const textURI = canvas.toDataURL();
        // Emoji
        context.restore();
        context.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = 50;
        canvas.height = 50;
        context.font = `35px ${CSS_FONT_FAMILY.replace(/!important/gm, '')}`;
        context.fillText('👾', 0, 37);
        const emojiURI = canvas.toDataURL();
        // lies
        context.clearRect(0, 0, canvas.width, canvas.height);
        if ((mods && mods.pixels) || !!Math.max(...context.getImageData(0, 0, 8, 8).data)) {
            lied = true;
            documentLie(`CanvasRenderingContext2D.getImageData`, `pixel data modified`);
        }
        // verify low entropy image data
        canvas.width = 2;
        canvas.height = 2;
        context.fillStyle = '#000';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = '#fff';
        context.fillRect(2, 2, 1, 1);
        context.beginPath();
        context.arc(0, 0, 2, 0, 1, true);
        context.closePath();
        context.fill();
        const imageDataLowEntropy = context.getImageData(0, 0, 2, 2).data.join('');
        const KnownImageData = {
            BLINK: [
                '255255255255192192192255240240240255484848255',
                '255255255255177177177255246246246255535353255',
                '255255255255128128128255191191191255646464255',
                '255255255255178178178255247247247255565656255',
                '255255255255174174174255242242242255474747255',
                '255255255255229229229255127127127255686868255',
                '255255255255192192192255244244244255535353255',
            ],
            GECKO: [
                '255255255255192192192255240240240255484848255',
                '255255255255191191191255239239239255646464255',
                '255255255255191191191255223223223255606060255',
                '255255255255171171171255223223223255606060255', // ?
            ],
            WEBKIT: [
                '255255255255185185185255233233233255474747255',
                '255255255255185185185255229229229255474747255',
                '255255255255185185185255218218218255474747255',
                '255255255255192192192255240240240255484848255',
                '255255255255178178178255247247247255565656255',
                '255255255255178178178255247247247255565656255',
                '255255255255192192192255240240240255484848255',
                '255255255255186186186255218218218255464646255',
            ],
        };
        Analysis.imageDataLowEntropy = imageDataLowEntropy;
        if (IS_BLINK && !KnownImageData.BLINK.includes(imageDataLowEntropy)) {
            LowerEntropy.CANVAS = true;
        }
        else if (IS_GECKO && !KnownImageData.GECKO.includes(imageDataLowEntropy)) {
            LowerEntropy.CANVAS = true;
        }
        else if (IS_WEBKIT && !KnownImageData.WEBKIT.includes(imageDataLowEntropy)) {
            LowerEntropy.CANVAS = true;
        }
        if (LowerEntropy.CANVAS) {
            sendToTrash('CanvasRenderingContext2D.getImageData', 'suspicious pixel data');
        }
        const getTextMetricsFloatLie = (context) => {
            const isFloat = (n) => n % 1 !== 0;
            const { actualBoundingBoxAscent: abba, actualBoundingBoxDescent: abbd, actualBoundingBoxLeft: abbl, actualBoundingBoxRight: abbr, fontBoundingBoxAscent: fbba, fontBoundingBoxDescent: fbbd,
            // width: w,
             } = context.measureText('') || {};
            const lied = [
                abba,
                abbd,
                abbl,
                abbr,
                fbba,
                fbbd,
            ].find((x) => isFloat((x || 0)));
            return lied;
        };
        await queueEvent(timer);
        if (getTextMetricsFloatLie(context)) {
            textMetricsLie = true;
            lied = true;
            documentLie('CanvasRenderingContext2D.measureText', 'metric noise detected');
        }
        logTestResult({ time: timer.stop(), test: 'canvas 2d', passed: true });
        return {
            dataURI,
            paintURI,
            paintCpuURI,
            textURI,
            emojiURI,
            mods,
            textMetricsSystemSum,
            liedTextMetrics: textMetricsLie,
            emojiSet: [...emojiSet],
            lied,
        };
    }
    catch (error) {
        logTestResult({ test: 'canvas 2d', passed: false });
        captureError(error);
        return;
    }
}

function getCSS() {
    const computeStyle = (type, { require: [captureError] }) => {
        try {
            // get CSSStyleDeclaration
            const cssStyleDeclaration = (type == 'getComputedStyle' ? getComputedStyle(document.body) :
                type == 'HTMLElement.style' ? document.body.style :
                    // @ts-ignore
                    type == 'CSSRuleList.style' ? document.styleSheets[0].cssRules[0].style :
                        undefined);
            if (!cssStyleDeclaration) {
                throw new TypeError('invalid argument string');
            }
            // get properties
            const proto = Object.getPrototypeOf(cssStyleDeclaration);
            const prototypeProperties = Object.getOwnPropertyNames(proto);
            const ownEnumerablePropertyNames = [];
            const cssVar = /^--.*$/;
            Object.keys(cssStyleDeclaration).forEach((key) => {
                const numericKey = !isNaN(+key);
                const value = cssStyleDeclaration[key];
                const customPropKey = cssVar.test(key);
                const customPropValue = cssVar.test(value);
                if (numericKey && !customPropValue) {
                    return ownEnumerablePropertyNames.push(value);
                }
                else if (!numericKey && !customPropKey) {
                    return ownEnumerablePropertyNames.push(key);
                }
                return;
            });
            // get properties in prototype chain (required only in chrome)
            const propertiesInPrototypeChain = {};
            const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
            const uncapitalize = (str) => str.charAt(0).toLowerCase() + str.slice(1);
            const removeFirstChar = (str) => str.slice(1);
            const caps = /[A-Z]/g;
            ownEnumerablePropertyNames.forEach((key) => {
                if (propertiesInPrototypeChain[key]) {
                    return;
                }
                // determine attribute type
                const isNamedAttribute = key.indexOf('-') > -1;
                const isAliasAttribute = caps.test(key);
                // reduce key for computation
                const firstChar = key.charAt(0);
                const isPrefixedName = isNamedAttribute && firstChar == '-';
                const isCapitalizedAlias = isAliasAttribute && firstChar == firstChar.toUpperCase();
                key = (isPrefixedName ? removeFirstChar(key) :
                    isCapitalizedAlias ? uncapitalize(key) :
                        key);
                // find counterpart in CSSStyleDeclaration object or its prototype chain
                if (isNamedAttribute) {
                    const aliasAttribute = key.split('-').map((word, index) => index == 0 ? word : capitalize(word)).join('');
                    if (aliasAttribute in cssStyleDeclaration) {
                        propertiesInPrototypeChain[aliasAttribute] = true;
                    }
                    else if (capitalize(aliasAttribute) in cssStyleDeclaration) {
                        propertiesInPrototypeChain[capitalize(aliasAttribute)] = true;
                    }
                }
                else if (isAliasAttribute) {
                    const namedAttribute = key.replace(caps, (char) => '-' + char.toLowerCase());
                    if (namedAttribute in cssStyleDeclaration) {
                        propertiesInPrototypeChain[namedAttribute] = true;
                    }
                    else if (`-${namedAttribute}` in cssStyleDeclaration) {
                        propertiesInPrototypeChain[`-${namedAttribute}`] = true;
                    }
                }
                return;
            });
            // compile keys
            const keys = [
                ...new Set([
                    ...prototypeProperties,
                    ...ownEnumerablePropertyNames,
                    ...Object.keys(propertiesInPrototypeChain),
                ]),
            ];
            // @ts-ignore
            const interfaceName = ('' + proto).match(/\[object (.+)\]/)[1];
            return { keys, interfaceName };
        }
        catch (error) {
            captureError(error);
            return;
        }
    };
    const getSystemStyles = (el) => {
        try {
            const colors = [
                'ActiveBorder',
                'ActiveCaption',
                'ActiveText',
                'AppWorkspace',
                'Background',
                'ButtonBorder',
                'ButtonFace',
                'ButtonHighlight',
                'ButtonShadow',
                'ButtonText',
                'Canvas',
                'CanvasText',
                'CaptionText',
                'Field',
                'FieldText',
                'GrayText',
                'Highlight',
                'HighlightText',
                'InactiveBorder',
                'InactiveCaption',
                'InactiveCaptionText',
                'InfoBackground',
                'InfoText',
                'LinkText',
                'Mark',
                'MarkText',
                'Menu',
                'MenuText',
                'Scrollbar',
                'ThreeDDarkShadow',
                'ThreeDFace',
                'ThreeDHighlight',
                'ThreeDLightShadow',
                'ThreeDShadow',
                'VisitedText',
                'Window',
                'WindowFrame',
                'WindowText',
            ];
            const fonts = [
                'caption',
                'icon',
                'menu',
                'message-box',
                'small-caption',
                'status-bar',
            ];
            const getStyles = (el) => ({
                colors: colors.map((color) => {
                    el.setAttribute('style', `background-color: ${color} !important`);
                    return {
                        [color]: getComputedStyle(el).backgroundColor,
                    };
                }),
                fonts: fonts.map((font) => {
                    el.setAttribute('style', `font: ${font} !important`);
                    const computedStyle = getComputedStyle(el);
                    return {
                        [font]: `${computedStyle.fontSize} ${computedStyle.fontFamily}`,
                    };
                }),
            });
            if (!el) {
                el = document.createElement('div');
                document.body.append(el);
                const systemStyles = getStyles(el);
                el.parentNode.removeChild(el);
                return systemStyles;
            }
            return getStyles(el);
        }
        catch (error) {
            captureError(error);
            return;
        }
    };
    try {
        const timer = createTimer();
        timer.start();
        const computedStyle = computeStyle('getComputedStyle', { require: [captureError] });
        const system = getSystemStyles(PARENT_PHANTOM);
        logTestResult({ time: timer.stop(), test: 'computed style', passed: true });
        return {
            computedStyle,
            system,
        };
    }
    catch (error) {
        logTestResult({ test: 'computed style', passed: false });
        captureError(error);
        return;
    }
}

function getCSSMedia() {
    const gcd = (a, b) => b == 0 ? a : gcd(b, a % b);
    const getAspectRatio = (width, height) => {
        const r = gcd(width, height);
        const aspectRatio = `${width / r}/${height / r}`;
        return aspectRatio;
    };
    const query = ({ body, type, rangeStart, rangeLen }) => {
        const html = [...Array(rangeLen)].map((slot, i) => {
            i += rangeStart;
            return `@media(device-${type}:${i}px){body{--device-${type}:${i};}}`;
        }).join('');
        body.innerHTML = `<style>${html}</style>`;
        const style = getComputedStyle(body);
        return style.getPropertyValue(`--device-${type}`).trim();
    };
    const getScreenMedia = ({ body, width, height }) => {
        let widthMatch = query({ body, type: 'width', rangeStart: width, rangeLen: 1 });
        let heightMatch = query({ body, type: 'height', rangeStart: height, rangeLen: 1 });
        if (widthMatch && heightMatch) {
            return { width, height };
        }
        const rangeLen = 1000;
        [...Array(10)].find((slot, i) => {
            if (!widthMatch) {
                widthMatch = query({ body, type: 'width', rangeStart: i * rangeLen, rangeLen });
            }
            if (!heightMatch) {
                heightMatch = query({ body, type: 'height', rangeStart: i * rangeLen, rangeLen });
            }
            return widthMatch && heightMatch;
        });
        return { width: +widthMatch, height: +heightMatch };
    };
    try {
        const timer = createTimer();
        timer.start();
        const win = PHANTOM_DARKNESS.window;
        const { body } = win.document;
        const { width, availWidth, height, availHeight } = win.screen;
        const noTaskbar = !(width - availWidth || height - availHeight);
        if (screen.width !== width || (width > 800 && noTaskbar)) {
            LowerEntropy.IFRAME_SCREEN = true;
        }
        const deviceAspectRatio = getAspectRatio(width, height);
        const matchMediaCSS = {
            ['prefers-reduced-motion']: (win.matchMedia('(prefers-reduced-motion: no-preference)').matches ? 'no-preference' :
                win.matchMedia('(prefers-reduced-motion: reduce)').matches ? 'reduce' : undefined),
            ['prefers-color-scheme']: (win.matchMedia('(prefers-color-scheme: light)').matches ? 'light' :
                win.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : undefined),
            monochrome: (win.matchMedia('(monochrome)').matches ? 'monochrome' :
                win.matchMedia('(monochrome: 0)').matches ? 'non-monochrome' : undefined),
            ['inverted-colors']: (win.matchMedia('(inverted-colors: inverted)').matches ? 'inverted' :
                win.matchMedia('(inverted-colors: none)').matches ? 'none' : undefined),
            ['forced-colors']: (win.matchMedia('(forced-colors: none)').matches ? 'none' :
                win.matchMedia('(forced-colors: active)').matches ? 'active' : undefined),
            ['any-hover']: (win.matchMedia('(any-hover: hover)').matches ? 'hover' :
                win.matchMedia('(any-hover: none)').matches ? 'none' : undefined),
            hover: (win.matchMedia('(hover: hover)').matches ? 'hover' :
                win.matchMedia('(hover: none)').matches ? 'none' : undefined),
            ['any-pointer']: (win.matchMedia('(any-pointer: fine)').matches ? 'fine' :
                win.matchMedia('(any-pointer: coarse)').matches ? 'coarse' :
                    win.matchMedia('(any-pointer: none)').matches ? 'none' : undefined),
            pointer: (win.matchMedia('(pointer: fine)').matches ? 'fine' :
                win.matchMedia('(pointer: coarse)').matches ? 'coarse' :
                    win.matchMedia('(pointer: none)').matches ? 'none' : undefined),
            ['device-aspect-ratio']: (win.matchMedia(`(device-aspect-ratio: ${deviceAspectRatio})`).matches ? deviceAspectRatio : undefined),
            ['device-screen']: (win.matchMedia(`(device-width: ${width}px) and (device-height: ${height}px)`).matches ? `${width} x ${height}` : undefined),
            ['display-mode']: (win.matchMedia('(display-mode: fullscreen)').matches ? 'fullscreen' :
                win.matchMedia('(display-mode: standalone)').matches ? 'standalone' :
                    win.matchMedia('(display-mode: minimal-ui)').matches ? 'minimal-ui' :
                        win.matchMedia('(display-mode: browser)').matches ? 'browser' : undefined),
            ['color-gamut']: (win.matchMedia('(color-gamut: srgb)').matches ? 'srgb' :
                win.matchMedia('(color-gamut: p3)').matches ? 'p3' :
                    win.matchMedia('(color-gamut: rec2020)').matches ? 'rec2020' : undefined),
            orientation: (win.matchMedia('(orientation: landscape)').matches ? 'landscape' :
                win.matchMedia('(orientation: portrait)').matches ? 'portrait' : undefined),
        };
        body.innerHTML = `
		<style>
		@media (prefers-reduced-motion: no-preference) {body {--prefers-reduced-motion: no-preference}}
		@media (prefers-reduced-motion: reduce) {body {--prefers-reduced-motion: reduce}}
		@media (prefers-color-scheme: light) {body {--prefers-color-scheme: light}}
		@media (prefers-color-scheme: dark) {body {--prefers-color-scheme: dark}}
		@media (monochrome) {body {--monochrome: monochrome}}
		@media (monochrome: 0) {body {--monochrome: non-monochrome}}
		@media (inverted-colors: inverted) {body {--inverted-colors: inverted}}
		@media (inverted-colors: none) {body {--inverted-colors: none}}
		@media (forced-colors: none) {body {--forced-colors: none}}
		@media (forced-colors: active) {body {--forced-colors: active}}
		@media (any-hover: hover) {body {--any-hover: hover}}
		@media (any-hover: none) {body {--any-hover: none}}
		@media (hover: hover) {body {--hover: hover}}
		@media (hover: none) {body {--hover: none}}
		@media (any-pointer: fine) {body {--any-pointer: fine}}
		@media (any-pointer: coarse) {body {--any-pointer: coarse}}
		@media (any-pointer: none) {body {--any-pointer: none}}
		@media (pointer: fine) {body {--pointer: fine}}
		@media (pointer: coarse) {body {--pointer: coarse}}
		@media (pointer: none) {body {--pointer: none}}
		@media (device-aspect-ratio: ${deviceAspectRatio}) {body {--device-aspect-ratio: ${deviceAspectRatio}}}
		@media (device-width: ${width}px) and (device-height: ${height}px) {body {--device-screen: ${width} x ${height}}}
		@media (display-mode: fullscreen) {body {--display-mode: fullscreen}}
		@media (display-mode: standalone) {body {--display-mode: standalone}}
		@media (display-mode: minimal-ui) {body {--display-mode: minimal-ui}}
		@media (display-mode: browser) {body {--display-mode: browser}}
		@media (color-gamut: srgb) {body {--color-gamut: srgb}}
		@media (color-gamut: p3) {body {--color-gamut: p3}}
		@media (color-gamut: rec2020) {body {--color-gamut: rec2020}}
		@media (orientation: landscape) {body {--orientation: landscape}}
		@media (orientation: portrait) {body {--orientation: portrait}}
		</style>
		`;
        const style = getComputedStyle(body);
        const mediaCSS = {
            ['prefers-reduced-motion']: style.getPropertyValue('--prefers-reduced-motion').trim() || undefined,
            ['prefers-color-scheme']: style.getPropertyValue('--prefers-color-scheme').trim() || undefined,
            monochrome: style.getPropertyValue('--monochrome').trim() || undefined,
            ['inverted-colors']: style.getPropertyValue('--inverted-colors').trim() || undefined,
            ['forced-colors']: style.getPropertyValue('--forced-colors').trim() || undefined,
            ['any-hover']: style.getPropertyValue('--any-hover').trim() || undefined,
            hover: style.getPropertyValue('--hover').trim() || undefined,
            ['any-pointer']: style.getPropertyValue('--any-pointer').trim() || undefined,
            pointer: style.getPropertyValue('--pointer').trim() || undefined,
            ['device-aspect-ratio']: style.getPropertyValue('--device-aspect-ratio').trim() || undefined,
            ['device-screen']: style.getPropertyValue('--device-screen').trim() || undefined,
            ['display-mode']: style.getPropertyValue('--display-mode').trim() || undefined,
            ['color-gamut']: style.getPropertyValue('--color-gamut').trim() || undefined,
            orientation: style.getPropertyValue('--orientation').trim() || undefined,
        };
        // get screen query
        const screenQuery = getScreenMedia({ body, width, height });
        logTestResult({ time: timer.stop(), test: 'css media', passed: true });
        return { mediaCSS, matchMediaCSS, screenQuery };
    }
    catch (error) {
        logTestResult({ test: 'css media', passed: false });
        captureError(error);
        return;
    }
}

function getHTMLElementVersion() {
    try {
        const timer = createTimer();
        timer.start();
        const keys = [];
        // eslint-disable-next-line guard-for-in
        for (const key in document.documentElement) {
            keys.push(key);
        }
        logTestResult({ time: timer.stop(), test: 'html element', passed: true });
        return { keys };
    }
    catch (error) {
        logTestResult({ test: 'html element', passed: false });
        captureError(error);
        return;
    }
}

// inspired by
// https://privacycheck.sec.lrz.de/active/fp_gcr/fp_getclientrects.html
// https://privacycheck.sec.lrz.de/active/fp_e/fp_emoji.html
async function getClientRects() {
    try {
        const timer = createTimer();
        await queueEvent(timer);
        const toNativeObject = (domRect) => {
            return {
                bottom: domRect.bottom,
                height: domRect.height,
                left: domRect.left,
                right: domRect.right,
                width: domRect.width,
                top: domRect.top,
                x: domRect.x,
                y: domRect.y,
            };
        };
        let lied = (lieProps['Element.getClientRects'] ||
            lieProps['Element.getBoundingClientRect'] ||
            lieProps['Range.getClientRects'] ||
            lieProps['Range.getBoundingClientRect'] ||
            lieProps['String.fromCodePoint']) || false;
        const DOC = (PHANTOM_DARKNESS &&
            PHANTOM_DARKNESS.document &&
            PHANTOM_DARKNESS.document.body ? PHANTOM_DARKNESS.document :
            document);
        const getBestRect = (el) => {
            let range;
            if (!lieProps['Element.getClientRects']) {
                return el.getClientRects()[0];
            }
            else if (!lieProps['Element.getBoundingClientRect']) {
                return el.getBoundingClientRect();
            }
            else if (!lieProps['Range.getClientRects']) {
                range = DOC.createRange();
                range.selectNode(el);
                return range.getClientRects()[0];
            }
            range = DOC.createRange();
            range.selectNode(el);
            return range.getBoundingClientRect();
        };
        const rectsId = `${instanceId}-client-rects-div`;
        const divElement = document.createElement('div');
        divElement.setAttribute('id', rectsId);
        DOC.body.appendChild(divElement);
        patch(divElement, html `
		<div id="${rectsId}">
			<style>
			.rect-ghost,
			.rect-known {
				top: 0;
				left: 0;
				position: absolute;
				visibility: hidden;
			}
			.rect-known {
				width: 100px;
				height: 100px;
				transform: rotate(45deg);
			}
			.rect-ghost {
				width: 0;
				height: 0;
			}
			</style>
			<div class="rect-known"></div>
			<div class="rect-ghost"></div>
			<div style="perspective:100px;width:1000.099%;" id="rect-container">
				<style>
				.rects {
					width: 1000%;
					height: 1000%;
					max-width: 1000%;
				}
				.absolute {
					position: absolute;
				}
				#cRect1 {
					border: solid 2.715px;
					border-color: #F72585;
					padding: 3.98px;
					margin-left: 12.12px;
				}
				#cRect2 {
					border: solid 2px;
					border-color: #7209B7;
					font-size: 30px;
					margin-top: 20px;
					padding: 3.98px;
					transform: skewY(23.1753218deg) rotate3d(10.00099, 90, 0.100000000000009, 60000000000008.00000009deg);
				}
				#cRect3 {
					border: solid 2.89px;
					border-color: #3A0CA3;
					font-size: 45px;
					transform: skewY(-23.1753218deg) scale(1099.0000000099, 1.89) matrix(1.11, 2.0001, -1.0001, 1.009, 150, 94.4);
					margin-top: 50px;
				}
				#cRect4 {
					border: solid 2px;
					border-color: #4361EE;
					transform: matrix(1.11, 2.0001, -1.0001, 1.009, 150, 94.4);
					margin-top: 11.1331px;
					margin-left: 12.1212px;
					padding: 4.4545px;
					left: 239.4141px;
					top: 8.5050px;
				}
				#cRect5 {
					border: solid 2px;
					border-color: #4CC9F0;
					margin-left: 42.395pt;
				}
				#cRect6 {
					border: solid 2px;
					border-color: #F72585;
					transform: perspective(12890px) translateZ(101.5px);
					padding: 12px;
				}
				#cRect7 {
					margin-top: -350.552px;
					margin-left: 0.9099rem;
					border: solid 2px;
					border-color: #4361EE;
				}
				#cRect8 {
					margin-top: -150.552px;
					margin-left: 15.9099rem;
					border: solid 2px;
					border-color: #3A0CA3;
				}
				#cRect9 {
					margin-top: -110.552px;
					margin-left: 15.9099rem;
					border: solid 2px;
					border-color: #7209B7;
				}
				#cRect10 {
					margin-top: -315.552px;
					margin-left: 15.9099rem;
					border: solid 2px;
					border-color: #F72585;
				}
				#cRect11 {
					width: 10px;
					height: 10px;
					margin-left: 15.0000009099rem;
					border: solid 2px;
					border-color: #F72585;
				}
				#cRect12 {
					width: 10px;
					height: 10px;
					margin-left: 15.0000009099rem;
					border: solid 2px;
					border-color: #F72585;
				}
				#rect-container .shift-dom-rect {
					top: 1px !important;
					left: 1px !important;
				}
				</style>
				<div id="cRect1" class="rects"></div>
				<div id="cRect2" class="rects"></div>
				<div id="cRect3" class="rects"></div>
				<div id="cRect4" class="rects absolute"></div>
				<div id="cRect5" class="rects"></div>
				<div id="cRect6" class="rects"></div>
				<div id="cRect7" class="rects absolute"></div>
				<div id="cRect8" class="rects absolute"></div>
				<div id="cRect9" class="rects absolute"></div>
				<div id="cRect10" class="rects absolute"></div>
				<div id="cRect11" class="rects"></div>
				<div id="cRect12" class="rects"></div>
				<div id="emoji" class="emojis"></div>
			</div>
			<div id="emoji-container">
				<style>
				.domrect-emoji {
					font-family: ${CSS_FONT_FAMILY};
					font-size: 200px !important;
					height: auto;
					position: absolute !important;
					transform: scale(1.000999);
				}
				</style>
				${EMOJIS.map((emoji) => {
            return `<div class="domrect-emoji">${emoji}</div>`;
        }).join('')}
			</div>
		</div>
		`);
        // get emoji set and system
        const pattern = new Set();
        await queueEvent(timer);
        const emojiElems = [...DOC.getElementsByClassName('domrect-emoji')];
        const emojiSet = emojiElems.reduce((emojiSet, el, i) => {
            const emoji = EMOJIS[i];
            const { height, width } = getBestRect(el);
            const dimensions = `${width},${height}`;
            if (!pattern.has(dimensions)) {
                pattern.add(dimensions);
                emojiSet.add(emoji);
            }
            return emojiSet;
        }, new Set());
        const domrectSystemSum = 0.00001 * [...pattern].map((x) => {
            return x.split(',').reduce((acc, x) => acc += (+x || 0), 0);
        }).reduce((acc, x) => acc += x, 0);
        // get clientRects
        const range = document.createRange();
        const rectElems = DOC.getElementsByClassName('rects');
        const elementClientRects = [...rectElems].map((el) => {
            return toNativeObject(el.getClientRects()[0]);
        });
        const elementBoundingClientRect = [...rectElems].map((el) => {
            return toNativeObject(el.getBoundingClientRect());
        });
        const rangeClientRects = [...rectElems].map((el) => {
            range.selectNode(el);
            return toNativeObject(range.getClientRects()[0]);
        });
        const rangeBoundingClientRect = [...rectElems].map((el) => {
            range.selectNode(el);
            return toNativeObject(el.getBoundingClientRect());
        });
        // detect failed shift calculation
        // inspired by https://arkenfox.github.io/TZP
        const rect4 = [...rectElems][3];
        const { top: initialTop } = elementClientRects[3];
        rect4.classList.add('shift-dom-rect');
        const { top: shiftedTop } = toNativeObject(rect4.getClientRects()[0]);
        rect4.classList.remove('shift-dom-rect');
        const { top: unshiftedTop } = toNativeObject(rect4.getClientRects()[0]);
        const diff = initialTop - shiftedTop;
        const unshiftLie = diff != (unshiftedTop - shiftedTop);
        if (unshiftLie) {
            lied = true;
            documentLie('Element.getClientRects', 'failed unshift calculation');
        }
        // detect failed math calculation lie
        let mathLie = false;
        elementClientRects.forEach((rect) => {
            const { right, left, width, bottom, top, height, x, y } = rect;
            if (right - left != width ||
                bottom - top != height ||
                right - x != width ||
                bottom - y != height) {
                lied = true;
                mathLie = true;
            }
            return;
        });
        if (mathLie) {
            documentLie('Element.getClientRects', 'failed math calculation');
        }
        // detect equal elements mismatch lie
        const { right: right1, left: left1 } = elementClientRects[10];
        const { right: right2, left: left2 } = elementClientRects[11];
        if (right1 != right2 || left1 != left2) {
            documentLie('Element.getClientRects', 'equal elements mismatch');
            lied = true;
        }
        // detect unknown rotate dimensions
        const knownEl = [...DOC.getElementsByClassName('rect-known')][0];
        const knownDimensions = toNativeObject(knownEl.getClientRects()[0]);
        const knownHash = hashMini(knownDimensions);
        if (IS_BLINK) {
            const Rotate = {
                '9d9215cc': true,
                '47ded322': true,
                'd0eceaa8': true, // 90
            };
            if (!Rotate[knownHash]) {
                documentLie('Element.getClientRects', 'unknown rotate dimensions');
                lied = true;
            }
        }
        else if (IS_GECKO) {
            const Rotate = {
                'e38453f0': true, // 100, etc
            };
            if (!Rotate[knownHash]) {
                documentLie('Element.getClientRects', 'unknown rotate dimensions');
                lied = true;
            }
        }
        // detect ghost dimensions
        const ghostEl = [...DOC.getElementsByClassName('rect-ghost')][0];
        const ghostDimensions = toNativeObject(ghostEl.getClientRects()[0]);
        const hasGhostDimensions = Object.keys(ghostDimensions)
            .some((key) => ghostDimensions[key] !== 0);
        if (hasGhostDimensions) {
            documentLie('Element.getClientRects', 'unknown ghost dimensions');
            lied = true;
        }
        DOC.body.removeChild(DOC.getElementById(rectsId));
        logTestResult({ time: timer.stop(), test: 'rects', passed: true });
        return {
            elementClientRects,
            elementBoundingClientRect,
            rangeClientRects,
            rangeBoundingClientRect,
            emojiSet: [...emojiSet],
            domrectSystemSum,
            lied,
        };
    }
    catch (error) {
        logTestResult({ test: 'rects', passed: false });
        captureError(error);
        return;
    }
}

function getErrors(errFns) {
    const errors = [];
    let i;
    const len = errFns.length;
    for (i = 0; i < len; i++) {
        try {
            errFns[i]();
        }
        catch (err) {
            errors.push(err.message);
        }
    }
    return errors;
}
function getConsoleErrors() {
    try {
        const timer = createTimer();
        timer.start();
        const errorTests = [
            () => new Function('alert(")')(),
            () => new Function('const foo;foo.bar')(),
            () => new Function('null.bar')(),
            () => new Function('abc.xyz = 123')(),
            () => new Function('const foo;foo.bar')(),
            () => new Function('(1).toString(1000)')(),
            () => new Function('[...undefined].length')(),
            () => new Function('var x = new Array(-1)')(),
            () => new Function('const a=1; const a=2;')(),
        ];
        const errors = getErrors(errorTests);
        logTestResult({ time: timer.stop(), test: 'console errors', passed: true });
        return { errors };
    }
    catch (error) {
        logTestResult({ test: 'console errors', passed: false });
        captureError(error);
        return;
    }
}

/*
Steps to update:
0. get beta release desktop/mobile
1. get diffs from template
2. update feature list
3. update stable features object
*/
const getStableFeatures = () => ({
    'Chrome': {
        version: 109,
        windowKeys: `Object, Function, Array, Number, parseFloat, parseInt, Infinity, NaN, undefined, Boolean, String, Symbol, Date, Promise, RegExp, Error, AggregateError, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, globalThis, JSON, Math, Intl, ArrayBuffer, Uint8Array, Int8Array, Uint16Array, Int16Array, Uint32Array, Int32Array, Float32Array, Float64Array, Uint8ClampedArray, BigUint64Array, BigInt64Array, DataView, Map, BigInt, Set, WeakMap, WeakSet, Proxy, Reflect, FinalizationRegistry, WeakRef, decodeURI, decodeURIComponent, encodeURI, encodeURIComponent, escape, unescape, eval, isFinite, isNaN, console, Option, Image, Audio, webkitURL, webkitRTCPeerConnection, webkitMediaStream, WebKitMutationObserver, WebKitCSSMatrix, XSLTProcessor, XPathResult, XPathExpression, XPathEvaluator, XMLSerializer, XMLHttpRequestUpload, XMLHttpRequestEventTarget, XMLHttpRequest, XMLDocument, WritableStreamDefaultWriter, WritableStreamDefaultController, WritableStream, Worker, Window, WheelEvent, WebSocket, WebGLVertexArrayObject, WebGLUniformLocation, WebGLTransformFeedback, WebGLTexture, WebGLSync, WebGLShaderPrecisionFormat, WebGLShader, WebGLSampler, WebGLRenderingContext, WebGLRenderbuffer, WebGLQuery, WebGLProgram, WebGLFramebuffer, WebGLContextEvent, WebGLBuffer, WebGLActiveInfo, WebGL2RenderingContext, WaveShaperNode, VisualViewport, VirtualKeyboardGeometryChangeEvent, ValidityState, VTTCue, UserActivation, URLSearchParams, URLPattern, URL, UIEvent, TrustedTypePolicyFactory, TrustedTypePolicy, TrustedScriptURL, TrustedScript, TrustedHTML, TreeWalker, TransitionEvent, TransformStreamDefaultController, TransformStream, TrackEvent, TouchList, TouchEvent, Touch, TimeRanges, TextTrackList, TextTrackCueList, TextTrackCue, TextTrack, TextMetrics, TextEvent, TextEncoderStream, TextEncoder, TextDecoderStream, TextDecoder, Text, TaskSignal, TaskPriorityChangeEvent, TaskController, TaskAttributionTiming, SyncManager, SubmitEvent, StyleSheetList, StyleSheet, StylePropertyMapReadOnly, StylePropertyMap, StorageEvent, Storage, StereoPannerNode, StaticRange, ShadowRoot, Selection, SecurityPolicyViolationEvent, ScriptProcessorNode, ScreenOrientation, Screen, Scheduling, Scheduler, SVGViewElement, SVGUseElement, SVGUnitTypes, SVGTransformList, SVGTransform, SVGTitleElement, SVGTextPositioningElement, SVGTextPathElement, SVGTextElement, SVGTextContentElement, SVGTSpanElement, SVGSymbolElement, SVGSwitchElement, SVGStyleElement, SVGStringList, SVGStopElement, SVGSetElement, SVGScriptElement, SVGSVGElement, SVGRectElement, SVGRect, SVGRadialGradientElement, SVGPreserveAspectRatio, SVGPolylineElement, SVGPolygonElement, SVGPointList, SVGPoint, SVGPatternElement, SVGPathElement, SVGNumberList, SVGNumber, SVGMetadataElement, SVGMatrix, SVGMaskElement, SVGMarkerElement, SVGMPathElement, SVGLinearGradientElement, SVGLineElement, SVGLengthList, SVGLength, SVGImageElement, SVGGraphicsElement, SVGGradientElement, SVGGeometryElement, SVGGElement, SVGForeignObjectElement, SVGFilterElement, SVGFETurbulenceElement, SVGFETileElement, SVGFESpotLightElement, SVGFESpecularLightingElement, SVGFEPointLightElement, SVGFEOffsetElement, SVGFEMorphologyElement, SVGFEMergeNodeElement, SVGFEMergeElement, SVGFEImageElement, SVGFEGaussianBlurElement, SVGFEFuncRElement, SVGFEFuncGElement, SVGFEFuncBElement, SVGFEFuncAElement, SVGFEFloodElement, SVGFEDropShadowElement, SVGFEDistantLightElement, SVGFEDisplacementMapElement, SVGFEDiffuseLightingElement, SVGFEConvolveMatrixElement, SVGFECompositeElement, SVGFEComponentTransferElement, SVGFEColorMatrixElement, SVGFEBlendElement, SVGEllipseElement, SVGElement, SVGDescElement, SVGDefsElement, SVGComponentTransferFunctionElement, SVGClipPathElement, SVGCircleElement, SVGAnimationElement, SVGAnimatedTransformList, SVGAnimatedString, SVGAnimatedRect, SVGAnimatedPreserveAspectRatio, SVGAnimatedNumberList, SVGAnimatedNumber, SVGAnimatedLengthList, SVGAnimatedLength, SVGAnimatedInteger, SVGAnimatedEnumeration, SVGAnimatedBoolean, SVGAnimatedAngle, SVGAnimateTransformElement, SVGAnimateMotionElement, SVGAnimateElement, SVGAngle, SVGAElement, Response, ResizeObserverSize, ResizeObserverEntry, ResizeObserver, Request, ReportingObserver, ReadableStreamDefaultReader, ReadableStreamDefaultController, ReadableStreamBYOBRequest, ReadableStreamBYOBReader, ReadableStream, ReadableByteStreamController, Range, RadioNodeList, RTCTrackEvent, RTCStatsReport, RTCSessionDescription, RTCSctpTransport, RTCRtpTransceiver, RTCRtpSender, RTCRtpReceiver, RTCPeerConnectionIceEvent, RTCPeerConnectionIceErrorEvent, RTCPeerConnection, RTCIceTransport, RTCIceCandidate, RTCErrorEvent, RTCError, RTCEncodedVideoFrame, RTCEncodedAudioFrame, RTCDtlsTransport, RTCDataChannelEvent, RTCDataChannel, RTCDTMFToneChangeEvent, RTCDTMFSender, RTCCertificate, PromiseRejectionEvent, ProgressEvent, Profiler, ProcessingInstruction, PopStateEvent, PointerEvent, PluginArray, Plugin, PeriodicWave, PerformanceTiming, PerformanceServerTiming, PerformanceResourceTiming, PerformancePaintTiming, PerformanceObserverEntryList, PerformanceObserver, PerformanceNavigationTiming, PerformanceNavigation, PerformanceMeasure, PerformanceMark, PerformanceLongTaskTiming, PerformanceEventTiming, PerformanceEntry, PerformanceElementTiming, Performance, Path2D, PannerNode, PageTransitionEvent, OverconstrainedError, OscillatorNode, OffscreenCanvasRenderingContext2D, OffscreenCanvas, OfflineAudioContext, OfflineAudioCompletionEvent, NodeList, NodeIterator, NodeFilter, Node, NetworkInformation, Navigator, NamedNodeMap, MutationRecord, MutationObserver, MutationEvent, MouseEvent, MimeTypeArray, MimeType, MessagePort, MessageEvent, MessageChannel, MediaStreamTrackProcessor, MediaStreamTrackEvent, MediaStreamEvent, MediaStreamAudioSourceNode, MediaStreamAudioDestinationNode, MediaStream, MediaRecorder, MediaQueryListEvent, MediaQueryList, MediaList, MediaError, MediaEncryptedEvent, MediaElementAudioSourceNode, MediaCapabilities, Location, LayoutShiftAttribution, LayoutShift, LargestContentfulPaint, KeyframeEffect, KeyboardEvent, IntersectionObserverEntry, IntersectionObserver, InputEvent, InputDeviceInfo, InputDeviceCapabilities, ImageData, ImageCapture, ImageBitmapRenderingContext, ImageBitmap, IdleDeadline, IIRFilterNode, IDBVersionChangeEvent, IDBTransaction, IDBRequest, IDBOpenDBRequest, IDBObjectStore, IDBKeyRange, IDBIndex, IDBFactory, IDBDatabase, IDBCursorWithValue, IDBCursor, History, Headers, HashChangeEvent, HTMLVideoElement, HTMLUnknownElement, HTMLUListElement, HTMLTrackElement, HTMLTitleElement, HTMLTimeElement, HTMLTextAreaElement, HTMLTemplateElement, HTMLTableSectionElement, HTMLTableRowElement, HTMLTableElement, HTMLTableColElement, HTMLTableCellElement, HTMLTableCaptionElement, HTMLStyleElement, HTMLSpanElement, HTMLSourceElement, HTMLSlotElement, HTMLSelectElement, HTMLScriptElement, HTMLQuoteElement, HTMLProgressElement, HTMLPreElement, HTMLPictureElement, HTMLParamElement, HTMLParagraphElement, HTMLOutputElement, HTMLOptionsCollection, HTMLOptionElement, HTMLOptGroupElement, HTMLObjectElement, HTMLOListElement, HTMLModElement, HTMLMeterElement, HTMLMetaElement, HTMLMenuElement, HTMLMediaElement, HTMLMarqueeElement, HTMLMapElement, HTMLLinkElement, HTMLLegendElement, HTMLLabelElement, HTMLLIElement, HTMLInputElement, HTMLImageElement, HTMLIFrameElement, HTMLHtmlElement, HTMLHeadingElement, HTMLHeadElement, HTMLHRElement, HTMLFrameSetElement, HTMLFrameElement, HTMLFormElement, HTMLFormControlsCollection, HTMLFontElement, HTMLFieldSetElement, HTMLEmbedElement, HTMLElement, HTMLDocument, HTMLDivElement, HTMLDirectoryElement, HTMLDialogElement, HTMLDetailsElement, HTMLDataListElement, HTMLDataElement, HTMLDListElement, HTMLCollection, HTMLCanvasElement, HTMLButtonElement, HTMLBodyElement, HTMLBaseElement, HTMLBRElement, HTMLAudioElement, HTMLAreaElement, HTMLAnchorElement, HTMLAllCollection, GeolocationPositionError, GeolocationPosition, GeolocationCoordinates, Geolocation, GamepadHapticActuator, GamepadEvent, GamepadButton, Gamepad, GainNode, FormDataEvent, FormData, FontFaceSetLoadEvent, FontFace, FocusEvent, FileReader, FileList, File, FeaturePolicy, External, EventTarget, EventSource, EventCounts, Event, ErrorEvent, ElementInternals, Element, DynamicsCompressorNode, DragEvent, DocumentType, DocumentFragment, Document, DelayNode, DecompressionStream, DataTransferItemList, DataTransferItem, DataTransfer, DOMTokenList, DOMStringMap, DOMStringList, DOMRectReadOnly, DOMRectList, DOMRect, DOMQuad, DOMPointReadOnly, DOMPoint, DOMParser, DOMMatrixReadOnly, DOMMatrix, DOMImplementation, DOMException, DOMError, CustomStateSet, CustomEvent, CustomElementRegistry, Crypto, CountQueuingStrategy, ConvolverNode, ConstantSourceNode, CompressionStream, CompositionEvent, Comment, CloseEvent, ClipboardEvent, CharacterData, ChannelSplitterNode, ChannelMergerNode, CanvasRenderingContext2D, CanvasPattern, CanvasGradient, CanvasFilter, CanvasCaptureMediaStreamTrack, CSSVariableReferenceValue, CSSUnparsedValue, CSSUnitValue, CSSTranslate, CSSTransformValue, CSSTransformComponent, CSSSupportsRule, CSSStyleValue, CSSStyleSheet, CSSStyleRule, CSSStyleDeclaration, CSSSkewY, CSSSkewX, CSSSkew, CSSScale, CSSRuleList, CSSRule, CSSRotate, CSSPropertyRule, CSSPositionValue, CSSPerspective, CSSPageRule, CSSNumericValue, CSSNumericArray, CSSNamespaceRule, CSSMediaRule, CSSMatrixComponent, CSSMathValue, CSSMathSum, CSSMathProduct, CSSMathNegate, CSSMathMin, CSSMathMax, CSSMathInvert, CSSMathClamp, CSSLayerStatementRule, CSSLayerBlockRule, CSSKeywordValue, CSSKeyframesRule, CSSKeyframeRule, CSSImportRule, CSSImageValue, CSSGroupingRule, CSSFontFaceRule, CSSCounterStyleRule, CSSConditionRule, CSS, CDATASection, ByteLengthQueuingStrategy, BroadcastChannel, BlobEvent, Blob, BiquadFilterNode, BeforeUnloadEvent, BeforeInstallPromptEvent, BaseAudioContext, BarProp, AudioWorkletNode, AudioScheduledSourceNode, AudioProcessingEvent, AudioParamMap, AudioParam, AudioNode, AudioListener, AudioDestinationNode, AudioContext, AudioBufferSourceNode, AudioBuffer, Attr, AnimationEvent, AnimationEffect, Animation, AnalyserNode, AbstractRange, AbortSignal, AbortController, window, self, document, name, location, customElements, history, locationbar, menubar, personalbar, scrollbars, statusbar, toolbar, status, closed, frames, length, top, opener, parent, frameElement, navigator, origin, external, screen, innerWidth, innerHeight, scrollX, pageXOffset, scrollY, pageYOffset, visualViewport, screenX, screenY, outerWidth, outerHeight, devicePixelRatio, event, clientInformation, offscreenBuffering, screenLeft, screenTop, styleMedia, onsearch, isSecureContext, trustedTypes, performance, onappinstalled, onbeforeinstallprompt, crypto, indexedDB, sessionStorage, localStorage, onbeforexrselect, onabort, onbeforeinput, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextlost, oncontextmenu, oncontextrestored, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, onformdata, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onsecuritypolicyviolation, onseeked, onseeking, onselect, onslotchange, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting, onwebkitanimationend, onwebkitanimationiteration, onwebkitanimationstart, onwebkittransitionend, onwheel, onauxclick, ongotpointercapture, onlostpointercapture, onpointerdown, onpointermove, onpointerrawupdate, onpointerup, onpointercancel, onpointerover, onpointerout, onpointerenter, onpointerleave, onselectstart, onselectionchange, onanimationend, onanimationiteration, onanimationstart, ontransitionrun, ontransitionstart, ontransitionend, ontransitioncancel, onafterprint, onbeforeprint, onbeforeunload, onhashchange, onlanguagechange, onmessage, onmessageerror, onoffline, ononline, onpagehide, onpageshow, onpopstate, onrejectionhandled, onstorage, onunhandledrejection, onunload, crossOriginIsolated, scheduler, alert, atob, blur, btoa, cancelAnimationFrame, cancelIdleCallback, captureEvents, clearInterval, clearTimeout, close, confirm, createImageBitmap, fetch, find, focus, getComputedStyle, getSelection, matchMedia, moveBy, moveTo, open, postMessage, print, prompt, queueMicrotask, releaseEvents, reportError, requestAnimationFrame, requestIdleCallback, resizeBy, resizeTo, scroll, scrollBy, scrollTo, setInterval, setTimeout, stop, structuredClone, webkitCancelAnimationFrame, webkitRequestAnimationFrame, Atomics, chrome, WebAssembly, caches, cookieStore, ondevicemotion, ondeviceorientation, ondeviceorientationabsolute, launchQueue, onbeforematch, AbsoluteOrientationSensor, Accelerometer, AudioWorklet, BatteryManager, Cache, CacheStorage, Clipboard, ClipboardItem, CookieChangeEvent, CookieStore, CookieStoreManager, Credential, CredentialsContainer, CryptoKey, DeviceMotionEvent, DeviceMotionEventAcceleration, DeviceMotionEventRotationRate, DeviceOrientationEvent, FederatedCredential, GravitySensor, Gyroscope, Keyboard, KeyboardLayoutMap, LinearAccelerationSensor, Lock, LockManager, MIDIAccess, MIDIConnectionEvent, MIDIInput, MIDIInputMap, MIDIMessageEvent, MIDIOutput, MIDIOutputMap, MIDIPort, MediaDeviceInfo, MediaDevices, MediaKeyMessageEvent, MediaKeySession, MediaKeyStatusMap, MediaKeySystemAccess, MediaKeys, NavigationPreloadManager, NavigatorManagedData, OrientationSensor, PasswordCredential, RelativeOrientationSensor, ScreenDetailed, ScreenDetails, Sensor, SensorErrorEvent, ServiceWorker, ServiceWorkerContainer, ServiceWorkerRegistration, StorageManager, SubtleCrypto, VirtualKeyboard, WebTransport, WebTransportBidirectionalStream, WebTransportDatagramDuplexStream, WebTransportError, Worklet, XRDOMOverlayState, XRLayer, XRWebGLBinding, AudioData, EncodedAudioChunk, EncodedVideoChunk, ImageTrack, ImageTrackList, VideoColorSpace, VideoFrame, AudioDecoder, AudioEncoder, ImageDecoder, VideoDecoder, VideoEncoder, AuthenticatorAssertionResponse, AuthenticatorAttestationResponse, AuthenticatorResponse, PublicKeyCredential, Bluetooth, BluetoothCharacteristicProperties, BluetoothDevice, BluetoothRemoteGATTCharacteristic, BluetoothRemoteGATTDescriptor, BluetoothRemoteGATTServer, BluetoothRemoteGATTService, CaptureController, EyeDropper, FileSystemDirectoryHandle, FileSystemFileHandle, FileSystemHandle, FileSystemWritableFileStream, FontData, FragmentDirective, HID, HIDConnectionEvent, HIDDevice, HIDInputReportEvent, IdentityCredential, IdleDetector, LaunchParams, LaunchQueue, OTPCredential, PaymentAddress, PaymentRequest, PaymentResponse, PaymentMethodChangeEvent, Presentation, PresentationAvailability, PresentationConnection, PresentationConnectionAvailableEvent, PresentationConnectionCloseEvent, PresentationConnectionList, PresentationReceiver, PresentationRequest, Sanitizer, Serial, SerialPort, USB, USBAlternateInterface, USBConfiguration, USBConnectionEvent, USBDevice, USBEndpoint, USBInTransferResult, USBInterface, USBIsochronousInTransferPacket, USBIsochronousInTransferResult, USBIsochronousOutTransferPacket, USBIsochronousOutTransferResult, USBOutTransferResult, WakeLock, WakeLockSentinel, WindowControlsOverlay, WindowControlsOverlayGeometryChangeEvent, XRAnchor, XRAnchorSet, XRBoundedReferenceSpace, XRFrame, XRInputSource, XRInputSourceArray, XRInputSourceEvent, XRInputSourcesChangeEvent, XRPose, XRReferenceSpace, XRReferenceSpaceEvent, XRRenderState, XRRigidTransform, XRSession, XRSessionEvent, XRSpace, XRSystem, XRView, XRViewerPose, XRViewport, XRWebGLLayer, XRCPUDepthInformation, XRDepthInformation, XRWebGLDepthInformation, XRCamera, XRHitTestResult, XRHitTestSource, XRRay, XRTransientInputHitTestResult, XRTransientInputHitTestSource, XRLightEstimate, XRLightProbe, getScreenDetails, queryLocalFonts, showDirectoryPicker, showOpenFilePicker, showSaveFilePicker, originAgentCluster, navigation, webkitStorageInfo, speechSynthesis, oncontentvisibilityautostatechange, AnimationPlaybackEvent, AnimationTimeline, CSSAnimation, CSSTransition, DocumentTimeline, BackgroundFetchManager, BackgroundFetchRecord, BackgroundFetchRegistration, BluetoothUUID, BrowserCaptureMediaStreamTrack, CropTarget, CSSContainerRule, CSSFontPaletteValuesRule, ContentVisibilityAutoStateChangeEvent, DelegatedInkTrailPresenter, Ink, Highlight, HighlightRegistry, MathMLElement, MediaMetadata, MediaSession, MediaSource, SourceBuffer, SourceBufferList, MediaSourceHandle, MediaStreamTrack, MediaStreamTrackGenerator, NavigateEvent, Navigation, NavigationCurrentEntryChangeEvent, NavigationDestination, NavigationHistoryEntry, NavigationTransition, NavigatorUAData, Notification, PaymentInstruments, PaymentManager, PaymentRequestUpdateEvent, PeriodicSyncManager, PermissionStatus, Permissions, PictureInPictureEvent, PictureInPictureWindow, PushManager, PushSubscription, PushSubscriptionOptions, RemotePlayback, SharedWorker, SpeechSynthesisErrorEvent, SpeechSynthesisEvent, SpeechSynthesisUtterance, VideoPlaybackQuality, webkitSpeechGrammar, webkitSpeechGrammarList, webkitSpeechRecognition, webkitSpeechRecognitionError, webkitSpeechRecognitionEvent, openDatabase, webkitRequestFileSystem, webkitResolveLocalFileSystemURL`,
        cssKeys: `cssText, length, parentRule, cssFloat, getPropertyPriority, getPropertyValue, item, removeProperty, setProperty, constructor, accent-color, align-content, align-items, align-self, alignment-baseline, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, app-region, appearance, backdrop-filter, backface-visibility, background-attachment, background-blend-mode, background-clip, background-color, background-image, background-origin, background-position, background-repeat, background-size, baseline-shift, block-size, border-block-end-color, border-block-end-style, border-block-end-width, border-block-start-color, border-block-start-style, border-block-start-width, border-bottom-color, border-bottom-left-radius, border-bottom-right-radius, border-bottom-style, border-bottom-width, border-collapse, border-end-end-radius, border-end-start-radius, border-image-outset, border-image-repeat, border-image-slice, border-image-source, border-image-width, border-inline-end-color, border-inline-end-style, border-inline-end-width, border-inline-start-color, border-inline-start-style, border-inline-start-width, border-left-color, border-left-style, border-left-width, border-right-color, border-right-style, border-right-width, border-start-end-radius, border-start-start-radius, border-top-color, border-top-left-radius, border-top-right-radius, border-top-style, border-top-width, bottom, box-shadow, box-sizing, break-after, break-before, break-inside, buffered-rendering, caption-side, caret-color, clear, clip, clip-path, clip-rule, color, color-interpolation, color-interpolation-filters, color-rendering, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, contain-intrinsic-block-size, contain-intrinsic-height, contain-intrinsic-inline-size, contain-intrinsic-size, contain-intrinsic-width, container-name, container-type, content, cursor, cx, cy, d, direction, display, dominant-baseline, empty-cells, fill, fill-opacity, fill-rule, filter, flex-basis, flex-direction, flex-grow, flex-shrink, flex-wrap, float, flood-color, flood-opacity, font-family, font-kerning, font-optical-sizing, font-palette, font-size, font-stretch, font-style, font-synthesis-small-caps, font-synthesis-style, font-synthesis-weight, font-variant, font-variant-caps, font-variant-east-asian, font-variant-ligatures, font-variant-numeric, font-weight, grid-auto-columns, grid-auto-flow, grid-auto-rows, grid-column-end, grid-column-start, grid-row-end, grid-row-start, grid-template-areas, grid-template-columns, grid-template-rows, height, hyphenate-character, hyphenate-limit-chars, hyphens, image-orientation, image-rendering, inline-size, inset-block-end, inset-block-start, inset-inline-end, inset-inline-start, isolation, justify-content, justify-items, justify-self, left, letter-spacing, lighting-color, line-break, line-height, list-style-image, list-style-position, list-style-type, margin-block-end, margin-block-start, margin-bottom, margin-inline-end, margin-inline-start, margin-left, margin-right, margin-top, marker-end, marker-mid, marker-start, mask-type, math-depth, math-shift, math-style, max-block-size, max-height, max-inline-size, max-width, min-block-size, min-height, min-inline-size, min-width, mix-blend-mode, object-fit, object-position, object-view-box, offset-distance, offset-path, offset-rotate, opacity, order, orphans, outline-color, outline-offset, outline-style, outline-width, overflow-anchor, overflow-clip-margin, overflow-wrap, overflow-x, overflow-y, overscroll-behavior-block, overscroll-behavior-inline, padding-block-end, padding-block-start, padding-bottom, padding-inline-end, padding-inline-start, padding-left, padding-right, padding-top, paint-order, perspective, perspective-origin, pointer-events, position, r, resize, right, rotate, row-gap, ruby-position, rx, ry, scale, scroll-behavior, scroll-margin-block-end, scroll-margin-block-start, scroll-margin-inline-end, scroll-margin-inline-start, scroll-padding-block-end, scroll-padding-block-start, scroll-padding-inline-end, scroll-padding-inline-start, scrollbar-gutter, shape-image-threshold, shape-margin, shape-outside, shape-rendering, speak, stop-color, stop-opacity, stroke, stroke-dasharray, stroke-dashoffset, stroke-linecap, stroke-linejoin, stroke-miterlimit, stroke-opacity, stroke-width, tab-size, table-layout, text-align, text-align-last, text-anchor, text-decoration, text-decoration-color, text-decoration-line, text-decoration-skip-ink, text-decoration-style, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-indent, text-overflow, text-rendering, text-shadow, text-size-adjust, text-transform, text-underline-position, top, touch-action, transform, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, translate, unicode-bidi, user-select, vector-effect, vertical-align, visibility, white-space, widows, width, will-change, word-break, word-spacing, writing-mode, x, y, z-index, zoom, -webkit-border-horizontal-spacing, -webkit-border-image, -webkit-border-vertical-spacing, -webkit-box-align, -webkit-box-decoration-break, -webkit-box-direction, -webkit-box-flex, -webkit-box-ordinal-group, -webkit-box-orient, -webkit-box-pack, -webkit-box-reflect, -webkit-font-smoothing, -webkit-highlight, -webkit-line-break, -webkit-line-clamp, -webkit-locale, -webkit-mask-box-image, -webkit-mask-box-image-outset, -webkit-mask-box-image-repeat, -webkit-mask-box-image-slice, -webkit-mask-box-image-source, -webkit-mask-box-image-width, -webkit-mask-clip, -webkit-mask-composite, -webkit-mask-image, -webkit-mask-origin, -webkit-mask-position, -webkit-mask-repeat, -webkit-mask-size, -webkit-print-color-adjust, -webkit-rtl-ordering, -webkit-tap-highlight-color, -webkit-text-combine, -webkit-text-decorations-in-effect, -webkit-text-fill-color, -webkit-text-orientation, -webkit-text-security, -webkit-text-stroke-color, -webkit-text-stroke-width, -webkit-user-drag, -webkit-user-modify, -webkit-writing-mode, accentColor, additiveSymbols, alignContent, alignItems, alignSelf, alignmentBaseline, all, animation, animationDelay, animationDirection, animationDuration, animationFillMode, animationIterationCount, animationName, animationPlayState, animationTimingFunction, appRegion, ascentOverride, aspectRatio, backdropFilter, backfaceVisibility, background, backgroundAttachment, backgroundBlendMode, backgroundClip, backgroundColor, backgroundImage, backgroundOrigin, backgroundPosition, backgroundPositionX, backgroundPositionY, backgroundRepeat, backgroundRepeatX, backgroundRepeatY, backgroundSize, basePalette, baselineShift, blockSize, border, borderBlock, borderBlockColor, borderBlockEnd, borderBlockEndColor, borderBlockEndStyle, borderBlockEndWidth, borderBlockStart, borderBlockStartColor, borderBlockStartStyle, borderBlockStartWidth, borderBlockStyle, borderBlockWidth, borderBottom, borderBottomColor, borderBottomLeftRadius, borderBottomRightRadius, borderBottomStyle, borderBottomWidth, borderCollapse, borderColor, borderEndEndRadius, borderEndStartRadius, borderImage, borderImageOutset, borderImageRepeat, borderImageSlice, borderImageSource, borderImageWidth, borderInline, borderInlineColor, borderInlineEnd, borderInlineEndColor, borderInlineEndStyle, borderInlineEndWidth, borderInlineStart, borderInlineStartColor, borderInlineStartStyle, borderInlineStartWidth, borderInlineStyle, borderInlineWidth, borderLeft, borderLeftColor, borderLeftStyle, borderLeftWidth, borderRadius, borderRight, borderRightColor, borderRightStyle, borderRightWidth, borderSpacing, borderStartEndRadius, borderStartStartRadius, borderStyle, borderTop, borderTopColor, borderTopLeftRadius, borderTopRightRadius, borderTopStyle, borderTopWidth, borderWidth, boxShadow, boxSizing, breakAfter, breakBefore, breakInside, bufferedRendering, captionSide, caretColor, clipPath, clipRule, colorInterpolation, colorInterpolationFilters, colorRendering, colorScheme, columnCount, columnFill, columnGap, columnRule, columnRuleColor, columnRuleStyle, columnRuleWidth, columnSpan, columnWidth, columns, contain, containIntrinsicBlockSize, containIntrinsicHeight, containIntrinsicInlineSize, containIntrinsicSize, containIntrinsicWidth, container, containerName, containerType, contentVisibility, counterIncrement, counterReset, counterSet, descentOverride, dominantBaseline, emptyCells, fallback, fillOpacity, fillRule, flex, flexBasis, flexDirection, flexFlow, flexGrow, flexShrink, flexWrap, floodColor, floodOpacity, font, fontDisplay, fontFamily, fontFeatureSettings, fontKerning, fontOpticalSizing, fontPalette, fontSize, fontStretch, fontStyle, fontSynthesis, fontSynthesisSmallCaps, fontSynthesisStyle, fontSynthesisWeight, fontVariant, fontVariantCaps, fontVariantEastAsian, fontVariantLigatures, fontVariantNumeric, fontVariationSettings, fontWeight, forcedColorAdjust, gap, grid, gridArea, gridAutoColumns, gridAutoFlow, gridAutoRows, gridColumn, gridColumnEnd, gridColumnGap, gridColumnStart, gridGap, gridRow, gridRowEnd, gridRowGap, gridRowStart, gridTemplate, gridTemplateAreas, gridTemplateColumns, gridTemplateRows, hyphenateCharacter, hyphenateLimitChars, imageOrientation, imageRendering, inherits, initialValue, inlineSize, inset, insetBlock, insetBlockEnd, insetBlockStart, insetInline, insetInlineEnd, insetInlineStart, justifyContent, justifyItems, justifySelf, letterSpacing, lightingColor, lineBreak, lineGapOverride, lineHeight, listStyle, listStyleImage, listStylePosition, listStyleType, margin, marginBlock, marginBlockEnd, marginBlockStart, marginBottom, marginInline, marginInlineEnd, marginInlineStart, marginLeft, marginRight, marginTop, marker, markerEnd, markerMid, markerStart, mask, maskType, mathDepth, mathShift, mathStyle, maxBlockSize, maxHeight, maxInlineSize, maxWidth, minBlockSize, minHeight, minInlineSize, minWidth, mixBlendMode, negative, objectFit, objectPosition, objectViewBox, offset, offsetDistance, offsetPath, offsetRotate, outline, outlineColor, outlineOffset, outlineStyle, outlineWidth, overflow, overflowAnchor, overflowClipMargin, overflowWrap, overflowX, overflowY, overrideColors, overscrollBehavior, overscrollBehaviorBlock, overscrollBehaviorInline, overscrollBehaviorX, overscrollBehaviorY, pad, padding, paddingBlock, paddingBlockEnd, paddingBlockStart, paddingBottom, paddingInline, paddingInlineEnd, paddingInlineStart, paddingLeft, paddingRight, paddingTop, page, pageBreakAfter, pageBreakBefore, pageBreakInside, pageOrientation, paintOrder, perspectiveOrigin, placeContent, placeItems, placeSelf, pointerEvents, prefix, quotes, range, rowGap, rubyPosition, scrollBehavior, scrollMargin, scrollMarginBlock, scrollMarginBlockEnd, scrollMarginBlockStart, scrollMarginBottom, scrollMarginInline, scrollMarginInlineEnd, scrollMarginInlineStart, scrollMarginLeft, scrollMarginRight, scrollMarginTop, scrollPadding, scrollPaddingBlock, scrollPaddingBlockEnd, scrollPaddingBlockStart, scrollPaddingBottom, scrollPaddingInline, scrollPaddingInlineEnd, scrollPaddingInlineStart, scrollPaddingLeft, scrollPaddingRight, scrollPaddingTop, scrollSnapAlign, scrollSnapStop, scrollSnapType, scrollbarGutter, shapeImageThreshold, shapeMargin, shapeOutside, shapeRendering, size, sizeAdjust, speakAs, src, stopColor, stopOpacity, strokeDasharray, strokeDashoffset, strokeLinecap, strokeLinejoin, strokeMiterlimit, strokeOpacity, strokeWidth, suffix, symbols, syntax, system, tabSize, tableLayout, textAlign, textAlignLast, textAnchor, textCombineUpright, textDecoration, textDecorationColor, textDecorationLine, textDecorationSkipInk, textDecorationStyle, textDecorationThickness, textEmphasis, textEmphasisColor, textEmphasisPosition, textEmphasisStyle, textIndent, textOrientation, textOverflow, textRendering, textShadow, textSizeAdjust, textTransform, textUnderlineOffset, textUnderlinePosition, touchAction, transformBox, transformOrigin, transformStyle, transition, transitionDelay, transitionDuration, transitionProperty, transitionTimingFunction, unicodeBidi, unicodeRange, userSelect, vectorEffect, verticalAlign, webkitAlignContent, webkitAlignItems, webkitAlignSelf, webkitAnimation, webkitAnimationDelay, webkitAnimationDirection, webkitAnimationDuration, webkitAnimationFillMode, webkitAnimationIterationCount, webkitAnimationName, webkitAnimationPlayState, webkitAnimationTimingFunction, webkitAppRegion, webkitAppearance, webkitBackfaceVisibility, webkitBackgroundClip, webkitBackgroundOrigin, webkitBackgroundSize, webkitBorderAfter, webkitBorderAfterColor, webkitBorderAfterStyle, webkitBorderAfterWidth, webkitBorderBefore, webkitBorderBeforeColor, webkitBorderBeforeStyle, webkitBorderBeforeWidth, webkitBorderBottomLeftRadius, webkitBorderBottomRightRadius, webkitBorderEnd, webkitBorderEndColor, webkitBorderEndStyle, webkitBorderEndWidth, webkitBorderHorizontalSpacing, webkitBorderImage, webkitBorderRadius, webkitBorderStart, webkitBorderStartColor, webkitBorderStartStyle, webkitBorderStartWidth, webkitBorderTopLeftRadius, webkitBorderTopRightRadius, webkitBorderVerticalSpacing, webkitBoxAlign, webkitBoxDecorationBreak, webkitBoxDirection, webkitBoxFlex, webkitBoxOrdinalGroup, webkitBoxOrient, webkitBoxPack, webkitBoxReflect, webkitBoxShadow, webkitBoxSizing, webkitClipPath, webkitColumnBreakAfter, webkitColumnBreakBefore, webkitColumnBreakInside, webkitColumnCount, webkitColumnGap, webkitColumnRule, webkitColumnRuleColor, webkitColumnRuleStyle, webkitColumnRuleWidth, webkitColumnSpan, webkitColumnWidth, webkitColumns, webkitFilter, webkitFlex, webkitFlexBasis, webkitFlexDirection, webkitFlexFlow, webkitFlexGrow, webkitFlexShrink, webkitFlexWrap, webkitFontFeatureSettings, webkitFontSmoothing, webkitHighlight, webkitHyphenateCharacter, webkitJustifyContent, webkitLineBreak, webkitLineClamp, webkitLocale, webkitLogicalHeight, webkitLogicalWidth, webkitMarginAfter, webkitMarginBefore, webkitMarginEnd, webkitMarginStart, webkitMask, webkitMaskBoxImage, webkitMaskBoxImageOutset, webkitMaskBoxImageRepeat, webkitMaskBoxImageSlice, webkitMaskBoxImageSource, webkitMaskBoxImageWidth, webkitMaskClip, webkitMaskComposite, webkitMaskImage, webkitMaskOrigin, webkitMaskPosition, webkitMaskPositionX, webkitMaskPositionY, webkitMaskRepeat, webkitMaskRepeatX, webkitMaskRepeatY, webkitMaskSize, webkitMaxLogicalHeight, webkitMaxLogicalWidth, webkitMinLogicalHeight, webkitMinLogicalWidth, webkitOpacity, webkitOrder, webkitPaddingAfter, webkitPaddingBefore, webkitPaddingEnd, webkitPaddingStart, webkitPerspective, webkitPerspectiveOrigin, webkitPerspectiveOriginX, webkitPerspectiveOriginY, webkitPrintColorAdjust, webkitRtlOrdering, webkitRubyPosition, webkitShapeImageThreshold, webkitShapeMargin, webkitShapeOutside, webkitTapHighlightColor, webkitTextCombine, webkitTextDecorationsInEffect, webkitTextEmphasis, webkitTextEmphasisColor, webkitTextEmphasisPosition, webkitTextEmphasisStyle, webkitTextFillColor, webkitTextOrientation, webkitTextSecurity, webkitTextSizeAdjust, webkitTextStroke, webkitTextStrokeColor, webkitTextStrokeWidth, webkitTransform, webkitTransformOrigin, webkitTransformOriginX, webkitTransformOriginY, webkitTransformOriginZ, webkitTransformStyle, webkitTransition, webkitTransitionDelay, webkitTransitionDuration, webkitTransitionProperty, webkitTransitionTimingFunction, webkitUserDrag, webkitUserModify, webkitUserSelect, webkitWritingMode, whiteSpace, willChange, wordBreak, wordSpacing, wordWrap, writingMode, zIndex, additive-symbols, ascent-override, aspect-ratio, background-position-x, background-position-y, background-repeat-x, background-repeat-y, base-palette, border-block, border-block-color, border-block-end, border-block-start, border-block-style, border-block-width, border-bottom, border-color, border-image, border-inline, border-inline-color, border-inline-end, border-inline-start, border-inline-style, border-inline-width, border-left, border-radius, border-right, border-spacing, border-style, border-top, border-width, color-scheme, column-fill, column-rule, content-visibility, counter-increment, counter-reset, counter-set, descent-override, flex-flow, font-display, font-feature-settings, font-synthesis, font-variation-settings, forced-color-adjust, grid-area, grid-column, grid-column-gap, grid-gap, grid-row, grid-row-gap, grid-template, initial-value, inset-block, inset-inline, line-gap-override, list-style, margin-block, margin-inline, override-colors, overscroll-behavior, overscroll-behavior-x, overscroll-behavior-y, padding-block, padding-inline, page-break-after, page-break-before, page-break-inside, page-orientation, place-content, place-items, place-self, scroll-margin, scroll-margin-block, scroll-margin-bottom, scroll-margin-inline, scroll-margin-left, scroll-margin-right, scroll-margin-top, scroll-padding, scroll-padding-block, scroll-padding-bottom, scroll-padding-inline, scroll-padding-left, scroll-padding-right, scroll-padding-top, scroll-snap-align, scroll-snap-stop, scroll-snap-type, size-adjust, speak-as, text-combine-upright, text-decoration-thickness, text-emphasis, text-orientation, text-underline-offset, transform-box, unicode-range, -webkit-align-content, -webkit-align-items, -webkit-align-self, -webkit-animation, -webkit-animation-delay, -webkit-animation-direction, -webkit-animation-duration, -webkit-animation-fill-mode, -webkit-animation-iteration-count, -webkit-animation-name, -webkit-animation-play-state, -webkit-animation-timing-function, -webkit-app-region, -webkit-appearance, -webkit-backface-visibility, -webkit-background-clip, -webkit-background-origin, -webkit-background-size, -webkit-border-after, -webkit-border-after-color, -webkit-border-after-style, -webkit-border-after-width, -webkit-border-before, -webkit-border-before-color, -webkit-border-before-style, -webkit-border-before-width, -webkit-border-bottom-left-radius, -webkit-border-bottom-right-radius, -webkit-border-end, -webkit-border-end-color, -webkit-border-end-style, -webkit-border-end-width, -webkit-border-radius, -webkit-border-start, -webkit-border-start-color, -webkit-border-start-style, -webkit-border-start-width, -webkit-border-top-left-radius, -webkit-border-top-right-radius, -webkit-box-shadow, -webkit-box-sizing, -webkit-clip-path, -webkit-column-break-after, -webkit-column-break-before, -webkit-column-break-inside, -webkit-column-count, -webkit-column-gap, -webkit-column-rule, -webkit-column-rule-color, -webkit-column-rule-style, -webkit-column-rule-width, -webkit-column-span, -webkit-column-width, -webkit-columns, -webkit-filter, -webkit-flex, -webkit-flex-basis, -webkit-flex-direction, -webkit-flex-flow, -webkit-flex-grow, -webkit-flex-shrink, -webkit-flex-wrap, -webkit-font-feature-settings, -webkit-hyphenate-character, -webkit-justify-content, -webkit-logical-height, -webkit-logical-width, -webkit-margin-after, -webkit-margin-before, -webkit-margin-end, -webkit-margin-start, -webkit-mask, -webkit-mask-position-x, -webkit-mask-position-y, -webkit-mask-repeat-x, -webkit-mask-repeat-y, -webkit-max-logical-height, -webkit-max-logical-width, -webkit-min-logical-height, -webkit-min-logical-width, -webkit-opacity, -webkit-order, -webkit-padding-after, -webkit-padding-before, -webkit-padding-end, -webkit-padding-start, -webkit-perspective, -webkit-perspective-origin, -webkit-perspective-origin-x, -webkit-perspective-origin-y, -webkit-ruby-position, -webkit-shape-image-threshold, -webkit-shape-margin, -webkit-shape-outside, -webkit-text-emphasis, -webkit-text-emphasis-color, -webkit-text-emphasis-position, -webkit-text-emphasis-style, -webkit-text-size-adjust, -webkit-text-stroke, -webkit-transform, -webkit-transform-origin, -webkit-transform-origin-x, -webkit-transform-origin-y, -webkit-transform-origin-z, -webkit-transform-style, -webkit-transition, -webkit-transition-delay, -webkit-transition-duration, -webkit-transition-property, -webkit-transition-timing-function, -webkit-user-select, word-wrap`,
        jsKeys: 'Object.assign, Object.getOwnPropertyDescriptor, Object.getOwnPropertyDescriptors, Object.getOwnPropertyNames, Object.getOwnPropertySymbols, Object.hasOwn, Object.is, Object.preventExtensions, Object.seal, Object.create, Object.defineProperties, Object.defineProperty, Object.freeze, Object.getPrototypeOf, Object.setPrototypeOf, Object.isExtensible, Object.isFrozen, Object.isSealed, Object.keys, Object.entries, Object.fromEntries, Object.values, Object.__defineGetter__, Object.__defineSetter__, Object.hasOwnProperty, Object.__lookupGetter__, Object.__lookupSetter__, Object.isPrototypeOf, Object.propertyIsEnumerable, Object.toString, Object.valueOf, Object.__proto__, Object.toLocaleString, Function.apply, Function.bind, Function.call, Function.toString, Boolean.toString, Boolean.valueOf, Symbol.for, Symbol.keyFor, Symbol.asyncIterator, Symbol.hasInstance, Symbol.isConcatSpreadable, Symbol.iterator, Symbol.match, Symbol.matchAll, Symbol.replace, Symbol.search, Symbol.species, Symbol.split, Symbol.toPrimitive, Symbol.toStringTag, Symbol.unscopables, Symbol.toString, Symbol.valueOf, Symbol.description, Error.captureStackTrace, Error.stackTraceLimit, Error.message, Error.toString, Number.isFinite, Number.isInteger, Number.isNaN, Number.isSafeInteger, Number.parseFloat, Number.parseInt, Number.MAX_VALUE, Number.MIN_VALUE, Number.NaN, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.EPSILON, Number.toExponential, Number.toFixed, Number.toPrecision, Number.toString, Number.valueOf, Number.toLocaleString, BigInt.asUintN, BigInt.asIntN, BigInt.toLocaleString, BigInt.toString, BigInt.valueOf, Math.abs, Math.acos, Math.acosh, Math.asin, Math.asinh, Math.atan, Math.atanh, Math.atan2, Math.ceil, Math.cbrt, Math.expm1, Math.clz32, Math.cos, Math.cosh, Math.exp, Math.floor, Math.fround, Math.hypot, Math.imul, Math.log, Math.log1p, Math.log2, Math.log10, Math.max, Math.min, Math.pow, Math.random, Math.round, Math.sign, Math.sin, Math.sinh, Math.sqrt, Math.tan, Math.tanh, Math.trunc, Math.E, Math.LN10, Math.LN2, Math.LOG10E, Math.LOG2E, Math.PI, Math.SQRT1_2, Math.SQRT2, Date.now, Date.parse, Date.UTC, Date.toString, Date.toDateString, Date.toTimeString, Date.toISOString, Date.toUTCString, Date.toGMTString, Date.getDate, Date.setDate, Date.getDay, Date.getFullYear, Date.setFullYear, Date.getHours, Date.setHours, Date.getMilliseconds, Date.setMilliseconds, Date.getMinutes, Date.setMinutes, Date.getMonth, Date.setMonth, Date.getSeconds, Date.setSeconds, Date.getTime, Date.setTime, Date.getTimezoneOffset, Date.getUTCDate, Date.setUTCDate, Date.getUTCDay, Date.getUTCFullYear, Date.setUTCFullYear, Date.getUTCHours, Date.setUTCHours, Date.getUTCMilliseconds, Date.setUTCMilliseconds, Date.getUTCMinutes, Date.setUTCMinutes, Date.getUTCMonth, Date.setUTCMonth, Date.getUTCSeconds, Date.setUTCSeconds, Date.valueOf, Date.getYear, Date.setYear, Date.toJSON, Date.toLocaleString, Date.toLocaleDateString, Date.toLocaleTimeString, String.fromCharCode, String.fromCodePoint, String.raw, String.anchor, String.at, String.big, String.blink, String.bold, String.charAt, String.charCodeAt, String.codePointAt, String.concat, String.endsWith, String.fontcolor, String.fontsize, String.fixed, String.includes, String.indexOf, String.italics, String.lastIndexOf, String.link, String.localeCompare, String.match, String.matchAll, String.normalize, String.padEnd, String.padStart, String.repeat, String.replace, String.replaceAll, String.search, String.slice, String.small, String.split, String.strike, String.sub, String.substr, String.substring, String.sup, String.startsWith, String.toString, String.trim, String.trimStart, String.trimLeft, String.trimEnd, String.trimRight, String.toLocaleLowerCase, String.toLocaleUpperCase, String.toLowerCase, String.toUpperCase, String.valueOf, RegExp.input, RegExp.$_, RegExp.lastMatch, RegExp.$&, RegExp.lastParen, RegExp.$+, RegExp.leftContext, RegExp.$`, RegExp.rightContext, RegExp.$\', RegExp.$1, RegExp.$2, RegExp.$3, RegExp.$4, RegExp.$5, RegExp.$6, RegExp.$7, RegExp.$8, RegExp.$9, RegExp.exec, RegExp.dotAll, RegExp.flags, RegExp.global, RegExp.hasIndices, RegExp.ignoreCase, RegExp.multiline, RegExp.source, RegExp.sticky, RegExp.unicode, RegExp.compile, RegExp.toString, RegExp.test, Array.isArray, Array.from, Array.of, Array.at, Array.concat, Array.copyWithin, Array.fill, Array.find, Array.findIndex, Array.lastIndexOf, Array.pop, Array.push, Array.reverse, Array.shift, Array.unshift, Array.slice, Array.sort, Array.splice, Array.includes, Array.indexOf, Array.join, Array.keys, Array.entries, Array.values, Array.forEach, Array.filter, Array.flat, Array.flatMap, Array.map, Array.every, Array.some, Array.reduce, Array.reduceRight, Array.toLocaleString, Array.toString, Array.findLast, Array.findLastIndex, Map.get, Map.set, Map.has, Map.delete, Map.clear, Map.entries, Map.forEach, Map.keys, Map.size, Map.values, Set.has, Set.add, Set.delete, Set.clear, Set.entries, Set.forEach, Set.size, Set.values, Set.keys, WeakMap.delete, WeakMap.get, WeakMap.set, WeakMap.has, WeakSet.delete, WeakSet.has, WeakSet.add, Atomics.load, Atomics.store, Atomics.add, Atomics.sub, Atomics.and, Atomics.or, Atomics.xor, Atomics.exchange, Atomics.compareExchange, Atomics.isLockFree, Atomics.wait, Atomics.waitAsync, Atomics.notify, JSON.parse, JSON.stringify, Promise.all, Promise.allSettled, Promise.any, Promise.race, Promise.resolve, Promise.reject, Promise.then, Promise.catch, Promise.finally, Reflect.defineProperty, Reflect.deleteProperty, Reflect.apply, Reflect.construct, Reflect.get, Reflect.getOwnPropertyDescriptor, Reflect.getPrototypeOf, Reflect.has, Reflect.isExtensible, Reflect.ownKeys, Reflect.preventExtensions, Reflect.set, Reflect.setPrototypeOf, Proxy.revocable, Intl.getCanonicalLocales, Intl.supportedValuesOf, Intl.DateTimeFormat, Intl.NumberFormat, Intl.Collator, Intl.v8BreakIterator, Intl.PluralRules, Intl.RelativeTimeFormat, Intl.ListFormat, Intl.Locale, Intl.DisplayNames, Intl.Segmenter, WebAssembly.compile, WebAssembly.validate, WebAssembly.instantiate, WebAssembly.compileStreaming, WebAssembly.instantiateStreaming, WebAssembly.Module, WebAssembly.Instance, WebAssembly.Table, WebAssembly.Memory, WebAssembly.Global, WebAssembly.Tag, WebAssembly.Exception, WebAssembly.CompileError, WebAssembly.LinkError, WebAssembly.RuntimeError, Document.implementation, Document.URL, Document.documentURI, Document.compatMode, Document.characterSet, Document.charset, Document.inputEncoding, Document.contentType, Document.doctype, Document.documentElement, Document.xmlEncoding, Document.xmlVersion, Document.xmlStandalone, Document.domain, Document.referrer, Document.cookie, Document.lastModified, Document.readyState, Document.title, Document.dir, Document.body, Document.head, Document.images, Document.embeds, Document.plugins, Document.links, Document.forms, Document.scripts, Document.currentScript, Document.defaultView, Document.designMode, Document.onreadystatechange, Document.anchors, Document.applets, Document.fgColor, Document.linkColor, Document.vlinkColor, Document.alinkColor, Document.bgColor, Document.all, Document.scrollingElement, Document.onpointerlockchange, Document.onpointerlockerror, Document.hidden, Document.visibilityState, Document.wasDiscarded, Document.featurePolicy, Document.webkitVisibilityState, Document.webkitHidden, Document.onbeforecopy, Document.onbeforecut, Document.onbeforepaste, Document.onfreeze, Document.onresume, Document.onsearch, Document.onvisibilitychange, Document.fullscreenEnabled, Document.fullscreen, Document.onfullscreenchange, Document.onfullscreenerror, Document.webkitIsFullScreen, Document.webkitCurrentFullScreenElement, Document.webkitFullscreenEnabled, Document.webkitFullscreenElement, Document.onwebkitfullscreenchange, Document.onwebkitfullscreenerror, Document.rootElement, Document.onbeforexrselect, Document.onabort, Document.onbeforeinput, Document.onblur, Document.oncancel, Document.oncanplay, Document.oncanplaythrough, Document.onchange, Document.onclick, Document.onclose, Document.oncontextlost, Document.oncontextmenu, Document.oncontextrestored, Document.oncuechange, Document.ondblclick, Document.ondrag, Document.ondragend, Document.ondragenter, Document.ondragleave, Document.ondragover, Document.ondragstart, Document.ondrop, Document.ondurationchange, Document.onemptied, Document.onended, Document.onerror, Document.onfocus, Document.onformdata, Document.oninput, Document.oninvalid, Document.onkeydown, Document.onkeypress, Document.onkeyup, Document.onload, Document.onloadeddata, Document.onloadedmetadata, Document.onloadstart, Document.onmousedown, Document.onmouseenter, Document.onmouseleave, Document.onmousemove, Document.onmouseout, Document.onmouseover, Document.onmouseup, Document.onmousewheel, Document.onpause, Document.onplay, Document.onplaying, Document.onprogress, Document.onratechange, Document.onreset, Document.onresize, Document.onscroll, Document.onsecuritypolicyviolation, Document.onseeked, Document.onseeking, Document.onselect, Document.onslotchange, Document.onstalled, Document.onsubmit, Document.onsuspend, Document.ontimeupdate, Document.ontoggle, Document.onvolumechange, Document.onwaiting, Document.onwebkitanimationend, Document.onwebkitanimationiteration, Document.onwebkitanimationstart, Document.onwebkittransitionend, Document.onwheel, Document.onauxclick, Document.ongotpointercapture, Document.onlostpointercapture, Document.onpointerdown, Document.onpointermove, Document.onpointerrawupdate, Document.onpointerup, Document.onpointercancel, Document.onpointerover, Document.onpointerout, Document.onpointerenter, Document.onpointerleave, Document.onselectstart, Document.onselectionchange, Document.onanimationend, Document.onanimationiteration, Document.onanimationstart, Document.ontransitionrun, Document.ontransitionstart, Document.ontransitionend, Document.ontransitioncancel, Document.oncopy, Document.oncut, Document.onpaste, Document.children, Document.firstElementChild, Document.lastElementChild, Document.childElementCount, Document.activeElement, Document.styleSheets, Document.pointerLockElement, Document.fullscreenElement, Document.adoptedStyleSheets, Document.fonts, Document.adoptNode, Document.append, Document.captureEvents, Document.caretRangeFromPoint, Document.clear, Document.close, Document.createAttribute, Document.createAttributeNS, Document.createCDATASection, Document.createComment, Document.createDocumentFragment, Document.createElement, Document.createElementNS, Document.createEvent, Document.createExpression, Document.createNSResolver, Document.createNodeIterator, Document.createProcessingInstruction, Document.createRange, Document.createTextNode, Document.createTreeWalker, Document.elementFromPoint, Document.elementsFromPoint, Document.evaluate, Document.execCommand, Document.exitFullscreen, Document.exitPointerLock, Document.getElementById, Document.getElementsByClassName, Document.getElementsByName, Document.getElementsByTagName, Document.getElementsByTagNameNS, Document.getSelection, Document.hasFocus, Document.importNode, Document.open, Document.prepend, Document.queryCommandEnabled, Document.queryCommandIndeterm, Document.queryCommandState, Document.queryCommandSupported, Document.queryCommandValue, Document.querySelector, Document.querySelectorAll, Document.releaseEvents, Document.replaceChildren, Document.webkitCancelFullScreen, Document.webkitExitFullscreen, Document.write, Document.writeln, Document.prerendering, Document.onprerenderingchange, Document.fragmentDirective, Document.onbeforematch, Document.timeline, Document.pictureInPictureEnabled, Document.pictureInPictureElement, Document.oncontentvisibilityautostatechange, Document.exitPictureInPicture, Document.getAnimations, Element.namespaceURI, Element.prefix, Element.localName, Element.tagName, Element.id, Element.className, Element.classList, Element.slot, Element.attributes, Element.shadowRoot, Element.part, Element.assignedSlot, Element.innerHTML, Element.outerHTML, Element.scrollTop, Element.scrollLeft, Element.scrollWidth, Element.scrollHeight, Element.clientTop, Element.clientLeft, Element.clientWidth, Element.clientHeight, Element.onbeforecopy, Element.onbeforecut, Element.onbeforepaste, Element.onsearch, Element.elementTiming, Element.onfullscreenchange, Element.onfullscreenerror, Element.onwebkitfullscreenchange, Element.onwebkitfullscreenerror, Element.role, Element.ariaAtomic, Element.ariaAutoComplete, Element.ariaBusy, Element.ariaBrailleLabel, Element.ariaBrailleRoleDescription, Element.ariaChecked, Element.ariaColCount, Element.ariaColIndex, Element.ariaColSpan, Element.ariaCurrent, Element.ariaDescription, Element.ariaDisabled, Element.ariaExpanded, Element.ariaHasPopup, Element.ariaHidden, Element.ariaInvalid, Element.ariaKeyShortcuts, Element.ariaLabel, Element.ariaLevel, Element.ariaLive, Element.ariaModal, Element.ariaMultiLine, Element.ariaMultiSelectable, Element.ariaOrientation, Element.ariaPlaceholder, Element.ariaPosInSet, Element.ariaPressed, Element.ariaReadOnly, Element.ariaRelevant, Element.ariaRequired, Element.ariaRoleDescription, Element.ariaRowCount, Element.ariaRowIndex, Element.ariaRowSpan, Element.ariaSelected, Element.ariaSetSize, Element.ariaSort, Element.ariaValueMax, Element.ariaValueMin, Element.ariaValueNow, Element.ariaValueText, Element.children, Element.firstElementChild, Element.lastElementChild, Element.childElementCount, Element.previousElementSibling, Element.nextElementSibling, Element.after, Element.animate, Element.append, Element.attachShadow, Element.before, Element.closest, Element.computedStyleMap, Element.getAttribute, Element.getAttributeNS, Element.getAttributeNames, Element.getAttributeNode, Element.getAttributeNodeNS, Element.getBoundingClientRect, Element.getClientRects, Element.getElementsByClassName, Element.getElementsByTagName, Element.getElementsByTagNameNS, Element.getInnerHTML, Element.hasAttribute, Element.hasAttributeNS, Element.hasAttributes, Element.hasPointerCapture, Element.insertAdjacentElement, Element.insertAdjacentHTML, Element.insertAdjacentText, Element.matches, Element.prepend, Element.querySelector, Element.querySelectorAll, Element.releasePointerCapture, Element.remove, Element.removeAttribute, Element.removeAttributeNS, Element.removeAttributeNode, Element.replaceChildren, Element.replaceWith, Element.requestFullscreen, Element.requestPointerLock, Element.scroll, Element.scrollBy, Element.scrollIntoView, Element.scrollIntoViewIfNeeded, Element.scrollTo, Element.setAttribute, Element.setAttributeNS, Element.setAttributeNode, Element.setAttributeNodeNS, Element.setPointerCapture, Element.toggleAttribute, Element.webkitMatchesSelector, Element.webkitRequestFullScreen, Element.webkitRequestFullscreen, Element.checkVisibility, Element.getAnimations, Element.setHTML',
    },
    'Firefox': {
        version: 108,
        windowKeys: `undefined, globalThis, Array, Boolean, JSON, Date, Math, Number, String, RegExp, Error, InternalError, AggregateError, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, ArrayBuffer, Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, Uint8ClampedArray, BigInt64Array, BigUint64Array, BigInt, Proxy, WeakMap, Set, DataView, Symbol, Intl, Reflect, WeakSet, Atomics, Promise, WebAssembly, FinalizationRegistry, WeakRef, NaN, Infinity, isNaN, isFinite, parseFloat, parseInt, escape, unescape, decodeURI, encodeURI, decodeURIComponent, encodeURIComponent, ResizeObserverEntry, BroadcastChannel, AbortController, DOMRectList, SVGAnimatedEnumeration, DOMPointReadOnly, RTCDtlsTransport, MediaStreamTrackEvent, HTMLMediaElement, MediaDevices, TextMetrics, MIDIAccess, GamepadButton, IIRFilterNode, Response, PushSubscription, DocumentTimeline, SVGAnimatedNumberList, HTMLImageElement, HTMLFontElement, SourceBufferList, SVGFilterElement, HTMLPictureElement, CSSGroupingRule, HTMLSlotElement, DeviceOrientationEvent, SVGDefsElement, XPathResult, SVGFEDiffuseLightingElement, VTTCue, NodeFilter, WebGLTexture, GainNode, TextDecoder, GamepadPose, FileSystemFileEntry, SVGRadialGradientElement, WebGLShaderPrecisionFormat, SVGScriptElement, IDBOpenDBRequest, CustomEvent, IntersectionObserverEntry, DOMRectReadOnly, DataTransferItem, MIDIInput, TextDecoderStream, SVGComponentTransferFunctionElement, Image, Notification, ProcessingInstruction, ReadableStreamBYOBRequest, HTMLHeadingElement, FontFace, MIDIOutputMap, SVGFEMergeNodeElement, PopStateEvent, HTMLTrackElement, PluginArray, MIDIPort, FocusEvent, SVGAnimateTransformElement, DataTransfer, HTMLSpanElement, HTMLMeterElement, AudioProcessingEvent, HTMLTimeElement, IDBDatabase, SVGAnimatedInteger, ChannelMergerNode, HTMLFormElement, XMLDocument, NavigationPreloadManager, FileReader, Range, TextEncoderStream, HTMLBodyElement, HTMLTitleElement, Comment, FileSystemDirectoryReader, PublicKeyCredential, ImageBitmap, console, FontFaceSet, HTMLProgressElement, RTCTrackEvent, PointerEvent, HTMLFieldSetElement, MediaSource, SVGFEDisplacementMapElement, Cache, ReadableStreamBYOBReader, MessageEvent, WebGLProgram, StaticRange, XPathEvaluator, HTMLAreaElement, HTMLFormControlsCollection, PaintRequest, ChannelSplitterNode, MediaSession, DOMRect, SVGFESpecularLightingElement, SVGDescElement, AudioScheduledSourceNode, HTMLUnknownElement, SVGFETileElement, HTMLMenuElement, Storage, ConstantSourceNode, CacheStorage, SVGAnimatedPreserveAspectRatio, SVGFEFuncGElement, ScrollAreaEvent, CSSMediaRule, SVGSetElement, SVGGElement, SVGMetadataElement, ClipboardEvent, AudioContext, WebGLRenderbuffer, AudioParamMap, WebGLQuery, MediaKeySession, HTMLVideoElement, SVGFETurbulenceElement, BeforeUnloadEvent, CSSTransition, SVGTextPositioningElement, RTCPeerConnectionIceEvent, SVGTransform, PerformanceEventTiming, HTMLBRElement, SVGTSpanElement, SVGMaskElement, SVGMarkerElement, U2F, MutationRecord, AudioDestinationNode, ReadableByteStreamController, UIEvent, WebGLBuffer, IDBTransaction, OfflineResourceList, HTMLInputElement, HTMLLegendElement, mozRTCSessionDescription, SVGAnimationElement, SVGViewElement, CaretPosition, EventSource, SharedWorker, ServiceWorkerRegistration, DelayNode, CryptoKey, SVGMPathElement, NodeList, SVGFEPointLightElement, MediaError, SVGFEFloodElement, MediaKeyMessageEvent, HTMLTextAreaElement, MediaDeviceInfo, CSSCounterStyleRule, HTMLTableRowElement, AudioWorkletNode, AuthenticatorResponse, AudioNode, StorageManager, Permissions, IDBKeyRange, SVGFEComponentTransferElement, HTMLOutputElement, WebGL2RenderingContext, SVGTitleElement, AnimationPlaybackEvent, PromiseRejectionEvent, PerformancePaintTiming, SVGUnitTypes, SVGUseElement, PerformanceTiming, MathMLElement, GamepadHapticActuator, Navigator, mozRTCPeerConnection, PerformanceResourceTiming, AnimationTimeline, MIDIConnectionEvent, CanvasCaptureMediaStream, HTMLDirectoryElement, Gamepad, Lock, DOMQuad, MediaStreamTrackAudioSourceNode, PopupBlockedEvent, MouseScrollEvent, SVGFEFuncAElement, DataTransferItemList, AudioBufferSourceNode, WebGLContextEvent, XSLTProcessor, SVGFECompositeElement, TextTrack, OfflineAudioCompletionEvent, HTMLHRElement, SpeechSynthesisUtterance, CredentialsContainer, RTCRtpTransceiver, SVGTextElement, ImageBitmapRenderingContext, MediaList, HTMLDivElement, SVGGraphicsElement, CanvasPattern, ResizeObserver, HTMLBaseElement, MimeTypeArray, MediaCapabilitiesInfo, HTMLTableSectionElement, HTMLSelectElement, VideoPlaybackQuality, RTCDataChannelEvent, Headers, IdleDeadline, WebGLSampler, HTMLFrameElement, WebGLShader, Option, PaintRequestList, BarProp, SVGMatrix, ImageData, CSSFontFeatureValuesRule, SVGPolylineElement, CSSImportRule, MediaStreamEvent, HTMLLabelElement, ReadableStream, HTMLDialogElement, SVGAnimatedString, MimeType, StorageEvent, IDBObjectStore, HTMLParamElement, CSSRuleList, IDBCursor, CSSNamespaceRule, Worker, SVGAnimatedTransformList, GeolocationPosition, PageTransitionEvent, Directory, PerformanceObserverEntryList, PerformanceMark, AnalyserNode, CloseEvent, DocumentType, TransformStreamDefaultController, SVGPathElement, ReadableStreamDefaultController, PeriodicWave, BiquadFilterNode, SubmitEvent, WebGLVertexArrayObject, HTMLQuoteElement, Request, SVGClipPathElement, RadioNodeList, RTCPeerConnection, ByteLengthQueuingStrategy, WebGLTransformFeedback, HTMLHeadElement, CSSLayerStatementRule, SVGAElement, ServiceWorker, AudioParam, IDBVersionChangeEvent, BlobEvent, TrackEvent, Text, MediaKeys, MediaMetadata, DOMTokenList, SpeechSynthesis, RTCRtpReceiver, ResizeObserverSize, FormData, MediaStream, HTMLMetaElement, Worklet, FileSystem, SVGLinearGradientElement, Element, SVGAnimatedRect, SVGTextPathElement, CSSKeyframeRule, TimeEvent, InputEvent, AbstractRange, AbortSignal, DeviceMotionEvent, SVGAnimatedLengthList, PerformanceMeasure, IDBFactory, MediaRecorder, CSSConditionRule, RTCSessionDescription, CSSKeyframesRule, NodeIterator, Geolocation, RTCIceCandidate, MediaKeyError, AnimationEvent, CustomElementRegistry, HTMLObjectElement, File, ErrorEvent, MediaQueryListEvent, ValidityState, PannerNode, IntersectionObserver, DOMStringList, SVGFEOffsetElement, Plugin, DOMParser, SVGFEConvolveMatrixElement, SpeechSynthesisEvent, TreeWalker, HTMLAllCollection, SVGCircleElement, SVGFEDistantLightElement, SpeechSynthesisErrorEvent, WaveShaperNode, CSSAnimation, URL, SVGLengthList, SubtleCrypto, SVGPointList, HTMLAudioElement, MessageChannel, MessagePort, WebGLActiveInfo, Screen, XPathExpression, MediaRecorderErrorEvent, HTMLButtonElement, Location, MediaStreamAudioSourceNode, AnimationEffect, PerformanceObserver, SVGRectElement, ReadableStreamDefaultReader, DOMPoint, MediaKeySystemAccess, SVGFEDropShadowElement, HTMLDataElement, SVGTextContentElement, SVGFEMorphologyElement, SVGElement, HTMLModElement, Blob, CDATASection, FontFaceSetLoadEvent, AuthenticatorAttestationResponse, TextTrackCue, CSSFontFaceRule, MediaStreamAudioDestinationNode, SVGImageElement, SVGRect, SVGStopElement, VTTRegion, SVGFESpotLightElement, Selection, BaseAudioContext, SVGPoint, CanvasRenderingContext2D, Attr, XMLHttpRequest, WritableStreamDefaultWriter, Audio, HTMLStyleElement, SVGEllipseElement, MutationEvent, ProgressEvent, HTMLPreElement, DOMImplementation, HTMLMarqueeElement, XMLSerializer, SVGAnimateMotionElement, SVGGeometryElement, IDBRequest, PushManager, CSSMozDocumentRule, HTMLMapElement, AudioListener, GamepadEvent, MIDIMessageEvent, ElementInternals, TextEncoder, webkitURL, CSSStyleRule, SVGGradientElement, HTMLDetailsElement, SVGForeignObjectElement, CharacterData, RTCCertificate, HTMLCanvasElement, RTCDTMFToneChangeEvent, CSSStyleSheet, ScreenOrientation, ShadowRoot, DynamicsCompressorNode, WritableStream, HTMLFrameSetElement, TimeRanges, KeyframeEffect, SVGSVGElement, KeyEvent, Clipboard, HTMLDListElement, CountQueuingStrategy, DocumentFragment, DragEvent, mozRTCIceCandidate, MediaStreamTrack, SVGLength, MediaQueryList, URLSearchParams, HTMLSourceElement, KeyboardEvent, ScriptProcessorNode, DOMStringMap, HTMLOptGroupElement, WebGLUniformLocation, OffscreenCanvas, SVGPolygonElement, HTMLCollection, SVGNumber, MediaCapabilities, SourceBuffer, VisualViewport, CSSPageRule, GeolocationPositionError, HTMLTableColElement, SVGTransformList, SVGAnimatedNumber, CanvasGradient, PushSubscriptionOptions, History, WebKitCSSMatrix, HTMLTableCellElement, HTMLOptionElement, MediaElementAudioSourceNode, FormDataEvent, TextTrackCueList, SVGSwitchElement, Path2D, StyleSheet, PerformanceServerTiming, PerformanceNavigation, MutationObserver, XMLHttpRequestUpload, CSSLayerBlockRule, SVGPreserveAspectRatio, HTMLTableCaptionElement, SVGPatternElement, HTMLEmbedElement, XMLHttpRequestEventTarget, TransitionEvent, HTMLAnchorElement, HTMLDataListElement, SVGAngle, SVGLineElement, AudioBuffer, HashChangeEvent, MediaKeyStatusMap, IDBIndex, CSS, SVGFEGaussianBlurElement, Crypto, NamedNodeMap, CSSStyleDeclaration, MouseEvent, FileSystemEntry, DOMMatrix, SVGAnimatedAngle, OfflineAudioContext, HTMLScriptElement, StyleSheetList, RTCDTMFSender, HTMLOListElement, SVGSymbolElement, SpeechSynthesisVoice, SVGFEColorMatrixElement, TransformStream, SVGFEFuncBElement, DOMRequest, RTCRtpSender, CSSRule, OscillatorNode, ServiceWorkerContainer, HTMLParagraphElement, ConvolverNode, AudioWorklet, HTMLLinkElement, MIDIInputMap, PerformanceEntry, AuthenticatorAssertionResponse, TextTrackList, DOMException, SVGAnimateElement, HTMLOptionsCollection, HTMLUListElement, WheelEvent, SVGAnimatedBoolean, SecurityPolicyViolationEvent, RTCStatsReport, OffscreenCanvasRenderingContext2D, PermissionStatus, CompositionEvent, SVGFEFuncRElement, FileList, SVGStringList, SVGFEImageElement, HTMLElement, DOMMatrixReadOnly, LockManager, HTMLLIElement, SVGFEBlendElement, Animation, RTCDataChannel, MediaEncryptedEvent, WritableStreamDefaultController, WebGLFramebuffer, SVGStyleElement, SVGAnimatedLength, CSSFontPaletteValuesRule, CSSSupportsRule, HTMLIFrameElement, SVGNumberList, MIDIOutput, WebSocket, CSS2Properties, HTMLTableElement, FileSystemDirectoryEntry, SVGFEMergeElement, GeolocationCoordinates, StereoPannerNode, Credential, WebGLRenderingContext, WebGLSync, HTMLHtmlElement, HTMLTemplateElement, IDBCursorWithValue, Function, Object, eval, EventTarget, Window, close, stop, focus, blur, open, alert, confirm, prompt, print, postMessage, captureEvents, releaseEvents, getSelection, getComputedStyle, matchMedia, moveTo, moveBy, resizeTo, resizeBy, scroll, scrollTo, scrollBy, getDefaultComputedStyle, scrollByLines, scrollByPages, sizeToContent, updateCommands, find, dump, setResizable, requestIdleCallback, cancelIdleCallback, requestAnimationFrame, cancelAnimationFrame, reportError, btoa, atob, setTimeout, clearTimeout, setInterval, clearInterval, queueMicrotask, createImageBitmap, structuredClone, fetch, self, name, history, customElements, locationbar, menubar, personalbar, scrollbars, statusbar, toolbar, status, closed, event, frames, length, opener, parent, frameElement, navigator, clientInformation, external, applicationCache, screen, innerWidth, innerHeight, scrollX, pageXOffset, scrollY, pageYOffset, screenLeft, screenTop, screenX, screenY, outerWidth, outerHeight, performance, mozInnerScreenX, mozInnerScreenY, devicePixelRatio, scrollMaxX, scrollMaxY, fullScreen, ondevicemotion, ondeviceorientation, onabsolutedeviceorientation, InstallTrigger, visualViewport, crypto, onabort, onblur, onfocus, onauxclick, onbeforeinput, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragexit, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onformdata, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onwheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onsecuritypolicyviolation, onseeked, onseeking, onselect, onslotchange, onstalled, onsubmit, onsuspend, ontimeupdate, onvolumechange, onwaiting, onselectstart, onselectionchange, ontoggle, onpointercancel, onpointerdown, onpointerup, onpointermove, onpointerout, onpointerover, onpointerenter, onpointerleave, ongotpointercapture, onlostpointercapture, onmozfullscreenchange, onmozfullscreenerror, onanimationcancel, onanimationend, onanimationiteration, onanimationstart, ontransitioncancel, ontransitionend, ontransitionrun, ontransitionstart, onwebkitanimationend, onwebkitanimationiteration, onwebkitanimationstart, onwebkittransitionend, u2f, onerror, speechSynthesis, onafterprint, onbeforeprint, onbeforeunload, onhashchange, onlanguagechange, onmessage, onmessageerror, onoffline, ononline, onpagehide, onpageshow, onpopstate, onrejectionhandled, onstorage, onunhandledrejection, onunload, ongamepadconnected, ongamepaddisconnected, localStorage, origin, crossOriginIsolated, isSecureContext, indexedDB, caches, sessionStorage, window, document, location, top, netscape, Node, Document, HTMLDocument, EventCounts, Map, Event`,
        cssKeys: `alignContent, align-content, alignItems, align-items, alignSelf, align-self, aspectRatio, aspect-ratio, backfaceVisibility, backface-visibility, borderCollapse, border-collapse, borderImageRepeat, border-image-repeat, boxDecorationBreak, box-decoration-break, boxSizing, box-sizing, breakInside, break-inside, captionSide, caption-side, clear, colorInterpolation, color-interpolation, colorInterpolationFilters, color-interpolation-filters, columnCount, column-count, columnFill, column-fill, columnSpan, column-span, contain, direction, display, dominantBaseline, dominant-baseline, emptyCells, empty-cells, flexDirection, flex-direction, flexWrap, flex-wrap, cssFloat, float, fontKerning, font-kerning, fontOpticalSizing, font-optical-sizing, fontSizeAdjust, font-size-adjust, fontStretch, font-stretch, fontStyle, font-style, fontSynthesis, font-synthesis, fontVariantCaps, font-variant-caps, fontVariantEastAsian, font-variant-east-asian, fontVariantLigatures, font-variant-ligatures, fontVariantNumeric, font-variant-numeric, fontVariantPosition, font-variant-position, fontWeight, font-weight, gridAutoFlow, grid-auto-flow, hyphens, imageOrientation, image-orientation, imageRendering, image-rendering, imeMode, ime-mode, isolation, justifyContent, justify-content, justifyItems, justify-items, justifySelf, justify-self, lineBreak, line-break, listStylePosition, list-style-position, maskType, mask-type, mixBlendMode, mix-blend-mode, MozBoxAlign, -moz-box-align, MozBoxDirection, -moz-box-direction, MozBoxOrient, -moz-box-orient, MozBoxPack, -moz-box-pack, MozFloatEdge, -moz-float-edge, MozOrient, -moz-orient, MozTextSizeAdjust, -moz-text-size-adjust, MozUserFocus, -moz-user-focus, MozUserInput, -moz-user-input, MozUserModify, -moz-user-modify, MozWindowDragging, -moz-window-dragging, objectFit, object-fit, offsetRotate, offset-rotate, outlineStyle, outline-style, overflowAnchor, overflow-anchor, overflowWrap, overflow-wrap, paintOrder, paint-order, pointerEvents, pointer-events, position, printColorAdjust, print-color-adjust, resize, rubyAlign, ruby-align, rubyPosition, ruby-position, scrollBehavior, scroll-behavior, scrollSnapAlign, scroll-snap-align, scrollSnapStop, scroll-snap-stop, scrollSnapType, scroll-snap-type, scrollbarGutter, scrollbar-gutter, scrollbarWidth, scrollbar-width, shapeRendering, shape-rendering, strokeLinecap, stroke-linecap, strokeLinejoin, stroke-linejoin, tableLayout, table-layout, textAlign, text-align, textAlignLast, text-align-last, textAnchor, text-anchor, textCombineUpright, text-combine-upright, textDecorationLine, text-decoration-line, textDecorationSkipInk, text-decoration-skip-ink, textDecorationStyle, text-decoration-style, textEmphasisPosition, text-emphasis-position, textJustify, text-justify, textOrientation, text-orientation, textRendering, text-rendering, textTransform, text-transform, textUnderlinePosition, text-underline-position, touchAction, touch-action, transformBox, transform-box, transformStyle, transform-style, unicodeBidi, unicode-bidi, userSelect, user-select, vectorEffect, vector-effect, visibility, webkitLineClamp, WebkitLineClamp, -webkit-line-clamp, whiteSpace, white-space, wordBreak, word-break, writingMode, writing-mode, zIndex, z-index, appearance, MozForceBrokenImageIcon, -moz-force-broken-image-icon, breakAfter, break-after, breakBefore, break-before, clipRule, clip-rule, fillRule, fill-rule, fillOpacity, fill-opacity, strokeOpacity, stroke-opacity, MozBoxOrdinalGroup, -moz-box-ordinal-group, order, flexGrow, flex-grow, flexShrink, flex-shrink, MozBoxFlex, -moz-box-flex, strokeMiterlimit, stroke-miterlimit, overflowBlock, overflow-block, overflowInline, overflow-inline, overflowX, overflow-x, overflowY, overflow-y, overscrollBehaviorBlock, overscroll-behavior-block, overscrollBehaviorInline, overscroll-behavior-inline, overscrollBehaviorX, overscroll-behavior-x, overscrollBehaviorY, overscroll-behavior-y, floodOpacity, flood-opacity, opacity, shapeImageThreshold, shape-image-threshold, stopOpacity, stop-opacity, borderBlockEndStyle, border-block-end-style, borderBlockStartStyle, border-block-start-style, borderBottomStyle, border-bottom-style, borderInlineEndStyle, border-inline-end-style, borderInlineStartStyle, border-inline-start-style, borderLeftStyle, border-left-style, borderRightStyle, border-right-style, borderTopStyle, border-top-style, columnRuleStyle, column-rule-style, accentColor, accent-color, animationDelay, animation-delay, animationDirection, animation-direction, animationDuration, animation-duration, animationFillMode, animation-fill-mode, animationIterationCount, animation-iteration-count, animationName, animation-name, animationPlayState, animation-play-state, animationTimingFunction, animation-timing-function, backdropFilter, backdrop-filter, backgroundAttachment, background-attachment, backgroundBlendMode, background-blend-mode, backgroundClip, background-clip, backgroundImage, background-image, backgroundOrigin, background-origin, backgroundPositionX, background-position-x, backgroundPositionY, background-position-y, backgroundRepeat, background-repeat, backgroundSize, background-size, borderImageOutset, border-image-outset, borderImageSlice, border-image-slice, borderImageWidth, border-image-width, borderSpacing, border-spacing, boxShadow, box-shadow, caretColor, caret-color, clipPath, clip-path, color, colorScheme, color-scheme, columnWidth, column-width, content, counterIncrement, counter-increment, counterReset, counter-reset, counterSet, counter-set, cursor, d, filter, flexBasis, flex-basis, fontFamily, font-family, fontFeatureSettings, font-feature-settings, fontLanguageOverride, font-language-override, fontPalette, font-palette, fontSize, font-size, fontVariantAlternates, font-variant-alternates, fontVariationSettings, font-variation-settings, gridTemplateAreas, grid-template-areas, hyphenateCharacter, hyphenate-character, letterSpacing, letter-spacing, lineHeight, line-height, listStyleType, list-style-type, maskClip, mask-clip, maskComposite, mask-composite, maskImage, mask-image, maskMode, mask-mode, maskOrigin, mask-origin, maskPositionX, mask-position-x, maskPositionY, mask-position-y, maskRepeat, mask-repeat, maskSize, mask-size, offsetAnchor, offset-anchor, offsetPath, offset-path, perspective, quotes, rotate, scale, scrollbarColor, scrollbar-color, shapeOutside, shape-outside, strokeDasharray, stroke-dasharray, strokeDashoffset, stroke-dashoffset, strokeWidth, stroke-width, tabSize, tab-size, textDecorationThickness, text-decoration-thickness, textEmphasisStyle, text-emphasis-style, textOverflow, text-overflow, textShadow, text-shadow, transitionDelay, transition-delay, transitionDuration, transition-duration, transitionProperty, transition-property, transitionTimingFunction, transition-timing-function, translate, verticalAlign, vertical-align, willChange, will-change, wordSpacing, word-spacing, clip, MozImageRegion, -moz-image-region, objectPosition, object-position, perspectiveOrigin, perspective-origin, fill, stroke, transformOrigin, transform-origin, gridTemplateColumns, grid-template-columns, gridTemplateRows, grid-template-rows, borderImageSource, border-image-source, listStyleImage, list-style-image, gridAutoColumns, grid-auto-columns, gridAutoRows, grid-auto-rows, transform, columnGap, column-gap, rowGap, row-gap, markerEnd, marker-end, markerMid, marker-mid, markerStart, marker-start, containIntrinsicBlockSize, contain-intrinsic-block-size, containIntrinsicHeight, contain-intrinsic-height, containIntrinsicInlineSize, contain-intrinsic-inline-size, containIntrinsicWidth, contain-intrinsic-width, gridColumnEnd, grid-column-end, gridColumnStart, grid-column-start, gridRowEnd, grid-row-end, gridRowStart, grid-row-start, maxBlockSize, max-block-size, maxHeight, max-height, maxInlineSize, max-inline-size, maxWidth, max-width, cx, cy, offsetDistance, offset-distance, textIndent, text-indent, x, y, borderBottomLeftRadius, border-bottom-left-radius, borderBottomRightRadius, border-bottom-right-radius, borderEndEndRadius, border-end-end-radius, borderEndStartRadius, border-end-start-radius, borderStartEndRadius, border-start-end-radius, borderStartStartRadius, border-start-start-radius, borderTopLeftRadius, border-top-left-radius, borderTopRightRadius, border-top-right-radius, blockSize, block-size, height, inlineSize, inline-size, minBlockSize, min-block-size, minHeight, min-height, minInlineSize, min-inline-size, minWidth, min-width, width, paddingBlockEnd, padding-block-end, paddingBlockStart, padding-block-start, paddingBottom, padding-bottom, paddingInlineEnd, padding-inline-end, paddingInlineStart, padding-inline-start, paddingLeft, padding-left, paddingRight, padding-right, paddingTop, padding-top, r, shapeMargin, shape-margin, rx, ry, scrollPaddingBlockEnd, scroll-padding-block-end, scrollPaddingBlockStart, scroll-padding-block-start, scrollPaddingBottom, scroll-padding-bottom, scrollPaddingInlineEnd, scroll-padding-inline-end, scrollPaddingInlineStart, scroll-padding-inline-start, scrollPaddingLeft, scroll-padding-left, scrollPaddingRight, scroll-padding-right, scrollPaddingTop, scroll-padding-top, borderBlockEndWidth, border-block-end-width, borderBlockStartWidth, border-block-start-width, borderBottomWidth, border-bottom-width, borderInlineEndWidth, border-inline-end-width, borderInlineStartWidth, border-inline-start-width, borderLeftWidth, border-left-width, borderRightWidth, border-right-width, borderTopWidth, border-top-width, columnRuleWidth, column-rule-width, outlineWidth, outline-width, webkitTextStrokeWidth, WebkitTextStrokeWidth, -webkit-text-stroke-width, outlineOffset, outline-offset, overflowClipMargin, overflow-clip-margin, scrollMarginBlockEnd, scroll-margin-block-end, scrollMarginBlockStart, scroll-margin-block-start, scrollMarginBottom, scroll-margin-bottom, scrollMarginInlineEnd, scroll-margin-inline-end, scrollMarginInlineStart, scroll-margin-inline-start, scrollMarginLeft, scroll-margin-left, scrollMarginRight, scroll-margin-right, scrollMarginTop, scroll-margin-top, bottom, insetBlockEnd, inset-block-end, insetBlockStart, inset-block-start, insetInlineEnd, inset-inline-end, insetInlineStart, inset-inline-start, left, marginBlockEnd, margin-block-end, marginBlockStart, margin-block-start, marginBottom, margin-bottom, marginInlineEnd, margin-inline-end, marginInlineStart, margin-inline-start, marginLeft, margin-left, marginRight, margin-right, marginTop, margin-top, right, textUnderlineOffset, text-underline-offset, top, backgroundColor, background-color, borderBlockEndColor, border-block-end-color, borderBlockStartColor, border-block-start-color, borderBottomColor, border-bottom-color, borderInlineEndColor, border-inline-end-color, borderInlineStartColor, border-inline-start-color, borderLeftColor, border-left-color, borderRightColor, border-right-color, borderTopColor, border-top-color, columnRuleColor, column-rule-color, floodColor, flood-color, lightingColor, lighting-color, outlineColor, outline-color, stopColor, stop-color, textDecorationColor, text-decoration-color, textEmphasisColor, text-emphasis-color, webkitTextFillColor, WebkitTextFillColor, -webkit-text-fill-color, webkitTextStrokeColor, WebkitTextStrokeColor, -webkit-text-stroke-color, background, backgroundPosition, background-position, borderColor, border-color, borderStyle, border-style, borderWidth, border-width, borderTop, border-top, borderRight, border-right, borderBottom, border-bottom, borderLeft, border-left, borderBlockStart, border-block-start, borderBlockEnd, border-block-end, borderInlineStart, border-inline-start, borderInlineEnd, border-inline-end, border, borderRadius, border-radius, borderImage, border-image, borderBlockWidth, border-block-width, borderBlockStyle, border-block-style, borderBlockColor, border-block-color, borderInlineWidth, border-inline-width, borderInlineStyle, border-inline-style, borderInlineColor, border-inline-color, borderBlock, border-block, borderInline, border-inline, overflow, overscrollBehavior, overscroll-behavior, pageBreakBefore, page-break-before, pageBreakAfter, page-break-after, pageBreakInside, page-break-inside, offset, columns, columnRule, column-rule, font, fontVariant, font-variant, marker, textEmphasis, text-emphasis, webkitTextStroke, WebkitTextStroke, -webkit-text-stroke, listStyle, list-style, margin, marginBlock, margin-block, marginInline, margin-inline, scrollMargin, scroll-margin, scrollMarginBlock, scroll-margin-block, scrollMarginInline, scroll-margin-inline, outline, padding, paddingBlock, padding-block, paddingInline, padding-inline, scrollPadding, scroll-padding, scrollPaddingBlock, scroll-padding-block, scrollPaddingInline, scroll-padding-inline, flexFlow, flex-flow, flex, gap, gridRow, grid-row, gridColumn, grid-column, gridArea, grid-area, gridTemplate, grid-template, grid, placeContent, place-content, placeSelf, place-self, placeItems, place-items, inset, insetBlock, inset-block, insetInline, inset-inline, containIntrinsicSize, contain-intrinsic-size, mask, maskPosition, mask-position, textDecoration, text-decoration, transition, animation, all, webkitBackgroundClip, WebkitBackgroundClip, -webkit-background-clip, webkitBackgroundOrigin, WebkitBackgroundOrigin, -webkit-background-origin, webkitBackgroundSize, WebkitBackgroundSize, -webkit-background-size, MozBorderStartColor, -moz-border-start-color, MozBorderStartStyle, -moz-border-start-style, MozBorderStartWidth, -moz-border-start-width, MozBorderEndColor, -moz-border-end-color, MozBorderEndStyle, -moz-border-end-style, MozBorderEndWidth, -moz-border-end-width, webkitBorderTopLeftRadius, WebkitBorderTopLeftRadius, -webkit-border-top-left-radius, webkitBorderTopRightRadius, WebkitBorderTopRightRadius, -webkit-border-top-right-radius, webkitBorderBottomRightRadius, WebkitBorderBottomRightRadius, -webkit-border-bottom-right-radius, webkitBorderBottomLeftRadius, WebkitBorderBottomLeftRadius, -webkit-border-bottom-left-radius, MozTransform, -moz-transform, webkitTransform, WebkitTransform, -webkit-transform, MozPerspective, -moz-perspective, webkitPerspective, WebkitPerspective, -webkit-perspective, MozPerspectiveOrigin, -moz-perspective-origin, webkitPerspectiveOrigin, WebkitPerspectiveOrigin, -webkit-perspective-origin, MozBackfaceVisibility, -moz-backface-visibility, webkitBackfaceVisibility, WebkitBackfaceVisibility, -webkit-backface-visibility, MozTransformStyle, -moz-transform-style, webkitTransformStyle, WebkitTransformStyle, -webkit-transform-style, MozTransformOrigin, -moz-transform-origin, webkitTransformOrigin, WebkitTransformOrigin, -webkit-transform-origin, MozAppearance, -moz-appearance, webkitAppearance, WebkitAppearance, -webkit-appearance, webkitBoxShadow, WebkitBoxShadow, -webkit-box-shadow, webkitFilter, WebkitFilter, -webkit-filter, MozFontFeatureSettings, -moz-font-feature-settings, MozFontLanguageOverride, -moz-font-language-override, colorAdjust, color-adjust, MozHyphens, -moz-hyphens, webkitTextSizeAdjust, WebkitTextSizeAdjust, -webkit-text-size-adjust, wordWrap, word-wrap, MozTabSize, -moz-tab-size, MozMarginStart, -moz-margin-start, MozMarginEnd, -moz-margin-end, MozPaddingStart, -moz-padding-start, MozPaddingEnd, -moz-padding-end, webkitFlexDirection, WebkitFlexDirection, -webkit-flex-direction, webkitFlexWrap, WebkitFlexWrap, -webkit-flex-wrap, webkitJustifyContent, WebkitJustifyContent, -webkit-justify-content, webkitAlignContent, WebkitAlignContent, -webkit-align-content, webkitAlignItems, WebkitAlignItems, -webkit-align-items, webkitFlexGrow, WebkitFlexGrow, -webkit-flex-grow, webkitFlexShrink, WebkitFlexShrink, -webkit-flex-shrink, webkitAlignSelf, WebkitAlignSelf, -webkit-align-self, webkitOrder, WebkitOrder, -webkit-order, webkitFlexBasis, WebkitFlexBasis, -webkit-flex-basis, MozBoxSizing, -moz-box-sizing, webkitBoxSizing, WebkitBoxSizing, -webkit-box-sizing, gridColumnGap, grid-column-gap, gridRowGap, grid-row-gap, webkitMaskRepeat, WebkitMaskRepeat, -webkit-mask-repeat, webkitMaskPositionX, WebkitMaskPositionX, -webkit-mask-position-x, webkitMaskPositionY, WebkitMaskPositionY, -webkit-mask-position-y, webkitMaskClip, WebkitMaskClip, -webkit-mask-clip, webkitMaskOrigin, WebkitMaskOrigin, -webkit-mask-origin, webkitMaskSize, WebkitMaskSize, -webkit-mask-size, webkitMaskComposite, WebkitMaskComposite, -webkit-mask-composite, webkitMaskImage, WebkitMaskImage, -webkit-mask-image, MozUserSelect, -moz-user-select, webkitUserSelect, WebkitUserSelect, -webkit-user-select, MozTransitionDuration, -moz-transition-duration, webkitTransitionDuration, WebkitTransitionDuration, -webkit-transition-duration, MozTransitionTimingFunction, -moz-transition-timing-function, webkitTransitionTimingFunction, WebkitTransitionTimingFunction, -webkit-transition-timing-function, MozTransitionProperty, -moz-transition-property, webkitTransitionProperty, WebkitTransitionProperty, -webkit-transition-property, MozTransitionDelay, -moz-transition-delay, webkitTransitionDelay, WebkitTransitionDelay, -webkit-transition-delay, MozAnimationName, -moz-animation-name, webkitAnimationName, WebkitAnimationName, -webkit-animation-name, MozAnimationDuration, -moz-animation-duration, webkitAnimationDuration, WebkitAnimationDuration, -webkit-animation-duration, MozAnimationTimingFunction, -moz-animation-timing-function, webkitAnimationTimingFunction, WebkitAnimationTimingFunction, -webkit-animation-timing-function, MozAnimationIterationCount, -moz-animation-iteration-count, webkitAnimationIterationCount, WebkitAnimationIterationCount, -webkit-animation-iteration-count, MozAnimationDirection, -moz-animation-direction, webkitAnimationDirection, WebkitAnimationDirection, -webkit-animation-direction, MozAnimationPlayState, -moz-animation-play-state, webkitAnimationPlayState, WebkitAnimationPlayState, -webkit-animation-play-state, MozAnimationFillMode, -moz-animation-fill-mode, webkitAnimationFillMode, WebkitAnimationFillMode, -webkit-animation-fill-mode, MozAnimationDelay, -moz-animation-delay, webkitAnimationDelay, WebkitAnimationDelay, -webkit-animation-delay, webkitBoxAlign, WebkitBoxAlign, -webkit-box-align, webkitBoxDirection, WebkitBoxDirection, -webkit-box-direction, webkitBoxFlex, WebkitBoxFlex, -webkit-box-flex, webkitBoxOrient, WebkitBoxOrient, -webkit-box-orient, webkitBoxPack, WebkitBoxPack, -webkit-box-pack, webkitBoxOrdinalGroup, WebkitBoxOrdinalGroup, -webkit-box-ordinal-group, MozBorderStart, -moz-border-start, MozBorderEnd, -moz-border-end, webkitBorderRadius, WebkitBorderRadius, -webkit-border-radius, MozBorderImage, -moz-border-image, webkitBorderImage, WebkitBorderImage, -webkit-border-image, webkitFlexFlow, WebkitFlexFlow, -webkit-flex-flow, webkitFlex, WebkitFlex, -webkit-flex, gridGap, grid-gap, webkitMask, WebkitMask, -webkit-mask, webkitMaskPosition, WebkitMaskPosition, -webkit-mask-position, MozTransition, -moz-transition, webkitTransition, WebkitTransition, -webkit-transition, MozAnimation, -moz-animation, webkitAnimation, WebkitAnimation, -webkit-animation, constructor`,
        jsKeys: 'Object.assign, Object.getPrototypeOf, Object.setPrototypeOf, Object.getOwnPropertyDescriptor, Object.getOwnPropertyDescriptors, Object.keys, Object.values, Object.entries, Object.is, Object.defineProperty, Object.defineProperties, Object.create, Object.getOwnPropertyNames, Object.getOwnPropertySymbols, Object.isExtensible, Object.preventExtensions, Object.freeze, Object.isFrozen, Object.seal, Object.isSealed, Object.fromEntries, Object.hasOwn, Object.toString, Object.toLocaleString, Object.valueOf, Object.hasOwnProperty, Object.isPrototypeOf, Object.propertyIsEnumerable, Object.__defineGetter__, Object.__defineSetter__, Object.__lookupGetter__, Object.__lookupSetter__, Object.__proto__, Function.toString, Function.apply, Function.call, Function.bind, Boolean.toString, Boolean.valueOf, Symbol.for, Symbol.keyFor, Symbol.isConcatSpreadable, Symbol.iterator, Symbol.match, Symbol.replace, Symbol.search, Symbol.species, Symbol.hasInstance, Symbol.split, Symbol.toPrimitive, Symbol.toStringTag, Symbol.unscopables, Symbol.asyncIterator, Symbol.matchAll, Symbol.toString, Symbol.valueOf, Symbol.description, Error.toString, Error.message, Error.stack, Number.isFinite, Number.isInteger, Number.isNaN, Number.isSafeInteger, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.MAX_VALUE, Number.MIN_VALUE, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.EPSILON, Number.parseInt, Number.parseFloat, Number.NaN, Number.toString, Number.toLocaleString, Number.valueOf, Number.toFixed, Number.toExponential, Number.toPrecision, BigInt.asUintN, BigInt.asIntN, BigInt.valueOf, BigInt.toString, BigInt.toLocaleString, Math.abs, Math.acos, Math.asin, Math.atan, Math.atan2, Math.ceil, Math.clz32, Math.cos, Math.exp, Math.floor, Math.imul, Math.fround, Math.log, Math.max, Math.min, Math.pow, Math.random, Math.round, Math.sin, Math.sqrt, Math.tan, Math.log10, Math.log2, Math.log1p, Math.expm1, Math.cosh, Math.sinh, Math.tanh, Math.acosh, Math.asinh, Math.atanh, Math.hypot, Math.trunc, Math.sign, Math.cbrt, Math.E, Math.LOG2E, Math.LOG10E, Math.LN2, Math.LN10, Math.PI, Math.SQRT2, Math.SQRT1_2, Date.UTC, Date.parse, Date.now, Date.getTime, Date.getTimezoneOffset, Date.getYear, Date.getFullYear, Date.getUTCFullYear, Date.getMonth, Date.getUTCMonth, Date.getDate, Date.getUTCDate, Date.getDay, Date.getUTCDay, Date.getHours, Date.getUTCHours, Date.getMinutes, Date.getUTCMinutes, Date.getSeconds, Date.getUTCSeconds, Date.getMilliseconds, Date.getUTCMilliseconds, Date.setTime, Date.setYear, Date.setFullYear, Date.setUTCFullYear, Date.setMonth, Date.setUTCMonth, Date.setDate, Date.setUTCDate, Date.setHours, Date.setUTCHours, Date.setMinutes, Date.setUTCMinutes, Date.setSeconds, Date.setUTCSeconds, Date.setMilliseconds, Date.setUTCMilliseconds, Date.toUTCString, Date.toLocaleString, Date.toLocaleDateString, Date.toLocaleTimeString, Date.toDateString, Date.toTimeString, Date.toISOString, Date.toJSON, Date.toString, Date.valueOf, Date.toGMTString, String.fromCharCode, String.fromCodePoint, String.raw, String.toString, String.valueOf, String.toLowerCase, String.toUpperCase, String.charAt, String.charCodeAt, String.substring, String.padStart, String.padEnd, String.codePointAt, String.includes, String.indexOf, String.lastIndexOf, String.startsWith, String.endsWith, String.trim, String.trimStart, String.trimEnd, String.toLocaleLowerCase, String.toLocaleUpperCase, String.localeCompare, String.repeat, String.normalize, String.match, String.matchAll, String.search, String.replace, String.replaceAll, String.split, String.substr, String.concat, String.slice, String.at, String.bold, String.italics, String.fixed, String.strike, String.small, String.big, String.blink, String.sup, String.sub, String.anchor, String.link, String.fontcolor, String.fontsize, String.trimLeft, String.trimRight, RegExp.input, RegExp.lastMatch, RegExp.lastParen, RegExp.leftContext, RegExp.rightContext, RegExp.$1, RegExp.$2, RegExp.$3, RegExp.$4, RegExp.$5, RegExp.$6, RegExp.$7, RegExp.$8, RegExp.$9, RegExp.$_, RegExp.$&, RegExp.$+, RegExp.$`, RegExp.$\', RegExp.toString, RegExp.compile, RegExp.exec, RegExp.test, RegExp.flags, RegExp.hasIndices, RegExp.global, RegExp.ignoreCase, RegExp.multiline, RegExp.dotAll, RegExp.source, RegExp.sticky, RegExp.unicode, Array.isArray, Array.from, Array.of, Array.toString, Array.toLocaleString, Array.join, Array.reverse, Array.sort, Array.push, Array.pop, Array.shift, Array.unshift, Array.splice, Array.concat, Array.slice, Array.lastIndexOf, Array.indexOf, Array.forEach, Array.map, Array.filter, Array.reduce, Array.reduceRight, Array.some, Array.every, Array.find, Array.findIndex, Array.copyWithin, Array.fill, Array.entries, Array.keys, Array.values, Array.includes, Array.flatMap, Array.flat, Array.at, Array.findLast, Array.findLastIndex, Map.get, Map.has, Map.set, Map.delete, Map.keys, Map.values, Map.clear, Map.forEach, Map.entries, Map.size, Set.has, Set.add, Set.delete, Set.entries, Set.clear, Set.forEach, Set.values, Set.keys, Set.size, WeakMap.has, WeakMap.get, WeakMap.delete, WeakMap.set, WeakSet.add, WeakSet.delete, WeakSet.has, Atomics.compareExchange, Atomics.load, Atomics.store, Atomics.exchange, Atomics.add, Atomics.sub, Atomics.and, Atomics.or, Atomics.xor, Atomics.isLockFree, Atomics.wait, Atomics.notify, Atomics.wake, JSON.parse, JSON.stringify, Promise.all, Promise.allSettled, Promise.any, Promise.race, Promise.reject, Promise.resolve, Promise.then, Promise.catch, Promise.finally, Reflect.apply, Reflect.construct, Reflect.defineProperty, Reflect.deleteProperty, Reflect.get, Reflect.getOwnPropertyDescriptor, Reflect.getPrototypeOf, Reflect.has, Reflect.isExtensible, Reflect.ownKeys, Reflect.preventExtensions, Reflect.set, Reflect.setPrototypeOf, Proxy.revocable, Intl.getCanonicalLocales, Intl.supportedValuesOf, Intl.Collator, Intl.DateTimeFormat, Intl.DisplayNames, Intl.ListFormat, Intl.Locale, Intl.NumberFormat, Intl.PluralRules, Intl.RelativeTimeFormat, WebAssembly.compile, WebAssembly.instantiate, WebAssembly.validate, WebAssembly.compileStreaming, WebAssembly.instantiateStreaming, WebAssembly.Module, WebAssembly.Instance, WebAssembly.Memory, WebAssembly.Table, WebAssembly.Global, WebAssembly.CompileError, WebAssembly.LinkError, WebAssembly.RuntimeError, WebAssembly.Tag, WebAssembly.Exception, Document.getElementsByTagName, Document.getElementsByTagNameNS, Document.getElementsByClassName, Document.getElementById, Document.createElement, Document.createElementNS, Document.createDocumentFragment, Document.createTextNode, Document.createComment, Document.createProcessingInstruction, Document.importNode, Document.adoptNode, Document.createEvent, Document.createRange, Document.createNodeIterator, Document.createTreeWalker, Document.createCDATASection, Document.createAttribute, Document.createAttributeNS, Document.getElementsByName, Document.open, Document.close, Document.write, Document.writeln, Document.hasFocus, Document.execCommand, Document.queryCommandEnabled, Document.queryCommandIndeterm, Document.queryCommandState, Document.queryCommandSupported, Document.queryCommandValue, Document.releaseCapture, Document.mozSetImageElement, Document.clear, Document.captureEvents, Document.releaseEvents, Document.exitFullscreen, Document.mozCancelFullScreen, Document.exitPointerLock, Document.enableStyleSheetsForSet, Document.caretPositionFromPoint, Document.querySelector, Document.querySelectorAll, Document.getSelection, Document.hasStorageAccess, Document.requestStorageAccess, Document.elementFromPoint, Document.elementsFromPoint, Document.getAnimations, Document.prepend, Document.append, Document.replaceChildren, Document.createExpression, Document.createNSResolver, Document.evaluate, Document.implementation, Document.URL, Document.documentURI, Document.compatMode, Document.characterSet, Document.charset, Document.inputEncoding, Document.contentType, Document.doctype, Document.documentElement, Document.domain, Document.referrer, Document.cookie, Document.lastModified, Document.readyState, Document.title, Document.dir, Document.body, Document.head, Document.images, Document.embeds, Document.plugins, Document.links, Document.forms, Document.scripts, Document.defaultView, Document.designMode, Document.onreadystatechange, Document.onbeforescriptexecute, Document.onafterscriptexecute, Document.currentScript, Document.fgColor, Document.linkColor, Document.vlinkColor, Document.alinkColor, Document.bgColor, Document.anchors, Document.applets, Document.all, Document.fullscreen, Document.mozFullScreen, Document.fullscreenEnabled, Document.mozFullScreenEnabled, Document.onfullscreenchange, Document.onfullscreenerror, Document.onpointerlockchange, Document.onpointerlockerror, Document.hidden, Document.visibilityState, Document.onvisibilitychange, Document.selectedStyleSheetSet, Document.lastStyleSheetSet, Document.preferredStyleSheetSet, Document.styleSheetSets, Document.scrollingElement, Document.timeline, Document.rootElement, Document.oncopy, Document.oncut, Document.onpaste, Document.activeElement, Document.styleSheets, Document.pointerLockElement, Document.fullscreenElement, Document.mozFullScreenElement, Document.adoptedStyleSheets, Document.fonts, Document.onabort, Document.onblur, Document.onfocus, Document.onauxclick, Document.onbeforeinput, Document.oncanplay, Document.oncanplaythrough, Document.onchange, Document.onclick, Document.onclose, Document.oncontextmenu, Document.oncuechange, Document.ondblclick, Document.ondrag, Document.ondragend, Document.ondragenter, Document.ondragexit, Document.ondragleave, Document.ondragover, Document.ondragstart, Document.ondrop, Document.ondurationchange, Document.onemptied, Document.onended, Document.onformdata, Document.oninput, Document.oninvalid, Document.onkeydown, Document.onkeypress, Document.onkeyup, Document.onload, Document.onloadeddata, Document.onloadedmetadata, Document.onloadstart, Document.onmousedown, Document.onmouseenter, Document.onmouseleave, Document.onmousemove, Document.onmouseout, Document.onmouseover, Document.onmouseup, Document.onwheel, Document.onpause, Document.onplay, Document.onplaying, Document.onprogress, Document.onratechange, Document.onreset, Document.onresize, Document.onscroll, Document.onsecuritypolicyviolation, Document.onseeked, Document.onseeking, Document.onselect, Document.onslotchange, Document.onstalled, Document.onsubmit, Document.onsuspend, Document.ontimeupdate, Document.onvolumechange, Document.onwaiting, Document.onselectstart, Document.onselectionchange, Document.ontoggle, Document.onpointercancel, Document.onpointerdown, Document.onpointerup, Document.onpointermove, Document.onpointerout, Document.onpointerover, Document.onpointerenter, Document.onpointerleave, Document.ongotpointercapture, Document.onlostpointercapture, Document.onmozfullscreenchange, Document.onmozfullscreenerror, Document.onanimationcancel, Document.onanimationend, Document.onanimationiteration, Document.onanimationstart, Document.ontransitioncancel, Document.ontransitionend, Document.ontransitionrun, Document.ontransitionstart, Document.onwebkitanimationend, Document.onwebkitanimationiteration, Document.onwebkitanimationstart, Document.onwebkittransitionend, Document.onerror, Document.children, Document.firstElementChild, Document.lastElementChild, Document.childElementCount, Element.getAttributeNames, Element.getAttribute, Element.getAttributeNS, Element.toggleAttribute, Element.setAttribute, Element.setAttributeNS, Element.removeAttribute, Element.removeAttributeNS, Element.hasAttribute, Element.hasAttributeNS, Element.hasAttributes, Element.closest, Element.matches, Element.webkitMatchesSelector, Element.getElementsByTagName, Element.getElementsByTagNameNS, Element.getElementsByClassName, Element.insertAdjacentElement, Element.insertAdjacentText, Element.mozMatchesSelector, Element.setPointerCapture, Element.releasePointerCapture, Element.hasPointerCapture, Element.setCapture, Element.releaseCapture, Element.getAttributeNode, Element.setAttributeNode, Element.removeAttributeNode, Element.getAttributeNodeNS, Element.setAttributeNodeNS, Element.getClientRects, Element.getBoundingClientRect, Element.checkVisibility, Element.scrollIntoView, Element.scroll, Element.scrollTo, Element.scrollBy, Element.insertAdjacentHTML, Element.querySelector, Element.querySelectorAll, Element.attachShadow, Element.requestFullscreen, Element.mozRequestFullScreen, Element.requestPointerLock, Element.animate, Element.getAnimations, Element.before, Element.after, Element.replaceWith, Element.remove, Element.prepend, Element.append, Element.replaceChildren, Element.namespaceURI, Element.prefix, Element.localName, Element.tagName, Element.id, Element.className, Element.classList, Element.part, Element.attributes, Element.scrollTop, Element.scrollLeft, Element.scrollWidth, Element.scrollHeight, Element.clientTop, Element.clientLeft, Element.clientWidth, Element.clientHeight, Element.scrollTopMax, Element.scrollLeftMax, Element.innerHTML, Element.outerHTML, Element.shadowRoot, Element.assignedSlot, Element.slot, Element.onfullscreenchange, Element.onfullscreenerror, Element.previousElementSibling, Element.nextElementSibling, Element.children, Element.firstElementChild, Element.lastElementChild, Element.childElementCount',
    },
});
const BROWSER = (IS_BLINK ? 'Chrome' : IS_GECKO ? 'Firefox' : '');
const getEngineMaps = (browser) => {
    const geckoCSS = {
        '71': ['-moz-column-span'],
        '72': ['offset', 'offset-anchor', 'offset-distance', 'offset-path', 'offset-rotate', 'rotate', 'scale', 'translate'],
        '73': ['overscroll-behavior-block', 'overscroll-behavior-inline'],
        '74-79': ['!-moz-stack-sizing', 'text-underline-position'],
        '80-88': ['appearance'],
        '89-90': ['!-moz-outline-radius', '!-moz-outline-radius-bottomleft', '!-moz-outline-radius-bottomright', '!-moz-outline-radius-topleft', '!-moz-outline-radius-topright', 'aspect-ratio'],
        '91': ['tab-size'],
        '92-95': ['accent-color'],
        '96': ['color-scheme'],
        '97': ['print-color-adjust', 'scrollbar-gutter', 'd'],
        '98-101': ['hyphenate-character'],
        '102': ['overflow-clip-margin'],
        '103-106': ['scroll-snap-stop'],
        '107-108': ['backdrop-filter', 'font-palette', 'contain-intrinsic-block-size', 'contain-intrinsic-height', 'contain-intrinsic-inline-size', 'contain-intrinsic-width', 'contain-intrinsic-size'],
    };
    const blinkCSS = {
        '76': ['backdrop-filter'],
        '77-80': ['overscroll-behavior-block', 'overscroll-behavior-inline'],
        '81': ['color-scheme', 'image-orientation'],
        '83': ['contain-intrinsic-size'],
        '84': ['appearance', 'ruby-position'],
        '85-86': ['content-visibility', 'counter-set', 'inherits', 'initial-value', 'page-orientation', 'syntax'],
        '87': ['ascent-override', 'border-block', 'border-block-color', 'border-block-style', 'border-block-width', 'border-inline', 'border-inline-color', 'border-inline-style', 'border-inline-width', 'descent-override', 'inset', 'inset-block', 'inset-block-end', 'inset-block-start', 'inset-inline', 'inset-inline-end', 'inset-inline-start', 'line-gap-override', 'margin-block', 'margin-inline', 'padding-block', 'padding-inline', 'text-decoration-thickness', 'text-underline-offset'],
        '88': ['aspect-ratio'],
        '89': ['border-end-end-radius', 'border-end-start-radius', 'border-start-end-radius', 'border-start-start-radius', 'forced-color-adjust'],
        '90': ['overflow-clip-margin'],
        '91': ['additive-symbols', 'fallback', 'negative', 'pad', 'prefix', 'range', 'speak-as', 'suffix', 'symbols', 'system'],
        '92': ['size-adjust'],
        '93': ['accent-color'],
        '94': ['scrollbar-gutter'],
        '95-96': ['app-region', 'contain-intrinsic-block-size', 'contain-intrinsic-height', 'contain-intrinsic-inline-size', 'contain-intrinsic-width'],
        '97-98': ['font-synthesis-small-caps', 'font-synthesis-style', 'font-synthesis-weight', 'font-synthesis'],
        '99-100': ['text-emphasis-color', 'text-emphasis-position', 'text-emphasis-style', 'text-emphasis'],
        '101-103': ['font-palette', 'base-palette', 'override-colors'],
        '104': ['object-view-box'],
        '105': ['container-name', 'container-type', 'container'],
        '106-107': ['hyphenate-character'],
        '108': ['hyphenate-character', '!orientation', '!max-zoom', '!min-zoom', '!user-zoom'],
        '109': ['hyphenate-limit-chars', 'math-depth', 'math-shift', 'math-style'],
    };
    const geckoWindow = {
        // disregard: 'reportError','onsecuritypolicyviolation','onslotchange'
        '71': ['MathMLElement', '!SVGZoomAndPan'],
        '72-73': ['!BatteryManager', 'FormDataEvent', 'Geolocation', 'GeolocationCoordinates', 'GeolocationPosition', 'GeolocationPositionError', '!mozPaintCount'],
        '74': ['FormDataEvent', '!uneval'],
        '75': ['AnimationTimeline', 'CSSAnimation', 'CSSTransition', 'DocumentTimeline', 'SubmitEvent'],
        '76-77': ['AudioParamMap', 'AudioWorklet', 'AudioWorkletNode', 'Worklet'],
        '78': ['Atomics'],
        '79-81': ['AggregateError', 'FinalizationRegistry'],
        '82': ['MediaMetadata', 'MediaSession', 'Sanitizer'],
        '83': ['MediaMetadata', 'MediaSession', '!Sanitizer'],
        '84': ['PerformancePaintTiming'],
        '85-86': ['PerformancePaintTiming', '!HTMLMenuItemElement', '!onshow'],
        '87': ['onbeforeinput'],
        '88': ['onbeforeinput', '!VisualViewport'],
        '89-92': ['!ondevicelight', '!ondeviceproximity', '!onuserproximity'],
        '93-95': ['ElementInternals'],
        '96': ['Lock', 'LockManager'],
        '97': ['CSSLayerBlockRule', 'CSSLayerStatementRule'],
        '98': ['HTMLDialogElement'],
        '99': ['NavigationPreloadManager'],
        '100-104': ['WritableStream'],
        '105-106': ['TextDecoderStream', 'OffscreenCanvasRenderingContext2D', 'OffscreenCanvas', 'TextEncoderStream'],
        '107-108': ['CSSFontPaletteValuesRule'],
    };
    const blinkWindow = {
        // disregard: EyeDropper
        '80': ['CompressionStream', 'DecompressionStream', 'FeaturePolicy', 'FragmentDirective', 'PeriodicSyncManager', 'VideoPlaybackQuality'],
        '81': ['SubmitEvent', 'XRHitTestResult', 'XRHitTestSource', 'XRRay', 'XRTransientInputHitTestResult', 'XRTransientInputHitTestSource'],
        '83': ['BarcodeDetector', 'XRDOMOverlayState', 'XRSystem'],
        '84': ['AnimationPlaybackEvent', 'AnimationTimeline', 'CSSAnimation', 'CSSTransition', 'DocumentTimeline', 'FinalizationRegistry', 'LayoutShiftAttribution', 'ResizeObserverSize', 'WakeLock', 'WakeLockSentinel', 'WeakRef', 'XRLayer'],
        '85': ['AggregateError', 'CSSPropertyRule', 'EventCounts', 'XRAnchor', 'XRAnchorSet'],
        '86': ['RTCEncodedAudioFrame', 'RTCEncodedVideoFrame'],
        '87': ['CookieChangeEvent', 'CookieStore', 'CookieStoreManager', 'Scheduling'],
        '88': ['Scheduling', '!BarcodeDetector'],
        '89': ['ReadableByteStreamController', 'ReadableStreamBYOBReader', 'ReadableStreamBYOBRequest', 'ReadableStreamDefaultController', 'XRWebGLBinding'],
        '90': ['AbstractRange', 'CustomStateSet', 'NavigatorUAData', 'XRCPUDepthInformation', 'XRDepthInformation', 'XRLightEstimate', 'XRLightProbe', 'XRWebGLDepthInformation'],
        '91': ['CSSCounterStyleRule', 'GravitySensor', 'NavigatorManagedData'],
        '92': ['CSSCounterStyleRule', '!SharedArrayBuffer'],
        '93': ['WritableStreamDefaultController'],
        '94': ['AudioData', 'AudioDecoder', 'AudioEncoder', 'EncodedAudioChunk', 'EncodedVideoChunk', 'IdleDetector', 'ImageDecoder', 'ImageTrack', 'ImageTrackList', 'VideoColorSpace', 'VideoDecoder', 'VideoEncoder', 'VideoFrame', 'MediaStreamTrackGenerator', 'MediaStreamTrackProcessor', 'Profiler', 'VirtualKeyboard', 'DelegatedInkTrailPresenter', 'Ink', 'Scheduler', 'TaskController', 'TaskPriorityChangeEvent', 'TaskSignal', 'VirtualKeyboardGeometryChangeEvent'],
        '95-96': ['URLPattern'],
        '97-98': ['WebTransport', 'WebTransportBidirectionalStream', 'WebTransportDatagramDuplexStream', 'WebTransportError'],
        '99': ['CanvasFilter', 'CSSLayerBlockRule', 'CSSLayerStatementRule'],
        '100': ['CSSMathClamp'],
        '101-104': ['CSSFontPaletteValuesRule'],
        '105-106': ['CSSContainerRule'],
        '107-108': ['XRCamera'],
        '109': ['MathMLElement'],
    };
    const blinkJS = {
        '76': ['Document.onsecuritypolicyviolation', 'Promise.allSettled'],
        '77': ['Document.onformdata', 'Document.onpointerrawupdate'],
        '78': ['Element.elementTiming'],
        '79': ['Document.onanimationend', 'Document.onanimationiteration', 'Document.onanimationstart', 'Document.ontransitionend'],
        '80': ['!Document.registerElement', '!Element.createShadowRoot', '!Element.getDestinationInsertionPoints'],
        '81': ['Document.onwebkitanimationend', 'Document.onwebkitanimationiteration', 'Document.onwebkitanimationstart', 'Document.onwebkittransitionend', 'Element.ariaAtomic', 'Element.ariaAutoComplete', 'Element.ariaBusy', 'Element.ariaChecked', 'Element.ariaColCount', 'Element.ariaColIndex', 'Element.ariaColSpan', 'Element.ariaCurrent', 'Element.ariaDisabled', 'Element.ariaExpanded', 'Element.ariaHasPopup', 'Element.ariaHidden', 'Element.ariaKeyShortcuts', 'Element.ariaLabel', 'Element.ariaLevel', 'Element.ariaLive', 'Element.ariaModal', 'Element.ariaMultiLine', 'Element.ariaMultiSelectable', 'Element.ariaOrientation', 'Element.ariaPlaceholder', 'Element.ariaPosInSet', 'Element.ariaPressed', 'Element.ariaReadOnly', 'Element.ariaRelevant', 'Element.ariaRequired', 'Element.ariaRoleDescription', 'Element.ariaRowCount', 'Element.ariaRowIndex', 'Element.ariaRowSpan', 'Element.ariaSelected', 'Element.ariaSort', 'Element.ariaValueMax', 'Element.ariaValueMin', 'Element.ariaValueNow', 'Element.ariaValueText', 'Intl.DisplayNames'],
        '83': ['Element.ariaDescription', 'Element.onbeforexrselect'],
        '84': ['Document.getAnimations', 'Document.timeline', 'Element.ariaSetSize', 'Element.getAnimations'],
        '85': ['Promise.any', 'String.replaceAll'],
        '86': ['Document.fragmentDirective', 'Document.replaceChildren', 'Element.replaceChildren', '!Atomics.wake'],
        '87-89': ['Atomics.waitAsync', 'Document.ontransitioncancel', 'Document.ontransitionrun', 'Document.ontransitionstart', 'Intl.Segmenter'],
        '90': ['Document.onbeforexrselect', 'RegExp.hasIndices', '!Element.onbeforexrselect'],
        '91': ['Element.getInnerHTML'],
        '92': ['Array.at', 'String.at'],
        '93': ['Error.cause', 'Object.hasOwn'],
        '94': ['!Error.cause', 'Object.hasOwn'],
        '95-96': ['WebAssembly.Exception', 'WebAssembly.Tag'],
        '97-98': ['Array.findLast', 'Array.findLastIndex', 'Document.onslotchange'],
        '99-101': ['Intl.supportedValuesOf', 'Document.oncontextlost', 'Document.oncontextrestored'],
        '102': ['Element.ariaInvalid', 'Document.onbeforematch'],
        '103-106': ['Element.role'],
        '107-109': ['Element.ariaBrailleLabel', 'Element.ariaBrailleRoleDescription'],
    };
    const geckoJS = {
        '71': ['Promise.allSettled'],
        '72-73': ['Document.onformdata', 'Element.part'],
        '74': ['!Array.toSource', '!Boolean.toSource', '!Date.toSource', '!Error.toSource', '!Function.toSource', '!Intl.toSource', '!JSON.toSource', '!Math.toSource', '!Number.toSource', '!Object.toSource', '!RegExp.toSource', '!String.toSource', '!WebAssembly.toSource'],
        '75-76': ['Document.getAnimations', 'Document.timeline', 'Element.getAnimations', 'Intl.Locale'],
        '77': ['String.replaceAll'],
        '78': ['Atomics.add', 'Atomics.and', 'Atomics.compareExchange', 'Atomics.exchange', 'Atomics.isLockFree', 'Atomics.load', 'Atomics.notify', 'Atomics.or', 'Atomics.store', 'Atomics.sub', 'Atomics.wait', 'Atomics.wake', 'Atomics.xor', 'Document.replaceChildren', 'Element.replaceChildren', 'Intl.ListFormat', 'RegExp.dotAll'],
        '79-84': ['Promise.any'],
        '85': ['!Document.onshow', 'Promise.any'],
        '86': ['Intl.DisplayNames'],
        '87': ['Document.onbeforeinput'],
        '88-89': ['RegExp.hasIndices'],
        '90-91': ['Array.at', 'String.at'],
        '92': ['Object.hasOwn'],
        '93-99': ['Intl.supportedValuesOf', 'Document.onsecuritypolicyviolation', 'Document.onslotchange'],
        '100': ['WebAssembly.Tag', 'WebAssembly.Exception'],
        '101-103': ['Document.adoptedStyleSheets'],
        '104-108': ['Array.findLast', 'Array.findLastIndex'],
    };
    const IS_BLINK = browser == 'Chrome';
    const IS_GECKO = browser == 'Firefox';
    const css = (IS_BLINK ? blinkCSS : IS_GECKO ? geckoCSS : {});
    const win = (IS_BLINK ? blinkWindow : IS_GECKO ? geckoWindow : {});
    const js = (IS_BLINK ? blinkJS : IS_GECKO ? geckoJS : {});
    return {
        css,
        win,
        js,
    };
};
const getJSCoreFeatures = (win) => {
    const globalObjects = [
        'Object',
        'Function',
        'Boolean',
        'Symbol',
        'Error',
        'Number',
        'BigInt',
        'Math',
        'Date',
        'String',
        'RegExp',
        'Array',
        'Map',
        'Set',
        'WeakMap',
        'WeakSet',
        'Atomics',
        'JSON',
        'Promise',
        'Reflect',
        'Proxy',
        'Intl',
        'WebAssembly',
        'Document',
        'Element',
    ];
    try {
        // @ts-ignore
        const features = globalObjects.reduce((acc, name) => {
            const ignore = ['name', 'length', 'constructor', 'prototype', 'arguments', 'caller'];
            const descriptorKeys = Object.keys(Object.getOwnPropertyDescriptors(win[name] || {}));
            const descriptorProtoKeys = Object.keys(Object.getOwnPropertyDescriptors((win[name] || {}).prototype || {}));
            const uniques = [...new Set([...descriptorKeys, ...descriptorProtoKeys].filter((key) => !ignore.includes(key)))];
            const keys = uniques.map((key) => `${name}.${key}`);
            return [...acc, ...keys];
        }, []);
        return features;
    }
    catch (error) {
        console.error(error);
        return [];
    }
};
// @ts-ignore
const versionSort = (x) => x.sort((a, b) => /\d+/.exec(a)[0] - /\d+/.exec(b)[0]).reverse();
const getVersionLie = (vReport, version, forgivenessOffset = 0) => {
    const stable = getStableFeatures();
    const { version: maxVersion } = stable[BROWSER] || {};
    const validMetrics = vReport && version;
    if (!validMetrics) {
        return {};
    }
    const [vStart, vEnd] = version ? version.split('-') : [];
    const vMax = (vEnd || vStart);
    const reportIsTooHigh = +vReport > (+vMax + forgivenessOffset);
    const reportIsTooLow = +vReport < (+vStart - forgivenessOffset);
    const reportIsOff = (reportIsTooHigh || reportIsTooLow);
    const versionIsAboveMax = ((+vMax == maxVersion) &&
        (+vReport > maxVersion));
    const liedVersion = !versionIsAboveMax && reportIsOff;
    const distance = !liedVersion ? 0 : (Math.abs(vReport - (reportIsTooLow ? vStart : vMax)));
    return { liedVersion, distance };
};
async function getEngineFeatures({ cssComputed, navigatorComputed, windowFeaturesComputed, }) {
    try {
        const timer = createTimer();
        await queueEvent(timer);
        const win = PHANTOM_DARKNESS ? PHANTOM_DARKNESS : window;
        if (!cssComputed || !windowFeaturesComputed) {
            logTestResult({ test: 'features', passed: false });
            return;
        }
        const jsFeaturesKeys = getJSCoreFeatures(win);
        const { keys: computedStyleKeys } = cssComputed.computedStyle || {};
        const { keys: windowFeaturesKeys } = windowFeaturesComputed || {};
        const { userAgentParsed: decryptedName } = navigatorComputed || {};
        const isNative = (win, x) => (/\[native code\]/.test(win[x] + '') &&
            'prototype' in win[x] &&
            win[x].prototype.constructor.name === x);
        // @ts-ignore
        const getFeatures = ({ context, allKeys, engineMap, checkNative = false } = {}) => {
            const allKeysSet = new Set(allKeys);
            const features = new Set();
            // @ts-ignore
            const match = Object.keys(engineMap || {}).reduce((acc, key) => {
                const version = engineMap[key];
                const versionLen = version.length;
                const featureLen = version.filter((prop) => {
                    const removedFromVersion = prop.charAt(0) == '!';
                    if (removedFromVersion) {
                        const propName = prop.slice(1);
                        return !allKeysSet.has(propName) && features.add(prop);
                    }
                    return (allKeysSet.has(prop) &&
                        (checkNative ? isNative(context, prop) : true) &&
                        features.add(prop));
                }).length;
                return versionLen == featureLen ? [...acc, key] : acc;
            }, []);
            const version = versionSort(match)[0];
            return {
                version,
                features,
            };
        };
        // engine maps
        const { css: engineMapCSS, win: engineMapWindow, js: engineMapJS, } = getEngineMaps(BROWSER);
        // css version
        const { version: cssVersion, features: cssFeatures, } = getFeatures({
            context: win,
            allKeys: computedStyleKeys,
            engineMap: engineMapCSS,
        });
        // window version
        const { version: windowVersion, features: windowFeatures, } = getFeatures({
            context: win,
            allKeys: windowFeaturesKeys,
            engineMap: engineMapWindow,
            checkNative: true,
        });
        // js version
        const { version: jsVersion, features: jsFeatures, } = getFeatures({
            context: win,
            allKeys: jsFeaturesKeys,
            engineMap: engineMapJS,
        });
        // determine version based on 3 factors
        const getVersionFromRange = (range, versionCollection) => {
            const exactVersion = versionCollection.find((version) => version && !/-/.test(version));
            if (exactVersion) {
                return exactVersion;
            }
            const len = range.length;
            const first = range[0];
            const last = range[len - 1];
            return (!len ? '' :
                len == 1 ? first :
                    `${last}-${first}`);
        };
        const versionSet = new Set([
            cssVersion,
            windowVersion,
            jsVersion,
        ]);
        versionSet.delete(undefined);
        const versionRange = versionSort([...versionSet].reduce((acc, x) => [...acc, ...x.split('-')], []));
        const version = getVersionFromRange(versionRange, [cssVersion, windowVersion, jsVersion]);
        const vReport = (/\d+/.exec(decryptedName) || [])[0];
        const { liedVersion: liedCSS, distance: distanceCSS, } = getVersionLie(vReport, cssVersion);
        const { liedVersion: liedJS, distance: distanceJS, } = getVersionLie(vReport, jsVersion);
        const { liedVersion: liedWindow, distance: distanceWindow, } = getVersionLie(vReport, windowVersion);
        if (liedCSS) {
            sendToTrash('userAgent', `v${vReport} failed v${cssVersion} CSS features`);
            if (distanceCSS > 1) {
                documentLie(`Navigator.userAgent`, `v${vReport} failed CSS features by ${distanceCSS} versions`);
            }
        }
        if (liedJS) {
            sendToTrash('userAgent', `v${vReport} failed v${jsVersion} JS features`);
            if (distanceJS > 2) {
                documentLie(`Navigator.userAgent`, `v${vReport} failed JS features by ${distanceJS} versions`);
            }
        }
        if (liedWindow) {
            sendToTrash('userAgent', `v${vReport} failed v${windowVersion} Window features`);
            if (distanceWindow > 3) {
                documentLie(`Navigator.userAgent`, `v${vReport} failed Window features by ${distanceWindow} versions`);
            }
        }
        logTestResult({ time: timer.stop(), test: 'features', passed: true });
        return {
            versionRange,
            version,
            cssVersion,
            windowVersion,
            jsVersion,
            cssFeatures: [...cssFeatures],
            windowFeatures: [...windowFeatures],
            jsFeatures: [...jsFeatures],
            jsFeaturesKeys,
        };
    }
    catch (error) {
        logTestResult({ test: 'features', passed: false });
        captureError(error);
        return;
    }
}

function getPlatformEstimate() {
    if (!IS_BLINK)
        return [];
    const v80 = 'getVideoPlaybackQuality' in HTMLVideoElement.prototype;
    const v84 = CSS.supports('appearance: initial');
    const v86 = 'DisplayNames' in Intl;
    const v88 = CSS.supports('aspect-ratio: initial');
    const v89 = CSS.supports('border-end-end-radius: initial');
    const v95 = 'randomUUID' in Crypto.prototype;
    const hasBarcodeDetector = 'BarcodeDetector' in window;
    const hasDownlinkMax = 'downlinkMax' in (window.NetworkInformation?.prototype || {});
    const hasContentIndex = 'ContentIndex' in window;
    const hasContactsManager = 'ContactsManager' in window;
    const hasEyeDropper = 'EyeDropper' in window;
    const hasFileSystemWritableFileStream = 'FileSystemWritableFileStream' in window;
    const hasHid = 'HID' in window && 'HIDDevice' in window;
    const hasSerialPort = 'SerialPort' in window && 'Serial' in window;
    const hasSharedWorker = 'SharedWorker' in window;
    const hasTouch = 'ontouchstart' in Window && 'TouchEvent' in window;
    const hasFeature = (version, condition) => {
        return (version ? [condition] : []);
    };
    const estimate = {
        ["Android" /* Platform.ANDROID */]: [
            ...hasFeature(v88, hasBarcodeDetector),
            ...hasFeature(v84, hasContentIndex),
            ...hasFeature(v80, hasContactsManager),
            hasDownlinkMax,
            ...hasFeature(v95, !hasEyeDropper),
            ...hasFeature(v86, !hasFileSystemWritableFileStream),
            ...hasFeature(v89, !hasHid),
            ...hasFeature(v89, !hasSerialPort),
            !hasSharedWorker,
            hasTouch,
        ],
        ["Chrome OS" /* Platform.CHROME_OS */]: [
            ...hasFeature(v88, hasBarcodeDetector),
            ...hasFeature(v84, !hasContentIndex),
            ...hasFeature(v80, !hasContactsManager),
            hasDownlinkMax,
            ...hasFeature(v95, hasEyeDropper),
            ...hasFeature(v86, hasFileSystemWritableFileStream),
            ...hasFeature(v89, hasHid),
            ...hasFeature(v89, hasSerialPort),
            hasSharedWorker,
            hasTouch || !hasTouch,
        ],
        ["Windows" /* Platform.WINDOWS */]: [
            ...hasFeature(v88, !hasBarcodeDetector),
            ...hasFeature(v84, !hasContentIndex),
            ...hasFeature(v80, !hasContactsManager),
            !hasDownlinkMax,
            ...hasFeature(v95, hasEyeDropper),
            ...hasFeature(v86, hasFileSystemWritableFileStream),
            ...hasFeature(v89, hasHid),
            ...hasFeature(v89, hasSerialPort),
            hasSharedWorker,
            hasTouch || !hasTouch,
        ],
        ["Mac" /* Platform.MAC */]: [
            ...hasFeature(v88, hasBarcodeDetector),
            ...hasFeature(v84, !hasContentIndex),
            ...hasFeature(v80, !hasContactsManager),
            !hasDownlinkMax,
            ...hasFeature(v95, hasEyeDropper),
            ...hasFeature(v86, hasFileSystemWritableFileStream),
            ...hasFeature(v89, hasHid),
            ...hasFeature(v89, hasSerialPort),
            hasSharedWorker,
            !hasTouch,
        ],
        ["Linux" /* Platform.LINUX */]: [
            ...hasFeature(v88, !hasBarcodeDetector),
            ...hasFeature(v84, !hasContentIndex),
            ...hasFeature(v80, !hasContactsManager),
            !hasDownlinkMax,
            ...hasFeature(v95, hasEyeDropper),
            ...hasFeature(v86, hasFileSystemWritableFileStream),
            ...hasFeature(v89, hasHid),
            ...hasFeature(v89, hasSerialPort),
            hasSharedWorker,
            !hasTouch || !hasTouch,
        ],
    };
    // Chrome only features
    const headlessEstimate = {
        noContentIndex: v84 && !hasContentIndex,
        noContactsManager: v80 && !hasContactsManager,
        noDownlinkMax: !hasDownlinkMax,
    };
    const scores = Object.keys(estimate).reduce((acc, key) => {
        const list = estimate[key];
        const score = +((list.filter((x) => x).length / list.length).toFixed(2));
        acc[key] = score;
        return acc;
    }, {});
    const platform = Object.keys(scores).reduce((a, b) => scores[a] > scores[b] ? a : b);
    const highestScore = scores[platform];
    return [scores, highestScore, headlessEstimate];
}

const SYSTEM_FONTS = [
    'caption',
    'icon',
    'menu',
    'message-box',
    'small-caption',
    'status-bar',
];

const GeckoFonts = {
    '-apple-system': "Mac" /* Platform.MAC */,
    'Segoe UI': "Windows" /* Platform.WINDOWS */,
    'Tahoma': "Windows" /* Platform.WINDOWS */,
    'Yu Gothic UI': "Windows" /* Platform.WINDOWS */,
    'Microsoft JhengHei UI': "Windows" /* Platform.WINDOWS */,
    'Microsoft YaHei UI': "Windows" /* Platform.WINDOWS */,
    'Meiryo UI': "Windows" /* Platform.WINDOWS */,
    'Cantarell': "Linux" /* Platform.LINUX */,
    'Ubuntu': "Linux" /* Platform.LINUX */,
    'Sans': "Linux" /* Platform.LINUX */,
    'sans-serif': "Linux" /* Platform.LINUX */,
    'Fira Sans': "Linux" /* Platform.LINUX */,
    'Roboto': "Android" /* Platform.ANDROID */,
};
function getSystemFonts() {
    const { body } = document;
    const el = document.createElement('div');
    body.appendChild(el);
    try {
        const systemFonts = String([
            ...SYSTEM_FONTS.reduce((acc, font) => {
                el.setAttribute('style', `font: ${font} !important`);
                return acc.add(getComputedStyle(el).fontFamily);
            }, new Set()),
        ]);
        const geckoPlatform = GeckoFonts[systemFonts];
        return GeckoFonts[systemFonts] ? `${systemFonts}:${geckoPlatform}` : systemFonts;
    }
    catch (err) {
        return '';
    }
    finally {
        body.removeChild(el);
    }
}

/* eslint-disable new-cap */
async function getHeadlessFeatures({ webgl, workerScope, }) {
    try {
        const timer = createTimer();
        await queueEvent(timer);
        const mimeTypes = Object.keys({ ...navigator.mimeTypes });
        const systemFonts = getSystemFonts();
        const [scores, highestScore, headlessEstimate] = getPlatformEstimate();
        const data = {
            chromium: IS_BLINK,
            likeHeadless: {
                noPlugins: IS_BLINK && navigator.plugins.length === 0,
                noMimeTypes: IS_BLINK && mimeTypes.length === 0,
                notificationIsDenied: (IS_BLINK &&
                    'Notification' in window &&
                    (Notification.permission == 'denied')),
                hasKnownBgColor: IS_BLINK && (() => {
                    let rendered = PARENT_PHANTOM;
                    if (!PARENT_PHANTOM) {
                        rendered = document.createElement('div');
                        document.body.appendChild(rendered);
                    }
                    if (!rendered)
                        return false;
                    rendered.setAttribute('style', `background-color: ActiveText`);
                    const { backgroundColor: activeText } = getComputedStyle(rendered) || [];
                    if (!PARENT_PHANTOM) {
                        document.body.removeChild(rendered);
                    }
                    return activeText === 'rgb(255, 0, 0)';
                })(),
                prefersLightColor: matchMedia('(prefers-color-scheme: light)').matches,
                // @ts-expect-error rtt will be undefined if not supported
                rttIsZero: navigator?.connection?.rtt === 0,
                uaDataIsBlank: ('userAgentData' in navigator && (
                // @ts-expect-error if userAgentData is null
                navigator.userAgentData?.platform === '' ||
                    // @ts-expect-error if userAgentData is null
                    await navigator.userAgentData.getHighEntropyValues(['platform']).platform === '')),
                pdfIsDisabled: ('pdfViewerEnabled' in navigator && navigator.pdfViewerEnabled === false),
                noTaskbar: (screen.height === screen.availHeight &&
                    screen.width === screen.availWidth),
                hasVvpScreenRes: ((innerWidth === screen.width && outerHeight === screen.height) || ('visualViewport' in window &&
                    // @ts-expect-error if unsupported
                    (visualViewport.width === screen.width && visualViewport.height === screen.height))),
                hasSwiftShader: /SwiftShader/.test(workerScope?.webglRenderer),
                noWebShare: IS_BLINK && CSS.supports('accent-color: initial') && (!('share' in navigator) || !('canShare' in navigator)),
                noContentIndex: !!headlessEstimate?.noContentIndex,
                noContactsManager: !!headlessEstimate?.noContactsManager,
                noDownlinkMax: !!headlessEstimate?.noDownlinkMax,
            },
            headless: {
                webDriverIsOn: ((CSS.supports('border-end-end-radius: initial') && navigator.webdriver === undefined) ||
                    !!navigator.webdriver
                    // Somehow this tells me some things that have been changed on `navigator` 
                    || Object.getOwnPropertyNames(navigator).indexOf("webdriver") != -1),
                noChrome: IS_BLINK && !('chrome' in window),
                hasPermissionsBug: (IS_BLINK &&
                    'permissions' in navigator &&
                    await (async () => {
                        const res = await navigator.permissions.query({ name: 'notifications' });
                        return (res.state == 'prompt' &&
                            'Notification' in window &&
                            Notification.permission === 'denied');
                    })()),
                hasHeadlessUA: (/HeadlessChrome/.test(navigator.userAgent) ||
                    /HeadlessChrome/.test(navigator.appVersion)),
                hasHeadlessWorkerUA: !!workerScope && (/HeadlessChrome/.test(workerScope.userAgent)),
            },
            stealth: {
                hasIframeProxy: (() => {
                    try {
                        const iframe = document.createElement('iframe');
                        iframe.srcdoc = instanceId;
                        return !!iframe.contentWindow;
                    }
                    catch (err) {
                        return true;
                    }
                })(),
                hasHighChromeIndex: (() => {
                    const control = ('cookieStore' in window ? 'cookieStore' :
                        'ondevicemotion' in window ? 'ondevicemotion' :
                            'speechSynthesis');
                    const propsInWindow = [];
                    // eslint-disable-next-line guard-for-in
                    for (const prop in window) {
                        propsInWindow.push(prop);
                    }
                    const chromeIndex = propsInWindow.indexOf('chrome');
                    const controlIndex = propsInWindow.indexOf(control);
                    return chromeIndex > controlIndex;
                })(),
                hasBadChromeRuntime: (() => {
                    // @ts-expect-error if unsupported
                    if (!('chrome' in window && 'runtime' in chrome)) {
                        return false;
                    }
                    try {
                        // @ts-expect-error if unsupported
                        if ('prototype' in chrome.runtime.sendMessage ||
                            // @ts-expect-error if unsupported
                            'prototype' in chrome.runtime.connect) {
                            return true;
                        }
                        // @ts-expect-error if unsupported
                        new chrome.runtime.sendMessage;
                        // @ts-expect-error if unsupported
                        new chrome.runtime.connect;
                        return true;
                    }
                    catch (err) {
                        return err.constructor.name != 'TypeError' ? true : false;
                    }
                })(),
                hasToStringProxy: (!!lieProps['Function.toString']),
                hasBadWebGL: (() => {
                    const { UNMASKED_RENDERER_WEBGL: gpu } = webgl?.parameters || {};
                    const { webglRenderer: workerGPU } = workerScope || {};
                    return (gpu && workerGPU && (gpu !== workerGPU));
                })(),
            },
        };
        const { likeHeadless, headless, stealth } = data;
        const likeHeadlessKeys = Object.keys(likeHeadless);
        const headlessKeys = Object.keys(headless);
        const stealthKeys = Object.keys(stealth);
        const likeHeadlessRating = +((likeHeadlessKeys.filter((key) => likeHeadless[key]).length / likeHeadlessKeys.length) * 100).toFixed(0);
        const headlessRating = +((headlessKeys.filter((key) => headless[key]).length / headlessKeys.length) * 100).toFixed(0);
        const stealthRating = +((stealthKeys.filter((key) => stealth[key]).length / stealthKeys.length) * 100).toFixed(0);
        logTestResult({ time: timer.stop(), test: 'headless', passed: true });
        return {
            ...data,
            likeHeadlessRating,
            headlessRating,
            stealthRating,
            systemFonts,
            platformEstimate: [scores, highestScore],
        };
    }
    catch (error) {
        logTestResult({ test: 'headless', passed: false });
        captureError(error);
        return;
    }
}

async function getIntl() {
    const getLocale = (intl) => {
        const constructors = [
            'Collator',
            'DateTimeFormat',
            'DisplayNames',
            'ListFormat',
            'NumberFormat',
            'PluralRules',
            'RelativeTimeFormat',
        ];
        // @ts-ignore
        const locale = constructors.reduce((acc, name) => {
            try {
                const obj = new intl[name];
                if (!obj) {
                    return acc;
                }
                const { locale } = obj.resolvedOptions() || {};
                return [...acc, locale];
            }
            catch (error) {
                return acc;
            }
        }, []);
        return [...new Set(locale)];
    };
    try {
        const timer = createTimer();
        await queueEvent(timer);
        const lied = (lieProps['Intl.Collator.resolvedOptions'] ||
            lieProps['Intl.DateTimeFormat.resolvedOptions'] ||
            lieProps['Intl.DisplayNames.resolvedOptions'] ||
            lieProps['Intl.ListFormat.resolvedOptions'] ||
            lieProps['Intl.NumberFormat.resolvedOptions'] ||
            lieProps['Intl.PluralRules.resolvedOptions'] ||
            lieProps['Intl.RelativeTimeFormat.resolvedOptions']) || false;
        const dateTimeFormat = caniuse(() => {
            return new Intl.DateTimeFormat(undefined, {
                month: 'long',
                timeZoneName: 'long',
            }).format(963644400000);
        });
        const displayNames = caniuse(() => {
            return new Intl.DisplayNames(undefined, {
                type: 'language',
            }).of('en-US');
        });
        const listFormat = caniuse(() => {
            // @ts-ignore
            return new Intl.ListFormat(undefined, {
                style: 'long',
                type: 'disjunction',
            }).format(['0', '1']);
        });
        const numberFormat = caniuse(() => {
            return new Intl.NumberFormat(undefined, {
                notation: 'compact',
                compactDisplay: 'long',
            }).format(21000000);
        });
        const pluralRules = caniuse(() => {
            return new Intl.PluralRules().select(1);
        });
        const relativeTimeFormat = caniuse(() => {
            return new Intl.RelativeTimeFormat(undefined, {
                localeMatcher: 'best fit',
                numeric: 'auto',
                style: 'long',
            }).format(1, 'year');
        });
        const locale = getLocale(Intl);
        logTestResult({ time: timer.stop(), test: 'intl', passed: true });
        return {
            dateTimeFormat,
            displayNames,
            listFormat,
            numberFormat,
            pluralRules,
            relativeTimeFormat,
            locale: '' + locale,
            lied,
        };
    }
    catch (error) {
        logTestResult({ test: 'intl', passed: false });
        captureError(error);
        return;
    }
}

function getMaths() {
    try {
        const timer = createTimer();
        timer.start();
        // detect failed math equality lie
        const check = [
            'acos',
            'acosh',
            'asin',
            'asinh',
            'atan',
            'atanh',
            'atan2',
            'cbrt',
            'cos',
            'cosh',
            'expm1',
            'exp',
            'hypot',
            'log',
            'log1p',
            'log10',
            'sin',
            'sinh',
            'sqrt',
            'tan',
            'tanh',
            'pow',
        ];
        let lied = false;
        check.forEach((prop) => {
            if (!!lieProps[`Math.${prop}`]) {
                lied = true;
            }
            const test = (prop == 'cos' ? [1e308] :
                prop == 'acos' || prop == 'asin' || prop == 'atanh' ? [0.5] :
                    prop == 'pow' || prop == 'atan2' ? [Math.PI, 2] :
                        [Math.PI]);
            const res1 = Math[prop](...test);
            const res2 = Math[prop](...test);
            const matching = isNaN(res1) && isNaN(res2) ? true : res1 == res2;
            if (!matching) {
                lied = true;
                const mathLie = `expected x and got y`;
                documentLie(`Math.${prop}`, mathLie);
            }
            return;
        });
        const n = 0.123;
        const bigN = 5.860847362277284e+38;
        const fns = [
            ['acos', [n], `acos(${n})`, 1.4474840516030247, NaN, NaN, 1.4474840516030245],
            ['acos', [Math.SQRT1_2], 'acos(Math.SQRT1_2)', 0.7853981633974483, NaN, NaN, NaN],
            ['acosh', [1e308], 'acosh(1e308)', 709.889355822726, NaN, NaN, NaN],
            ['acosh', [Math.PI], 'acosh(Math.PI)', 1.811526272460853, NaN, NaN, NaN],
            ['acosh', [Math.SQRT2], 'acosh(Math.SQRT2)', 0.881373587019543, NaN, NaN, 0.8813735870195432],
            ['asin', [n], `asin(${n})`, 0.12331227519187199, NaN, NaN, NaN],
            ['asinh', [1e300], 'asinh(1e308)', 691.4686750787736, NaN, NaN, NaN],
            ['asinh', [Math.PI], 'asinh(Math.PI)', 1.8622957433108482, NaN, NaN, NaN],
            ['atan', [2], 'atan(2)', 1.1071487177940904, NaN, NaN, 1.1071487177940906],
            ['atan', [Math.PI], 'atan(Math.PI)', 1.2626272556789115, NaN, NaN, NaN],
            ['atanh', [0.5], 'atanh(0.5)', 0.5493061443340548, NaN, NaN, 0.5493061443340549],
            ['atan2', [1e-310, 2], 'atan2(1e-310, 2)', 5e-311, NaN, NaN, NaN],
            ['atan2', [Math.PI, 2], 'atan2(Math.PI)', 1.0038848218538872, NaN, NaN, NaN],
            ['cbrt', [100], 'cbrt(100)', 4.641588833612779, NaN, NaN, NaN],
            ['cbrt', [Math.PI], 'cbrt(Math.PI)', 1.4645918875615231, NaN, NaN, 1.4645918875615234],
            ['cos', [n], `cos(${n})`, 0.9924450321351935, NaN, NaN, NaN],
            ['cos', [Math.PI], 'cos(Math.PI)', -1, NaN, NaN, NaN],
            ['cos', [bigN], `cos(${bigN})`, -0.10868049424995659, NaN, -0.9779661551196617, NaN],
            ['cos', [-1e308], 'cos(-1e308)', -0.8913089376870335, NaN, 0.99970162388838, NaN],
            ['cos', [13 * Math.E], 'cos(13*Math.E)', -0.7108118501064331, -0.7108118501064332, NaN, NaN],
            ['cos', [57 * Math.E], 'cos(57*Math.E)', -0.536911695749024, -0.5369116957490239, NaN, NaN],
            ['cos', [21 * Math.LN2], 'cos(21*Math.LN2)', -0.4067775970251724, -0.40677759702517235, -0.6534063185820197, NaN],
            ['cos', [51 * Math.LN2], 'cos(51*Math.LN2)', -0.7017203400855446, -0.7017203400855445, NaN, NaN],
            ['cos', [21 * Math.LOG2E], 'cos(21*Math.LOG2E)', 0.4362848063618998, 0.43628480636189976, NaN, NaN],
            ['cos', [25 * Math.SQRT2], 'cos(25*Math.SQRT2)', -0.6982689820462377, -0.6982689820462376, NaN, NaN],
            ['cos', [50 * Math.SQRT1_2], 'cos(50*Math.SQRT1_2)', -0.6982689820462377, -0.6982689820462376, NaN, NaN],
            ['cos', [21 * Math.SQRT1_2], 'cos(21*Math.SQRT1_2)', -0.6534063185820198, NaN, NaN, NaN],
            ['cos', [17 * Math.LOG10E], 'cos(17*Math.LOG10E)', 0.4537557425982784, 0.45375574259827833, NaN, NaN],
            ['cos', [2 * Math.LOG10E], 'cos(2*Math.LOG10E)', 0.6459044007438142, NaN, 0.6459044007438141, NaN],
            ['cosh', [1], 'cosh(1)', 1.5430806348152437, NaN, NaN, NaN],
            ['cosh', [Math.PI], 'cosh(Math.PI)', 11.591953275521519, NaN, NaN, NaN],
            ['cosh', [492 * Math.LOG2E], 'cosh(492*Math.LOG2E)', 9.199870313877772e+307, 9.199870313877774e+307, NaN, NaN],
            ['cosh', [502 * Math.SQRT2], 'cosh(502*Math.SQRT2)', 1.0469199669023138e+308, 1.046919966902314e+308, NaN, NaN],
            ['expm1', [1], 'expm1(1)', 1.718281828459045, NaN, NaN, 1.7182818284590453],
            ['expm1', [Math.PI], 'expm1(Math.PI)', 22.140692632779267, NaN, NaN, NaN],
            ['exp', [n], `exp(${n})`, 1.1308844209474893, NaN, NaN, NaN],
            ['exp', [Math.PI], 'exp(Math.PI)', 23.140692632779267, NaN, NaN, NaN],
            ['hypot', [1, 2, 3, 4, 5, 6], 'hypot(1, 2, 3, 4, 5, 6)', 9.539392014169456, NaN, NaN, NaN],
            ['hypot', [bigN, bigN], `hypot(${bigN}, ${bigN})`, 8.288489826731116e+38, 8.288489826731114e+38, NaN, NaN],
            ['hypot', [2 * Math.E, -100], 'hypot(2*Math.E, -100)', 100.14767208675259, 100.14767208675258, NaN, NaN],
            ['hypot', [6 * Math.PI, -100], 'hypot(6*Math.PI, -100)', 101.76102278593319, 101.7610227859332, NaN, NaN],
            ['hypot', [2 * Math.LN2, -100], 'hypot(2*Math.LN2, -100)', 100.0096085986525, 100.00960859865252, NaN, NaN],
            ['hypot', [Math.LOG2E, -100], 'hypot(Math.LOG2E, -100)', 100.01040630344929, 100.01040630344927, NaN, NaN],
            ['hypot', [Math.SQRT2, -100], 'hypot(Math.SQRT2, -100)', 100.00999950004999, 100.00999950005, NaN, NaN],
            ['hypot', [Math.SQRT1_2, -100], 'hypot(Math.SQRT1_2, -100)', 100.0024999687508, 100.00249996875078, NaN, NaN],
            ['hypot', [2 * Math.LOG10E, -100], 'hypot(2*Math.LOG10E, -100)', 100.00377216279416, 100.00377216279418, NaN, NaN],
            ['log', [n], `log(${n})`, -2.0955709236097197, NaN, NaN, NaN],
            ['log', [Math.PI], 'log(Math.PI)', 1.1447298858494002, NaN, NaN, NaN],
            ['log1p', [n], `log1p(${n})`, 0.11600367575630613, NaN, NaN, NaN],
            ['log1p', [Math.PI], 'log1p(Math.PI)', 1.4210804127942926, NaN, NaN, NaN],
            ['log10', [n], `log10(${n})`, -0.9100948885606021, NaN, NaN, NaN],
            ['log10', [Math.PI], 'log10(Math.PI)', 0.4971498726941338, 0.49714987269413385, NaN, NaN],
            ['log10', [Math.E], 'log10(Math.E)', 0.4342944819032518, NaN, NaN, NaN],
            ['log10', [34 * Math.E], 'log10(34*Math.E)', 1.9657733989455068, 1.965773398945507, NaN, NaN],
            ['log10', [Math.LN2], 'log10(Math.LN2)', -0.1591745389548616, NaN, NaN, NaN],
            ['log10', [11 * Math.LN2], 'log10(11*Math.LN2)', 0.8822181462033634, 0.8822181462033635, NaN, NaN],
            ['log10', [Math.LOG2E], 'log10(Math.LOG2E)', 0.15917453895486158, NaN, NaN, NaN],
            ['log10', [43 * Math.LOG2E], 'log10(43*Math.LOG2E)', 1.792642994534448, 1.7926429945344482, NaN, NaN],
            ['log10', [Math.LOG10E], 'log10(Math.LOG10E)', -0.36221568869946325, NaN, NaN, NaN],
            ['log10', [7 * Math.LOG10E], 'log10(7*Math.LOG10E)', 0.4828823513147936, 0.48288235131479357, NaN, NaN],
            ['log10', [Math.SQRT1_2], 'log10(Math.SQRT1_2)', -0.15051499783199057, NaN, NaN, NaN],
            ['log10', [2 * Math.SQRT1_2], 'log10(2*Math.SQRT1_2)', 0.1505149978319906, 0.15051499783199063, NaN, NaN],
            ['log10', [Math.SQRT2], 'log10(Math.SQRT2)', 0.1505149978319906, 0.15051499783199063, NaN, NaN],
            ['sin', [bigN], `sin(${bigN})`, 0.994076732536068, NaN, -0.20876350121720488, NaN],
            ['sin', [Math.PI], 'sin(Math.PI)', 1.2246467991473532e-16, NaN, 1.2246063538223773e-16, NaN],
            ['sin', [39 * Math.E], 'sin(39*Math.E)', -0.7181630308570677, -0.7181630308570678, NaN, NaN],
            ['sin', [35 * Math.LN2], 'sin(35*Math.LN2)', -0.7659964138980511, -0.765996413898051, NaN, NaN],
            ['sin', [110 * Math.LOG2E], 'sin(110*Math.LOG2E)', 0.9989410140273756, 0.9989410140273757, NaN, NaN],
            ['sin', [7 * Math.LOG10E], 'sin(7*Math.LOG10E)', 0.10135692924965616, 0.10135692924965614, NaN, NaN],
            ['sin', [35 * Math.SQRT1_2], 'sin(35*Math.SQRT1_2)', -0.3746357547858202, -0.37463575478582023, NaN, NaN],
            ['sin', [21 * Math.SQRT2], 'sin(21*Math.SQRT2)', -0.9892668187780498, -0.9892668187780497, NaN, NaN],
            ['sinh', [1], 'sinh(1)', 1.1752011936438014, NaN, NaN, NaN],
            ['sinh', [Math.PI], 'sinh(Math.PI)', 11.548739357257748, NaN, NaN, 11.548739357257746],
            ['sinh', [Math.E], 'sinh(Math.E)', 7.544137102816975, NaN, NaN, NaN],
            ['sinh', [Math.LN2], 'sinh(Math.LN2)', 0.75, NaN, NaN, NaN],
            ['sinh', [Math.LOG2E], 'sinh(Math.LOG2E)', 1.9978980091062795, NaN, NaN, NaN],
            ['sinh', [492 * Math.LOG2E], 'sinh(492*Math.LOG2E)', 9.199870313877772e+307, 9.199870313877774e+307, NaN, NaN],
            ['sinh', [Math.LOG10E], 'sinh(Math.LOG10E)', 0.44807597941469024, NaN, NaN, NaN],
            ['sinh', [Math.SQRT1_2], 'sinh(Math.SQRT1_2)', 0.7675231451261164, NaN, NaN, NaN],
            ['sinh', [Math.SQRT2], 'sinh(Math.SQRT2)', 1.935066822174357, NaN, NaN, 1.9350668221743568],
            ['sinh', [502 * Math.SQRT2], 'sinh(502*Math.SQRT2)', 1.0469199669023138e+308, 1.046919966902314e+308, NaN, NaN],
            ['sqrt', [n], `sqrt(${n})`, 0.3507135583350036, NaN, NaN, NaN],
            ['sqrt', [Math.PI], 'sqrt(Math.PI)', 1.7724538509055159, NaN, NaN, NaN],
            ['tan', [-1e308], 'tan(-1e308)', 0.5086861259107568, NaN, NaN, 0.5086861259107567],
            ['tan', [Math.PI], 'tan(Math.PI)', -1.2246467991473532e-16, NaN, NaN, NaN],
            ['tan', [6 * Math.E], 'tan(6*Math.E)', 0.6866761546452431, 0.686676154645243, NaN, NaN],
            ['tan', [6 * Math.LN2], 'tan(6*Math.LN2)', 1.6182817135715877, 1.618281713571588, NaN, 1.6182817135715875],
            ['tan', [10 * Math.LOG2E], 'tan(10*Math.LOG2E)', -3.3537128705376014, -3.353712870537601, NaN, -3.353712870537602],
            ['tan', [17 * Math.SQRT2], 'tan(17*Math.SQRT2)', -1.9222955461799982, -1.922295546179998, NaN, NaN],
            ['tan', [34 * Math.SQRT1_2], 'tan(34*Math.SQRT1_2)', -1.9222955461799982, -1.922295546179998, NaN, NaN],
            ['tan', [10 * Math.LOG10E], 'tan(10*Math.LOG10E)', 2.5824856130712432, 2.5824856130712437, NaN, NaN],
            ['tanh', [n], `tanh(${n})`, 0.12238344189440875, NaN, NaN, 0.12238344189440876],
            ['tanh', [Math.PI], 'tanh(Math.PI)', 0.99627207622075, NaN, NaN, NaN],
            ['pow', [n, -100], `pow(${n}, -100)`, 1.022089333584519e+91, 1.0220893335845176e+91, NaN, NaN],
            ['pow', [Math.PI, -100], 'pow(Math.PI, -100)', 1.9275814160560204e-50, 1.9275814160560185e-50, NaN, 1.9275814160560206e-50],
            ['pow', [Math.E, -100], 'pow(Math.E, -100)', 3.7200759760208555e-44, 3.720075976020851e-44, NaN, NaN],
            ['pow', [Math.LN2, -100], 'pow(Math.LN2, -100)', 8269017203802394, 8269017203802410, NaN, NaN],
            ['pow', [Math.LN10, -100], 'pow(Math.LN10, -100)', 6.003867926738829e-37, 6.003867926738811e-37, NaN, NaN],
            ['pow', [Math.LOG2E, -100], 'pow(Math.LOG2E, -100)', 1.20933355845501e-16, 1.2093335584550061e-16, NaN, NaN],
            ['pow', [Math.LOG10E, -100], 'pow(Math.LOG10E, -100)', 1.6655929347585958e+36, 1.665592934758592e+36, NaN, 1.6655929347585955e+36],
            ['pow', [Math.SQRT1_2, -100], 'pow(Math.SQRT1_2, -100)', 1125899906842616.2, 1125899906842611.5, NaN, NaN],
            ['pow', [Math.SQRT2, -100], 'pow(Math.SQRT2, -100)', 8.881784197001191e-16, 8.881784197001154e-16, NaN, NaN],
            ['polyfill', [2e-3 ** -100], 'polyfill pow(2e-3, -100)', 7.888609052210102e+269, 7.888609052210126e+269, NaN, NaN],
        ];
        const data = {};
        fns.forEach((fn) => {
            data[fn[2]] = attempt(() => {
                // @ts-ignore
                const result = fn[0] != 'polyfill' ? Math[fn[0]](...fn[1]) : fn[1];
                const chrome = result == fn[3];
                const firefox = fn[4] ? result == fn[4] : false;
                const torBrowser = fn[5] ? result == fn[5] : false;
                const safari = fn[6] ? result == fn[6] : false;
                return { result, chrome, firefox, torBrowser, safari };
            });
        });
        logTestResult({ time: timer.stop(), test: 'math', passed: true });
        return { data, lied };
    }
    catch (error) {
        logTestResult({ test: 'math', passed: false });
        captureError(error);
        return;
    }
}

// inspired by
// - https://privacycheck.sec.lrz.de/active/fp_cpt/fp_can_play_type.html
// - https://arkenfox.github.io/TZP
const getMimeTypeShortList = () => [
    'audio/ogg; codecs="vorbis"',
    'audio/mpeg',
    'audio/mpegurl',
    'audio/wav; codecs="1"',
    'audio/x-m4a',
    'audio/aac',
    'video/ogg; codecs="theora"',
    'video/quicktime',
    'video/mp4; codecs="avc1.42E01E"',
    'video/webm; codecs="vp8"',
    'video/webm; codecs="vp9"',
    'video/x-matroska',
].sort();
async function getMedia() {
    const getMimeTypes = () => {
        try {
            const mimeTypes = getMimeTypeShortList();
            const videoEl = document.createElement('video');
            const audioEl = new Audio();
            const isMediaRecorderSupported = 'MediaRecorder' in window;
            const types = mimeTypes.reduce((acc, type) => {
                const data = {
                    mimeType: type,
                    audioPlayType: audioEl.canPlayType(type),
                    videoPlayType: videoEl.canPlayType(type),
                    mediaSource: MediaSource.isTypeSupported(type),
                    mediaRecorder: isMediaRecorderSupported ? MediaRecorder.isTypeSupported(type) : false,
                };
                if (!data.audioPlayType && !data.videoPlayType && !data.mediaSource && !data.mediaRecorder) {
                    return acc;
                }
                // @ts-ignore
                acc.push(data);
                return acc;
            }, []);
            return types;
        }
        catch (error) {
            return;
        }
    };
    try {
        const timer = createTimer();
        timer.start();
        const mimeTypes = getMimeTypes();
        logTestResult({ time: timer.stop(), test: 'media', passed: true });
        return { mimeTypes };
    }
    catch (error) {
        logTestResult({ test: 'media', passed: false });
        captureError(error);
        return;
    }
}

// special thanks to https://arh.antoinevastel.com for inspiration
async function getNavigator(workerScope) {
    try {
        const timer = createTimer();
        await queueEvent(timer);
        let lied = (lieProps['Navigator.appVersion'] ||
            lieProps['Navigator.deviceMemory'] ||
            lieProps['Navigator.doNotTrack'] ||
            lieProps['Navigator.hardwareConcurrency'] ||
            lieProps['Navigator.language'] ||
            lieProps['Navigator.languages'] ||
            lieProps['Navigator.maxTouchPoints'] ||
            lieProps['Navigator.oscpu'] ||
            lieProps['Navigator.platform'] ||
            lieProps['Navigator.userAgent'] ||
            lieProps['Navigator.vendor'] ||
            lieProps['Navigator.plugins'] ||
            lieProps['Navigator.mimeTypes']) || false;
        const credibleUserAgent = ('chrome' in window ? navigator.userAgent.includes(navigator.appVersion) : true);
        const data = {
            platform: attempt(() => {
                const { platform } = navigator;
                const systems = ['win', 'linux', 'mac', 'arm', 'pike', 'linux', 'iphone', 'ipad', 'ipod', 'android', 'x11'];
                const trusted = typeof platform == 'string' && systems.filter((val) => platform.toLowerCase().includes(val))[0];
                if (!trusted) {
                    sendToTrash(`platform`, `${platform} is unusual`);
                }
                // user agent os lie
                if (USER_AGENT_OS !== PLATFORM_OS) {
                    lied = true;
                    documentLie(`Navigator.platform`, `${PLATFORM_OS} platform and ${USER_AGENT_OS} user agent do not match`);
                }
                if (platform != workerScope.platform) {
                    lied = true; // documented in the worker source
                }
                return platform;
            }),
            system: attempt(() => getOS(navigator.userAgent), 'userAgent system failed'),
            userAgentParsed: await attempt(async () => {
                const reportedUserAgent = caniuse(() => navigator.userAgent);
                const reportedSystem = getOS(reportedUserAgent);
                const isBrave = await braveBrowser();
                const report = decryptUserAgent({
                    ua: reportedUserAgent,
                    os: reportedSystem,
                    isBrave,
                });
                return report;
            }),
            device: attempt(() => getUserAgentPlatform({ userAgent: navigator.userAgent }), 'userAgent device failed'),
            userAgent: attempt(() => {
                const { userAgent } = navigator;
                if (!credibleUserAgent) {
                    sendToTrash('userAgent', `${userAgent} does not match appVersion`);
                }
                if (/\s{2,}|^\s|\s$/g.test(userAgent)) {
                    sendToTrash('userAgent', `extra spaces detected`);
                }
                const gibbers = gibberish(userAgent);
                if (!!gibbers.length) {
                    sendToTrash(`userAgent is gibberish`, userAgent);
                }
                if (userAgent != workerScope.userAgent) {
                    lied = true; // documented in the worker source
                }
                return userAgent.trim().replace(/\s{2,}/, ' ');
            }, 'userAgent failed'),
            uaPostReduction: isUAPostReduction((navigator || {}).userAgent),
            appVersion: attempt(() => {
                const { appVersion } = navigator;
                if (!credibleUserAgent) {
                    sendToTrash('appVersion', `${appVersion} does not match userAgent`);
                }
                if ('appVersion' in navigator && !appVersion) {
                    sendToTrash('appVersion', 'Living Standard property returned falsy value');
                }
                if (/\s{2,}|^\s|\s$/g.test(appVersion)) {
                    sendToTrash('appVersion', `extra spaces detected`);
                }
                return appVersion.trim().replace(/\s{2,}/, ' ');
            }, 'appVersion failed'),
            deviceMemory: attempt(() => {
                if (!('deviceMemory' in navigator)) {
                    return undefined;
                }
                // @ts-ignore
                const { deviceMemory } = navigator;
                const trusted = {
                    '0.25': true,
                    '0.5': true,
                    '1': true,
                    '2': true,
                    '4': true,
                    '8': true,
                };
                if (!trusted[deviceMemory]) {
                    sendToTrash('deviceMemory', `${deviceMemory} is not a valid value [0.25, 0.5, 1, 2, 4, 8]`);
                }
                // @ts-expect-error memory is undefined if not supported
                const memory = performance?.memory?.jsHeapSizeLimit || null;
                const memoryInGigabytes = memory ? +(memory / 1073741824).toFixed(1) : 0;
                if (memoryInGigabytes > deviceMemory) {
                    sendToTrash('deviceMemory', `available memory ${memoryInGigabytes}GB is greater than device memory ${deviceMemory}GB`);
                }
                if (deviceMemory !== workerScope.deviceMemory) {
                    lied = true; // documented in the worker source
                }
                return deviceMemory;
            }, 'deviceMemory failed'),
            doNotTrack: attempt(() => {
                const { doNotTrack } = navigator;
                const trusted = {
                    '1': !0,
                    'true': !0,
                    'yes': !0,
                    '0': !0,
                    'false': !0,
                    'no': !0,
                    'unspecified': !0,
                    'null': !0,
                    'undefined': !0,
                };
                if (!trusted[doNotTrack]) {
                    sendToTrash('doNotTrack - unusual result', doNotTrack);
                }
                return doNotTrack;
            }, 'doNotTrack failed'),
            globalPrivacyControl: attempt(() => {
                if (!('globalPrivacyControl' in navigator)) {
                    return undefined;
                }
                // @ts-ignore
                const { globalPrivacyControl } = navigator;
                const trusted = {
                    '1': !0,
                    'true': !0,
                    'yes': !0,
                    '0': !0,
                    'false': !0,
                    'no': !0,
                    'unspecified': !0,
                    'null': !0,
                    'undefined': !0,
                };
                if (!trusted[globalPrivacyControl]) {
                    sendToTrash('globalPrivacyControl - unusual result', globalPrivacyControl);
                }
                return globalPrivacyControl;
            }, 'globalPrivacyControl failed'),
            hardwareConcurrency: attempt(() => {
                if (!('hardwareConcurrency' in navigator)) {
                    return undefined;
                }
                const { hardwareConcurrency } = navigator;
                if (hardwareConcurrency !== workerScope.hardwareConcurrency) {
                    lied = true; // documented in the worker source
                }
                return hardwareConcurrency;
            }, 'hardwareConcurrency failed'),
            language: attempt(() => {
                const { language, languages } = navigator;
                if (language && languages) {
                    // @ts-ignore
                    const lang = /^.{0,2}/g.exec(language)[0];
                    // @ts-ignore
                    const langs = /^.{0,2}/g.exec(languages[0])[0];
                    if (langs != lang) {
                        sendToTrash('language/languages', `${[language, languages].join(' ')} mismatch`);
                    }
                    return `${languages.join(', ')} (${language})`;
                }
                if (language != workerScope.language) {
                    lied = true;
                    documentLie(`Navigator.language`, `${language} does not match worker scope`);
                }
                if (languages !== workerScope.languages) {
                    lied = true;
                    documentLie(`Navigator.languages`, `${languages} does not match worker scope`);
                }
                return `${language} ${languages}`;
            }, 'language(s) failed'),
            maxTouchPoints: attempt(() => {
                if (!('maxTouchPoints' in navigator)) {
                    return null;
                }
                return navigator.maxTouchPoints;
            }, 'maxTouchPoints failed'),
            vendor: attempt(() => navigator.vendor, 'vendor failed'),
            mimeTypes: attempt(() => {
                const { mimeTypes } = navigator;
                return mimeTypes ? [...mimeTypes].map((m) => m.type) : [];
            }, 'mimeTypes failed'),
            // @ts-ignore
            oscpu: attempt(() => navigator.oscpu, 'oscpu failed'),
            plugins: attempt(() => {
                // https://html.spec.whatwg.org/multipage/system-state.html#pdf-viewing-support
                const { plugins } = navigator;
                if (!(plugins instanceof PluginArray)) {
                    return;
                }
                const response = plugins ? [...plugins]
                    .map((p) => ({
                    name: p.name,
                    description: p.description,
                    filename: p.filename,
                    // @ts-ignore
                    version: p.version,
                })) : [];
                const { lies } = getPluginLies(plugins, navigator.mimeTypes);
                if (lies.length) {
                    lied = true;
                    lies.forEach((lie) => {
                        return documentLie(`Navigator.plugins`, lie);
                    });
                }
                if (response.length) {
                    response.forEach((plugin) => {
                        const { name, description } = plugin;
                        const nameGibbers = gibberish(name);
                        const descriptionGibbers = gibberish(description);
                        if (nameGibbers.length) {
                            sendToTrash(`plugin name is gibberish`, name);
                        }
                        if (descriptionGibbers.length) {
                            sendToTrash(`plugin description is gibberish`, description);
                        }
                        return;
                    });
                }
                return response;
            }, 'plugins failed'),
            properties: attempt(() => {
                const keys = Object.keys(Object.getPrototypeOf(navigator));
                return keys;
            }, 'navigator keys failed'),
        };
        const getUserAgentData = () => attempt(() => {
            // @ts-ignore
            if (!navigator.userAgentData ||
                // @ts-ignore
                !navigator.userAgentData.getHighEntropyValues) {
                return;
            }
            // @ts-ignore
            return navigator.userAgentData.getHighEntropyValues(['platform', 'platformVersion', 'architecture', 'bitness', 'model', 'uaFullVersion']).then((data) => {
                // @ts-ignore
                const { brands, mobile } = navigator.userAgentData || {};
                const compressedBrands = (brands, captureVersion = false) => brands
                    .filter((obj) => !/Not/.test(obj.brand)).map((obj) => `${obj.brand}${captureVersion ? ` ${obj.version}` : ''}`);
                const removeChromium = (brands) => (brands.length > 1 ? brands.filter((brand) => !/Chromium/.test(brand)) : brands);
                // compress brands
                if (!data.brands) {
                    data.brands = brands;
                }
                data.brandsVersion = compressedBrands(data.brands, true);
                data.brands = compressedBrands(data.brands);
                data.brandsVersion = removeChromium(data.brandsVersion);
                data.brands = removeChromium(data.brands);
                if (!data.mobile) {
                    data.mobile = mobile;
                }
                const dataSorted = Object.keys(data).sort().reduce((acc, key) => {
                    acc[key] = data[key];
                    return acc;
                }, {});
                return dataSorted;
            });
        }, 'userAgentData failed');
        const getBluetoothAvailability = () => attempt(() => {
            if (!('bluetooth' in navigator) ||
                // @ts-ignore
                !navigator.bluetooth ||
                // @ts-ignore
                !navigator.bluetooth.getAvailability) {
                return undefined;
            }
            // @ts-ignore
            return navigator.bluetooth.getAvailability();
        }, 'bluetoothAvailability failed');
        const getPermissions = () => attempt(() => {
            const getPermissionState = (name) => navigator.permissions.query({ name })
                .then((res) => ({ name, state: res.state }))
                .catch((error) => ({ name, state: 'unknown' }));
            // https://w3c.github.io/permissions/#permission-registry
            const permissions = !('permissions' in navigator) ? undefined : Promise.all([
                getPermissionState('accelerometer'),
                getPermissionState('ambient-light-sensor'),
                getPermissionState('background-fetch'),
                getPermissionState('background-sync'),
                getPermissionState('bluetooth'),
                getPermissionState('camera'),
                getPermissionState('clipboard'),
                getPermissionState('device-info'),
                getPermissionState('display-capture'),
                getPermissionState('gamepad'),
                getPermissionState('geolocation'),
                getPermissionState('gyroscope'),
                getPermissionState('magnetometer'),
                getPermissionState('microphone'),
                getPermissionState('midi'),
                getPermissionState('nfc'),
                getPermissionState('notifications'),
                getPermissionState('persistent-storage'),
                getPermissionState('push'),
                getPermissionState('screen-wake-lock'),
                getPermissionState('speaker'),
                getPermissionState('speaker-selection'),
            ]).then((permissions) => permissions.reduce((acc, perm) => {
                const { state, name } = perm || {};
                if (acc[state]) {
                    acc[state].push(name);
                    return acc;
                }
                acc[state] = [name];
                return acc;
            }, {})).catch((error) => console.error(error));
            return permissions;
        }, 'permissions failed');
        const getWebgpu = () => attempt(() => {
            if (!('gpu' in navigator)) {
                return;
            }
            // @ts-ignore
            return navigator.gpu.requestAdapter().then(({ limits, features }) => {
                return {
                    features: [...features.values()],
                    limits: ((limits) => {
                        const data = {};
                        // eslint-disable-next-line guard-for-in
                        for (const prop in limits) {
                            data[prop] = limits[prop];
                        }
                        return data;
                    })(limits),
                };
            });
        }, 'webgpu failed');
        await queueEvent(timer);
        return Promise.all([
            getUserAgentData(),
            getBluetoothAvailability(),
            getPermissions(),
            getWebgpu(),
        ]).then(([userAgentData, bluetoothAvailability, permissions, webgpu,]) => {
            logTestResult({ time: timer.stop(), test: 'navigator', passed: true });
            return {
                ...data,
                userAgentData,
                bluetoothAvailability,
                permissions,
                webgpu,
                lied,
            };
        }).catch((error) => {
            console.error(error);
            logTestResult({ time: timer.stop(), test: 'navigator', passed: true });
            return {
                ...data,
                lied,
            };
        });
    }
    catch (error) {
        logTestResult({ test: 'navigator', passed: false });
        captureError(error, 'Navigator failed or blocked by client');
        return;
    }
}

async function getResistance() {
    try {
        const timer = createTimer();
        await queueEvent(timer);
        const data = {
            privacy: undefined,
            security: undefined,
            mode: undefined,
            extension: undefined,
            engine: (IS_BLINK ? 'Blink' :
                IS_GECKO ? 'Gecko' :
                    ''),
        };
        // Firefox/Tor Browser
        const regex = (n) => new RegExp(`${n}+$`);
        const delay = (ms, baseNumber, baseDate) => new Promise((resolve) => setTimeout(() => {
            const date = baseDate ? baseDate : +new Date();
            // @ts-ignore
            const value = regex(baseNumber).test(date) ? regex(baseNumber).exec(date)[0] : date;
            return resolve(value);
        }, ms));
        const getTimerPrecision = async () => {
            const baseDate = +new Date();
            const baseNumber = +('' + baseDate).slice(-1);
            const a = await delay(0, baseNumber, baseDate);
            const b = await delay(1, baseNumber);
            const c = await delay(2, baseNumber);
            const d = await delay(3, baseNumber);
            const e = await delay(4, baseNumber);
            const f = await delay(5, baseNumber);
            const g = await delay(6, baseNumber);
            const h = await delay(7, baseNumber);
            const i = await delay(8, baseNumber);
            const j = await delay(9, baseNumber);
            const lastCharA = ('' + a).slice(-1);
            const lastCharB = ('' + b).slice(-1);
            const lastCharC = ('' + c).slice(-1);
            const lastCharD = ('' + d).slice(-1);
            const lastCharE = ('' + e).slice(-1);
            const lastCharF = ('' + f).slice(-1);
            const lastCharG = ('' + g).slice(-1);
            const lastCharH = ('' + h).slice(-1);
            const lastCharI = ('' + i).slice(-1);
            const lastCharJ = ('' + j).slice(-1);
            const protection = (lastCharA == lastCharB &&
                lastCharA == lastCharC &&
                lastCharA == lastCharD &&
                lastCharA == lastCharE &&
                lastCharA == lastCharF &&
                lastCharA == lastCharG &&
                lastCharA == lastCharH &&
                lastCharA == lastCharI &&
                lastCharA == lastCharJ);
            const baseLen = ('' + a).length;
            const collection = [a, b, c, d, e, f, g, h, i, j];
            return {
                protection,
                delays: collection.map((n) => ('' + n).length > baseLen ? ('' + n).slice(-baseLen) : n),
                precision: protection ? Math.min(...collection.map((val) => ('' + val).length)) : undefined,
                precisionValue: protection ? lastCharA : undefined,
            };
        };
        const [isBrave, timerPrecision,] = await Promise.all([
            braveBrowser(),
            IS_BLINK ? undefined : getTimerPrecision(),
        ]);
        if (isBrave) {
            const braveMode = getBraveMode();
            data.privacy = 'Brave';
            // @ts-ignore
            data.security = {
                'FileSystemWritableFileStream': 'FileSystemWritableFileStream' in window,
                'Serial': 'Serial' in window,
                'ReportingObserver': 'ReportingObserver' in window,
            };
            data.mode = (braveMode.allow ? 'allow' :
                braveMode.standard ? 'standard' :
                    braveMode.strict ? 'strict' :
                        '');
        }
        const { protection } = timerPrecision || {};
        if (IS_GECKO && protection) {
            const features = {
                'OfflineAudioContext': 'OfflineAudioContext' in window,
                'WebGL2RenderingContext': 'WebGL2RenderingContext' in window,
                'WebAssembly': 'WebAssembly' in window,
                'maxTouchPoints': 'maxTouchPoints' in navigator,
                'RTCRtpTransceiver': 'RTCRtpTransceiver' in window,
                'MediaDevices': 'MediaDevices' in window,
                'Credential': 'Credential' in window,
            };
            const featureKeys = Object.keys(features);
            const targetSet = new Set([
                'RTCRtpTransceiver',
                'MediaDevices',
                'Credential',
            ]);
            const torBrowser = featureKeys.filter((key) => targetSet.has(key) && !features[key]).length == targetSet.size;
            const safer = !features.WebAssembly;
            data.privacy = torBrowser ? 'Tor Browser' : 'Firefox';
            // @ts-ignore
            data.security = {
                'reduceTimerPrecision': true,
                ...features,
            };
            data.mode = (!torBrowser ? 'resistFingerprinting' :
                safer ? 'safer' :
                    'standard');
        }
        // extension
        // - this technique gets a small sample of known lie patterns
        // - patterns vary based on extensions settings, version, browser
        const prototypeLiesLen = Object.keys(prototypeLies).length;
        // patterns based on settings
        const disabled = 'c767712b';
        const pattern = {
            noscript: {
                contentDocumentHash: ['0b637a33', '37e2f32e', '318390d1'],
                contentWindowHash: ['0b637a33', '37e2f32e', '318390d1'],
                getContextHash: ['0b637a33', '081d6d1b', disabled],
            },
            trace: {
                contentDocumentHash: ['ca9d9c2f'],
                contentWindowHash: ['ca9d9c2f'],
                createElementHash: ['77dea834'],
                getElementByIdHash: ['77dea834'],
                getImageDataHash: ['77dea834'],
                toBlobHash: ['77dea834', disabled],
                toDataURLHash: ['77dea834', disabled],
            },
            cydec: {
                // [FF, FF Anti OFF, Chrome, Chrome Anti Off, no iframe Chrome, no iframe Chrome Anti Off]
                contentDocumentHash: ['945b0c78', '15771efa', '403a1a21', '55e9b959'],
                contentWindowHash: ['945b0c78', '15771efa', '403a1a21', '55e9b959'],
                createElementHash: ['3dd86d6f', 'cc7cb598', '4237b44c', '1466aaf0', '0cb0c682', '73c662d9', '72b1ee2b', 'ae3d02c9'],
                getElementByIdHash: ['3dd86d6f', 'cc7cb598', '4237b44c', '1466aaf0', '0cb0c682', '73c662d9', '72b1ee2b', 'ae3d02c9'],
                getImageDataHash: ['044f14c2', 'db60d7f9', '15771efa', 'db60d7f9', '55e9b959'],
                toBlobHash: ['044f14c2', '15771efa', 'afec348d', '55e9b959', '0dbbf456'],
                toDataURLHash: ['ecb498d9', '15771efa', '6b838fb6', 'd19104ec', '6985d315', '55e9b959', 'fe88259f'],
            },
            canvasblocker: {
                contentDocumentHash: ['98ec858e', 'dbbaf31f'],
                contentWindowHash: ['98ec858e', 'dbbaf31f'],
                appendHash: ['98ec858e', 'dbbaf31f'],
                getImageDataHash: ['98ec858e', 'a2971888', 'dbbaf31f', disabled],
                toBlobHash: ['9f1c3dfe', 'a2971888', 'dbbaf31f', disabled],
                toDataURLHash: ['98ec858e', 'a2971888', 'dbbaf31f', disabled],
            },
            chameleon: {
                appendHash: ['77dea834'],
                insertAdjacentElementHash: ['77dea834'],
                insertAdjacentHTMLHash: ['77dea834'],
                insertAdjacentTextHash: ['77dea834'],
                prependHash: ['77dea834'],
                replaceWithHash: ['77dea834'],
                appendChildHash: ['77dea834'],
                insertBeforeHash: ['77dea834'],
                replaceChildHash: ['77dea834'],
            },
            duckduckgo: {
                toDataURLHash: ['fd00bf5d', '8ee7df22', disabled],
                toBlobHash: ['fd00bf5d', '8ee7df22', disabled],
                getImageDataHash: ['fd00bf5d', '8ee7df22', disabled],
                getByteFrequencyDataHash: ['fd00bf5d', '8ee7df22', disabled],
                getByteTimeDomainDataHash: ['fd00bf5d', '8ee7df22', disabled],
                getFloatFrequencyDataHash: ['fd00bf5d', '8ee7df22', disabled],
                getFloatTimeDomainDataHash: ['fd00bf5d', '8ee7df22', disabled],
                copyFromChannelHash: ['fd00bf5d', '8ee7df22', disabled],
                getChannelDataHash: ['fd00bf5d', '8ee7df22', disabled],
                hardwareConcurrencyHash: ['dfd41ab4'],
                availHeightHash: ['dfd41ab4'],
                availLeftHash: ['dfd41ab4'],
                availTopHash: ['dfd41ab4'],
                availWidthHash: ['dfd41ab4'],
                colorDepthHash: ['dfd41ab4'],
                pixelDepthHash: ['dfd41ab4'],
            },
            // mode: Learn to block new trackers from your browsing
            privacybadger: {
                getImageDataHash: ['0cb0c682'],
                toDataURLHash: ['0cb0c682'],
            },
            privacypossum: {
                hardwareConcurrencyHash: ['452924d5'],
                availWidthHash: ['452924d5'],
                colorDepthHash: ['452924d5'],
            },
            jshelter: {
                contentDocumentHash: ['0007ab4e', '0b637a33', '866fa7e7', '318390d1'],
                contentWindowHash: ['0007ab4e', '0b637a33', '866fa7e7', '318390d1'],
                appendHash: ['0007ab4e', '0b637a33', '866fa7e7', '318390d1'],
                insertAdjacentElementHash: ['0007ab4e', '0b637a33', '866fa7e7', '318390d1'],
                insertAdjacentHTMLHash: ['0007ab4e', '0b637a33', '866fa7e7', '318390d1'],
                prependHash: ['0007ab4e', '0b637a33', '866fa7e7', '318390d1'],
                replaceWithHash: ['0007ab4e', '0b637a33', '866fa7e7', '318390d1'],
                appendChildHash: ['0007ab4e', '0b637a33', '866fa7e7', '318390d1'],
                insertBeforeHash: ['0007ab4e', '0b637a33', '866fa7e7', '318390d1'],
                replaceChildHash: ['0007ab4e', '0b637a33', '866fa7e7', '318390d1'],
                hardwareConcurrencyHash: ['dfd41ab4'],
            },
            puppeteerExtra: {
                contentDocumentHash: ['55e9b959'],
                contentWindowHash: [
                    '55e9b959',
                    '50a281b5', // @2.10.0
                ],
                createElementHash: ['55e9b959'],
                getElementByIdHash: ['55e9b959'],
                appendHash: ['55e9b959'],
                insertAdjacentElementHash: ['55e9b959'],
                insertAdjacentHTMLHash: ['55e9b959'],
                insertAdjacentTextHash: ['55e9b959'],
                prependHash: ['55e9b959'],
                replaceWithHash: ['55e9b959'],
                appendChildHash: ['55e9b959'],
                insertBeforeHash: ['55e9b959'],
                replaceChildHash: ['55e9b959'],
                getContextHash: ['55e9b959', disabled],
                toDataURLHash: ['55e9b959', disabled],
                toBlobHash: ['55e9b959', disabled],
                getImageDataHash: ['55e9b959'],
                hardwareConcurrencyHash: ['efbd4cf9', 'a63491fb', 'b011fd1c', '194ecf17', '55e9b959'],
            },
            fakeBrowser: {
                appendChildHash: ['8dfec2ec', 'f43e6134'],
                getContextHash: ['83b825ab', 'a63491fb'],
                toDataURLHash: ['83b825ab', 'a63491fb'],
                toBlobHash: ['83b825ab', 'a63491fb'],
                getImageDataHash: ['83b825ab', 'a63491fb'],
                hardwareConcurrencyHash: ['83b825ab', 'a63491fb'],
                availHeightHash: ['83b825ab', 'a63491fb'],
                availLeftHash: ['83b825ab', 'a63491fb'],
                availTopHash: ['83b825ab', 'a63491fb'],
                availWidthHash: ['83b825ab', 'a63491fb'],
                colorDepthHash: ['83b825ab', 'a63491fb'],
                pixelDepthHash: ['83b825ab', 'a63491fb'],
            },
        };
        /*
        Random User-Agent
        User Agent Switcher and Manager
        ScriptSafe
        Windscribe
        */
        await queueEvent(timer);
        const hash = {
            // iframes
            contentDocumentHash: hashMini(prototypeLies['HTMLIFrameElement.contentDocument']),
            contentWindowHash: hashMini(prototypeLies['HTMLIFrameElement.contentWindow']),
            createElementHash: hashMini(prototypeLies['Document.createElement']),
            getElementByIdHash: hashMini(prototypeLies['Document.getElementById']),
            appendHash: hashMini(prototypeLies['Element.append']),
            insertAdjacentElementHash: hashMini(prototypeLies['Element.insertAdjacentElement']),
            insertAdjacentHTMLHash: hashMini(prototypeLies['Element.insertAdjacentHTML']),
            insertAdjacentTextHash: hashMini(prototypeLies['Element.insertAdjacentText']),
            prependHash: hashMini(prototypeLies['Element.prepend']),
            replaceWithHash: hashMini(prototypeLies['Element.replaceWith']),
            appendChildHash: hashMini(prototypeLies['Node.appendChild']),
            insertBeforeHash: hashMini(prototypeLies['Node.insertBefore']),
            replaceChildHash: hashMini(prototypeLies['Node.replaceChild']),
            // canvas
            getContextHash: hashMini(prototypeLies['HTMLCanvasElement.getContext']),
            toDataURLHash: hashMini(prototypeLies['HTMLCanvasElement.toDataURL']),
            toBlobHash: hashMini(prototypeLies['HTMLCanvasElement.toBlob']),
            getImageDataHash: hashMini(prototypeLies['CanvasRenderingContext2D.getImageData']),
            // Audio
            getByteFrequencyDataHash: hashMini(prototypeLies['AnalyserNode.getByteFrequencyData']),
            getByteTimeDomainDataHash: hashMini(prototypeLies['AnalyserNode.getByteTimeDomainData']),
            getFloatFrequencyDataHash: hashMini(prototypeLies['AnalyserNode.getFloatFrequencyData']),
            getFloatTimeDomainDataHash: hashMini(prototypeLies['AnalyserNode.getFloatTimeDomainData']),
            copyFromChannelHash: hashMini(prototypeLies['AudioBuffer.copyFromChannel']),
            getChannelDataHash: hashMini(prototypeLies['AudioBuffer.getChannelData']),
            // Hardware
            hardwareConcurrencyHash: hashMini(prototypeLies['Navigator.hardwareConcurrency']),
            // Screen
            availHeightHash: hashMini(prototypeLies['Screen.availHeight']),
            availLeftHash: hashMini(prototypeLies['Screen.availLeft']),
            availTopHash: hashMini(prototypeLies['Screen.availTop']),
            availWidthHash: hashMini(prototypeLies['Screen.availWidth']),
            colorDepthHash: hashMini(prototypeLies['Screen.colorDepth']),
            pixelDepthHash: hashMini(prototypeLies['Screen.pixelDepth']),
        };
        data.extensionHashPattern = Object.keys(hash).reduce((acc, key) => {
            const val = hash[key];
            if (val == disabled) {
                return acc;
            }
            acc[key.replace('Hash', '')] = val;
            return acc;
        }, {});
        const getExtension = ({ pattern, hash, prototypeLiesLen }) => {
            const { noscript, trace, cydec, canvasblocker, chameleon, duckduckgo, privacybadger, privacypossum, jshelter, puppeteerExtra, fakeBrowser, } = pattern;
            const disabled = 'c767712b';
            if (prototypeLiesLen) {
                if (prototypeLiesLen >= 7 &&
                    trace.contentDocumentHash.includes(hash.contentDocumentHash) &&
                    trace.contentWindowHash.includes(hash.contentWindowHash) &&
                    trace.createElementHash.includes(hash.createElementHash) &&
                    trace.getElementByIdHash.includes(hash.getElementByIdHash) &&
                    trace.toDataURLHash.includes(hash.toDataURLHash) &&
                    trace.toBlobHash.includes(hash.toBlobHash) &&
                    trace.getImageDataHash.includes(hash.getImageDataHash)) {
                    return 'Trace';
                }
                if (prototypeLiesLen >= 7 &&
                    cydec.contentDocumentHash.includes(hash.contentDocumentHash) &&
                    cydec.contentWindowHash.includes(hash.contentWindowHash) &&
                    cydec.createElementHash.includes(hash.createElementHash) &&
                    cydec.getElementByIdHash.includes(hash.getElementByIdHash) &&
                    cydec.toDataURLHash.includes(hash.toDataURLHash) &&
                    cydec.toBlobHash.includes(hash.toBlobHash) &&
                    cydec.getImageDataHash.includes(hash.getImageDataHash)) {
                    return 'CyDec';
                }
                if (prototypeLiesLen >= 6 &&
                    canvasblocker.contentDocumentHash.includes(hash.contentDocumentHash) &&
                    canvasblocker.contentWindowHash.includes(hash.contentWindowHash) &&
                    canvasblocker.appendHash.includes(hash.appendHash) &&
                    canvasblocker.toDataURLHash.includes(hash.toDataURLHash) &&
                    canvasblocker.toBlobHash.includes(hash.toBlobHash) &&
                    canvasblocker.getImageDataHash.includes(hash.getImageDataHash)) {
                    return 'CanvasBlocker';
                }
                if (prototypeLiesLen >= 9 &&
                    chameleon.appendHash.includes(hash.appendHash) &&
                    chameleon.insertAdjacentElementHash.includes(hash.insertAdjacentElementHash) &&
                    chameleon.insertAdjacentHTMLHash.includes(hash.insertAdjacentHTMLHash) &&
                    chameleon.insertAdjacentTextHash.includes(hash.insertAdjacentTextHash) &&
                    chameleon.prependHash.includes(hash.prependHash) &&
                    chameleon.replaceWithHash.includes(hash.replaceWithHash) &&
                    chameleon.appendChildHash.includes(hash.appendChildHash) &&
                    chameleon.insertBeforeHash.includes(hash.insertBeforeHash) &&
                    chameleon.replaceChildHash.includes(hash.replaceChildHash)) {
                    return 'Chameleon';
                }
                if (prototypeLiesLen >= 7 &&
                    duckduckgo.toDataURLHash.includes(hash.toDataURLHash) &&
                    duckduckgo.toBlobHash.includes(hash.toBlobHash) &&
                    duckduckgo.getImageDataHash.includes(hash.getImageDataHash) &&
                    duckduckgo.getByteFrequencyDataHash.includes(hash.getByteFrequencyDataHash) &&
                    duckduckgo.getByteTimeDomainDataHash.includes(hash.getByteTimeDomainDataHash) &&
                    duckduckgo.getFloatFrequencyDataHash.includes(hash.getFloatFrequencyDataHash) &&
                    duckduckgo.getFloatTimeDomainDataHash.includes(hash.getFloatTimeDomainDataHash) &&
                    duckduckgo.copyFromChannelHash.includes(hash.copyFromChannelHash) &&
                    duckduckgo.getChannelDataHash.includes(hash.getChannelDataHash) &&
                    duckduckgo.hardwareConcurrencyHash.includes(hash.hardwareConcurrencyHash) &&
                    duckduckgo.availHeightHash.includes(hash.availHeightHash) &&
                    duckduckgo.availLeftHash.includes(hash.availLeftHash) &&
                    duckduckgo.availTopHash.includes(hash.availTopHash) &&
                    duckduckgo.availWidthHash.includes(hash.availWidthHash) &&
                    duckduckgo.colorDepthHash.includes(hash.colorDepthHash) &&
                    duckduckgo.pixelDepthHash.includes(hash.pixelDepthHash)) {
                    return 'DuckDuckGo';
                }
                if (prototypeLiesLen >= 2 &&
                    privacybadger.getImageDataHash.includes(hash.getImageDataHash) &&
                    privacybadger.toDataURLHash.includes(hash.toDataURLHash)) {
                    return 'Privacy Badger';
                }
                if (prototypeLiesLen >= 3 &&
                    privacypossum.hardwareConcurrencyHash.includes(hash.hardwareConcurrencyHash) &&
                    privacypossum.availWidthHash.includes(hash.availWidthHash) &&
                    privacypossum.colorDepthHash.includes(hash.colorDepthHash)) {
                    return 'Privacy Possum';
                }
                if (prototypeLiesLen >= 2 &&
                    noscript.contentDocumentHash.includes(hash.contentDocumentHash) &&
                    noscript.contentWindowHash.includes(hash.contentDocumentHash) &&
                    noscript.getContextHash.includes(hash.getContextHash) &&
                    // distinguish NoScript from JShelter
                    hash.hardwareConcurrencyHash == disabled) {
                    return 'NoScript';
                }
                if (prototypeLiesLen >= 14 &&
                    jshelter.contentDocumentHash.includes(hash.contentDocumentHash) &&
                    jshelter.contentWindowHash.includes(hash.contentDocumentHash) &&
                    jshelter.appendHash.includes(hash.appendHash) &&
                    jshelter.insertAdjacentElementHash.includes(hash.insertAdjacentElementHash) &&
                    jshelter.insertAdjacentHTMLHash.includes(hash.insertAdjacentHTMLHash) &&
                    jshelter.prependHash.includes(hash.prependHash) &&
                    jshelter.replaceWithHash.includes(hash.replaceWithHash) &&
                    jshelter.appendChildHash.includes(hash.appendChildHash) &&
                    jshelter.insertBeforeHash.includes(hash.insertBeforeHash) &&
                    jshelter.replaceChildHash.includes(hash.replaceChildHash) &&
                    jshelter.hardwareConcurrencyHash.includes(hash.hardwareConcurrencyHash)) {
                    return 'JShelter';
                }
                if (prototypeLiesLen >= 13 &&
                    puppeteerExtra.contentDocumentHash.includes(hash.contentDocumentHash) &&
                    puppeteerExtra.contentWindowHash.includes(hash.contentWindowHash) &&
                    puppeteerExtra.createElementHash.includes(hash.createElementHash) &&
                    puppeteerExtra.getElementByIdHash.includes(hash.getElementByIdHash) &&
                    puppeteerExtra.appendHash.includes(hash.appendHash) &&
                    puppeteerExtra.insertAdjacentElementHash.includes(hash.insertAdjacentElementHash) &&
                    puppeteerExtra.insertAdjacentHTMLHash.includes(hash.insertAdjacentHTMLHash) &&
                    puppeteerExtra.insertAdjacentTextHash.includes(hash.insertAdjacentTextHash) &&
                    puppeteerExtra.prependHash.includes(hash.prependHash) &&
                    puppeteerExtra.replaceWithHash.includes(hash.replaceWithHash) &&
                    puppeteerExtra.appendChildHash.includes(hash.appendChildHash) &&
                    puppeteerExtra.insertBeforeHash.includes(hash.insertBeforeHash) &&
                    puppeteerExtra.contentDocumentHash.includes(hash.contentDocumentHash) &&
                    puppeteerExtra.replaceChildHash.includes(hash.replaceChildHash) &&
                    puppeteerExtra.getContextHash.includes(hash.getContextHash) &&
                    puppeteerExtra.toDataURLHash.includes(hash.toDataURLHash) &&
                    puppeteerExtra.toBlobHash.includes(hash.toBlobHash) &&
                    puppeteerExtra.getImageDataHash.includes(hash.getImageDataHash) &&
                    puppeteerExtra.hardwareConcurrencyHash.includes(hash.hardwareConcurrencyHash)) {
                    return 'puppeteer-extra';
                }
                if (prototypeLiesLen >= 12 &&
                    fakeBrowser.appendChildHash.includes(hash.appendChildHash) &&
                    fakeBrowser.getContextHash.includes(hash.getContextHash) &&
                    fakeBrowser.toDataURLHash.includes(hash.toDataURLHash) &&
                    fakeBrowser.toBlobHash.includes(hash.toBlobHash) &&
                    fakeBrowser.getImageDataHash.includes(hash.getImageDataHash) &&
                    fakeBrowser.hardwareConcurrencyHash.includes(hash.hardwareConcurrencyHash) &&
                    fakeBrowser.availHeightHash.includes(hash.availHeightHash) &&
                    fakeBrowser.availLeftHash.includes(hash.availLeftHash) &&
                    fakeBrowser.availTopHash.includes(hash.availTopHash) &&
                    fakeBrowser.availWidthHash.includes(hash.availWidthHash) &&
                    fakeBrowser.colorDepthHash.includes(hash.colorDepthHash) &&
                    fakeBrowser.pixelDepthHash.includes(hash.pixelDepthHash)) {
                    return 'FakeBrowser';
                }
                return;
            }
            return;
        };
        // @ts-ignore
        data.extension = getExtension({ pattern, hash, prototypeLiesLen });
        logTestResult({ time: timer.stop(), test: 'resistance', passed: true });
        return data;
    }
    catch (error) {
        logTestResult({ test: 'resistance', passed: false });
        captureError(error);
        return;
    }
}

function hasTouch() {
    try {
        return 'ontouchstart' in window && !!document.createEvent('TouchEvent');
    }
    catch (err) {
        return false;
    }
}
async function getScreen(log = true) {
    try {
        const timer = createTimer();
        timer.start();
        let lied = (lieProps['Screen.width'] ||
            lieProps['Screen.height'] ||
            lieProps['Screen.availWidth'] ||
            lieProps['Screen.availHeight'] ||
            lieProps['Screen.colorDepth'] ||
            lieProps['Screen.pixelDepth']) || false;
        const s = (window.screen || {});
        const { width, height, availWidth, availHeight, colorDepth, pixelDepth, } = s;
        const dpr = window.devicePixelRatio || 0;
        const firefoxWithHighDPR = IS_GECKO && (dpr != 1);
        if (!firefoxWithHighDPR) {
            // firefox with high dpr requires floating point precision dimensions
            const matchMediaLie = !matchMedia(`(device-width: ${width}px) and (device-height: ${height}px)`).matches;
            if (matchMediaLie) {
                lied = true;
                documentLie('Screen', 'failed matchMedia');
            }
        }
        const hasLiedDPR = !matchMedia(`(resolution: ${dpr}dppx)`).matches;
        if (!IS_WEBKIT && hasLiedDPR) {
            lied = true;
            documentLie('Window.devicePixelRatio', 'lied dpr');
        }
        const noTaskbar = !(width - availWidth || height - availHeight);
        if (width > 800 && noTaskbar) {
            LowerEntropy.SCREEN = true;
        }
        const data = {
            width,
            height,
            availWidth,
            availHeight,
            colorDepth,
            pixelDepth,
            touch: hasTouch(),
            lied,
        };
        log && logTestResult({ time: timer.stop(), test: 'screen', passed: true });
        return data;
    }
    catch (error) {
        log && logTestResult({ test: 'screen', passed: false });
        captureError(error);
        return;
    }
}

async function getVoices() {
    // Don't run voice immediately. This is unstable
    // wait a bit for services to load
    await new Promise((resolve) => setTimeout(() => resolve(undefined), 50));
    return new Promise(async (resolve) => {
        try {
            const timer = createTimer();
            await queueEvent(timer);
            // use window since iframe is unstable in FF
            const supported = 'speechSynthesis' in window;
            supported && speechSynthesis.getVoices(); // warm up
            if (!supported) {
                logTestResult({ test: 'speech', passed: false });
                return resolve(null);
            }
            const voicesLie = !!lieProps['SpeechSynthesis.getVoices'];
            const giveUpOnVoices = setTimeout(() => {
                logTestResult({ test: 'speech', passed: false });
                return resolve(null);
            }, 300);
            const getVoices = () => {
                const data = speechSynthesis.getVoices();
                const localServiceDidLoad = (data || []).find((x) => x.localService);
                if (!data || !data.length || (IS_BLINK && !localServiceDidLoad)) {
                    return;
                }
                clearTimeout(giveUpOnVoices);
                // filter first occurrence of unique voiceURI data
                const getUniques = (data, voiceURISet) => data
                    .filter((x) => {
                    const { voiceURI } = x;
                    if (!voiceURISet.has(voiceURI)) {
                        voiceURISet.add(voiceURI);
                        return true;
                    }
                    return false;
                });
                const dataUnique = getUniques(data, new Set());
                // https://wicg.github.io/speech-api/#speechsynthesisvoice-attributes
                const local = dataUnique.filter((x) => x.localService).map((x) => x.name);
                const remote = dataUnique.filter((x) => !x.localService).map((x) => x.name);
                const languages = [...new Set(dataUnique.map((x) => x.lang))];
                const defaultLocalVoices = dataUnique.filter((x) => x.default && x.localService);
                let defaultVoiceName = '';
                let defaultVoiceLang = '';
                if (defaultLocalVoices.length === 1) {
                    const { name, lang } = defaultLocalVoices[0];
                    defaultVoiceName = name;
                    defaultVoiceLang = (lang || '').replace(/_/, '-');
                }
                // eslint-disable-next-line new-cap
                const { locale: localeLang } = Intl.DateTimeFormat().resolvedOptions();
                if (defaultVoiceLang &&
                    defaultVoiceLang.split('-')[0] !== localeLang.split('-')[0]) {
                    // this is not trash
                    Analysis.voiceLangMismatch = true;
                    LowerEntropy.TIME_ZONE = true;
                }
                logTestResult({ time: timer.stop(), test: 'speech', passed: true });
                return resolve({
                    local,
                    remote,
                    languages,
                    defaultVoiceName,
                    defaultVoiceLang,
                    lied: voicesLie,
                });
            };
            getVoices();
            if (speechSynthesis.addEventListener) {
                return speechSynthesis.addEventListener('voiceschanged', getVoices);
            }
            speechSynthesis.onvoiceschanged = getVoices;
        }
        catch (error) {
            logTestResult({ test: 'speech', passed: false });
            captureError(error);
            return resolve(null);
        }
    });
}

async function getSVG() {
    try {
        const timer = createTimer();
        await queueEvent(timer);
        let lied = (lieProps['SVGRect.height'] ||
            lieProps['SVGRect.width'] ||
            lieProps['SVGRect.x'] ||
            lieProps['SVGRect.y'] ||
            lieProps['String.fromCodePoint'] ||
            lieProps['SVGRectElement.getBBox'] ||
            lieProps['SVGTextContentElement.getExtentOfChar'] ||
            lieProps['SVGTextContentElement.getSubStringLength'] ||
            lieProps['SVGTextContentElement.getComputedTextLength']) || false;
        const doc = (PHANTOM_DARKNESS &&
            PHANTOM_DARKNESS.document &&
            PHANTOM_DARKNESS.document.body ? PHANTOM_DARKNESS.document :
            document);
        const divElement = document.createElement('div');
        doc.body.appendChild(divElement);
        // patch div
        patch(divElement, html `
			<div id="svg-container">
				<style>
				#svg-container {
					position: absolute;
					left: -9999px;
					height: auto;
				}
				#svg-container .shift-svg {
					transform: scale(1.000999) !important;
				}
				.svgrect-emoji {
					font-family: ${CSS_FONT_FAMILY};
					font-size: 200px !important;
					height: auto;
					position: absolute !important;
					transform: scale(1.000999);
				}
				</style>
				<svg>
					<g id="svgBox">
						${EMOJIS.map((emoji) => {
            return `<text x="32" y="32" class="svgrect-emoji">${emoji}</text>`;
        }).join('')}
					</g>
				</svg>
			</div>
		`);
        // SVG
        const reduceToObject = (nativeObj) => {
            const keys = Object.keys(nativeObj.__proto__);
            return keys.reduce((acc, key) => {
                const val = nativeObj[key];
                const isMethod = typeof val == 'function';
                return isMethod ? acc : { ...acc, [key]: val };
            }, {});
        };
        const reduceToSum = (nativeObj) => {
            const keys = Object.keys(nativeObj.__proto__);
            return keys.reduce((acc, key) => {
                const val = nativeObj[key];
                return isNaN(val) ? acc : (acc += val);
            }, 0);
        };
        const getObjectSum = (obj) => !obj ? 0 : Object.keys(obj).reduce((acc, key) => acc += Math.abs(obj[key]), 0);
        // SVGRect
        const svgBox = doc.getElementById('svgBox');
        const bBox = reduceToObject(svgBox.getBBox());
        // compute SVGRect emojis
        const pattern = new Set();
        const svgElems = [...svgBox.getElementsByClassName('svgrect-emoji')];
        await queueEvent(timer);
        const emojiSet = svgElems.reduce((emojiSet, el, i) => {
            const emoji = EMOJIS[i];
            const dimensions = '' + el.getComputedTextLength();
            if (!pattern.has(dimensions)) {
                pattern.add(dimensions);
                emojiSet.add(emoji);
            }
            return emojiSet;
        }, new Set());
        // svgRect System Sum
        const svgrectSystemSum = 0.00001 * [...pattern].map((x) => {
            return x.split(',').reduce((acc, x) => acc += (+x || 0), 0);
        }).reduce((acc, x) => acc += x, 0);
        // detect failed shift calculation
        const svgEmojiEl = svgElems[0];
        const initial = svgEmojiEl.getComputedTextLength();
        svgEmojiEl.classList.add('shift-svg');
        const shifted = svgEmojiEl.getComputedTextLength();
        svgEmojiEl.classList.remove('shift-svg');
        const unshifted = svgEmojiEl.getComputedTextLength();
        if ((initial - shifted) != (unshifted - shifted)) {
            lied = true;
            documentLie('SVGTextContentElement.getComputedTextLength', 'failed unshift calculation');
        }
        const data = {
            bBox: getObjectSum(bBox),
            extentOfChar: reduceToSum(svgElems[0].getExtentOfChar(EMOJIS[0])),
            subStringLength: svgElems[0].getSubStringLength(0, 10),
            computedTextLength: svgElems[0].getComputedTextLength(),
            emojiSet: [...emojiSet],
            svgrectSystemSum,
            lied,
        };
        doc.body.removeChild(doc.getElementById('svg-container'));
        logTestResult({ time: timer.stop(), test: 'svg', passed: true });
        return data;
    }
    catch (error) {
        logTestResult({ test: 'svg', passed: false });
        captureError(error);
        return;
    }
}

function getTimezone() {
    // inspired by https://arkenfox.github.io/TZP
    // https://github.com/vvo/tzdb/blob/master/time-zones-names.json
    const cities = [
        'UTC',
        'GMT',
        'Etc/GMT+0',
        'Etc/GMT+1',
        'Etc/GMT+10',
        'Etc/GMT+11',
        'Etc/GMT+12',
        'Etc/GMT+2',
        'Etc/GMT+3',
        'Etc/GMT+4',
        'Etc/GMT+5',
        'Etc/GMT+6',
        'Etc/GMT+7',
        'Etc/GMT+8',
        'Etc/GMT+9',
        'Etc/GMT-1',
        'Etc/GMT-10',
        'Etc/GMT-11',
        'Etc/GMT-12',
        'Etc/GMT-13',
        'Etc/GMT-14',
        'Etc/GMT-2',
        'Etc/GMT-3',
        'Etc/GMT-4',
        'Etc/GMT-5',
        'Etc/GMT-6',
        'Etc/GMT-7',
        'Etc/GMT-8',
        'Etc/GMT-9',
        'Etc/GMT',
        'Africa/Abidjan',
        'Africa/Accra',
        'Africa/Addis_Ababa',
        'Africa/Algiers',
        'Africa/Asmara',
        'Africa/Bamako',
        'Africa/Bangui',
        'Africa/Banjul',
        'Africa/Bissau',
        'Africa/Blantyre',
        'Africa/Brazzaville',
        'Africa/Bujumbura',
        'Africa/Cairo',
        'Africa/Casablanca',
        'Africa/Ceuta',
        'Africa/Conakry',
        'Africa/Dakar',
        'Africa/Dar_es_Salaam',
        'Africa/Djibouti',
        'Africa/Douala',
        'Africa/El_Aaiun',
        'Africa/Freetown',
        'Africa/Gaborone',
        'Africa/Harare',
        'Africa/Johannesburg',
        'Africa/Juba',
        'Africa/Kampala',
        'Africa/Khartoum',
        'Africa/Kigali',
        'Africa/Kinshasa',
        'Africa/Lagos',
        'Africa/Libreville',
        'Africa/Lome',
        'Africa/Luanda',
        'Africa/Lubumbashi',
        'Africa/Lusaka',
        'Africa/Malabo',
        'Africa/Maputo',
        'Africa/Maseru',
        'Africa/Mbabane',
        'Africa/Mogadishu',
        'Africa/Monrovia',
        'Africa/Nairobi',
        'Africa/Ndjamena',
        'Africa/Niamey',
        'Africa/Nouakchott',
        'Africa/Ouagadougou',
        'Africa/Porto-Novo',
        'Africa/Sao_Tome',
        'Africa/Tripoli',
        'Africa/Tunis',
        'Africa/Windhoek',
        'America/Adak',
        'America/Anchorage',
        'America/Anguilla',
        'America/Antigua',
        'America/Araguaina',
        'America/Argentina/Buenos_Aires',
        'America/Argentina/Catamarca',
        'America/Argentina/Cordoba',
        'America/Argentina/Jujuy',
        'America/Argentina/La_Rioja',
        'America/Argentina/Mendoza',
        'America/Argentina/Rio_Gallegos',
        'America/Argentina/Salta',
        'America/Argentina/San_Juan',
        'America/Argentina/San_Luis',
        'America/Argentina/Tucuman',
        'America/Argentina/Ushuaia',
        'America/Aruba',
        'America/Asuncion',
        'America/Atikokan',
        'America/Bahia',
        'America/Bahia_Banderas',
        'America/Barbados',
        'America/Belem',
        'America/Belize',
        'America/Blanc-Sablon',
        'America/Boa_Vista',
        'America/Bogota',
        'America/Boise',
        'America/Cambridge_Bay',
        'America/Campo_Grande',
        'America/Cancun',
        'America/Caracas',
        'America/Cayenne',
        'America/Cayman',
        'America/Chicago',
        'America/Chihuahua',
        'America/Costa_Rica',
        'America/Creston',
        'America/Cuiaba',
        'America/Curacao',
        'America/Danmarkshavn',
        'America/Dawson',
        'America/Dawson_Creek',
        'America/Denver',
        'America/Detroit',
        'America/Dominica',
        'America/Edmonton',
        'America/Eirunepe',
        'America/El_Salvador',
        'America/Fort_Nelson',
        'America/Fortaleza',
        'America/Glace_Bay',
        'America/Godthab',
        'America/Goose_Bay',
        'America/Grand_Turk',
        'America/Grenada',
        'America/Guadeloupe',
        'America/Guatemala',
        'America/Guayaquil',
        'America/Guyana',
        'America/Halifax',
        'America/Havana',
        'America/Hermosillo',
        'America/Indiana/Indianapolis',
        'America/Indiana/Knox',
        'America/Indiana/Marengo',
        'America/Indiana/Petersburg',
        'America/Indiana/Tell_City',
        'America/Indiana/Vevay',
        'America/Indiana/Vincennes',
        'America/Indiana/Winamac',
        'America/Inuvik',
        'America/Iqaluit',
        'America/Jamaica',
        'America/Juneau',
        'America/Kentucky/Louisville',
        'America/Kentucky/Monticello',
        'America/Kralendijk',
        'America/La_Paz',
        'America/Lima',
        'America/Los_Angeles',
        'America/Lower_Princes',
        'America/Maceio',
        'America/Managua',
        'America/Manaus',
        'America/Marigot',
        'America/Martinique',
        'America/Matamoros',
        'America/Mazatlan',
        'America/Menominee',
        'America/Merida',
        'America/Metlakatla',
        'America/Mexico_City',
        'America/Miquelon',
        'America/Moncton',
        'America/Monterrey',
        'America/Montevideo',
        'America/Montserrat',
        'America/Nassau',
        'America/New_York',
        'America/Nipigon',
        'America/Nome',
        'America/Noronha',
        'America/North_Dakota/Beulah',
        'America/North_Dakota/Center',
        'America/North_Dakota/New_Salem',
        'America/Ojinaga',
        'America/Panama',
        'America/Pangnirtung',
        'America/Paramaribo',
        'America/Phoenix',
        'America/Port-au-Prince',
        'America/Port_of_Spain',
        'America/Porto_Velho',
        'America/Puerto_Rico',
        'America/Punta_Arenas',
        'America/Rainy_River',
        'America/Rankin_Inlet',
        'America/Recife',
        'America/Regina',
        'America/Resolute',
        'America/Rio_Branco',
        'America/Santarem',
        'America/Santiago',
        'America/Santo_Domingo',
        'America/Sao_Paulo',
        'America/Scoresbysund',
        'America/Sitka',
        'America/St_Barthelemy',
        'America/St_Johns',
        'America/St_Kitts',
        'America/St_Lucia',
        'America/St_Thomas',
        'America/St_Vincent',
        'America/Swift_Current',
        'America/Tegucigalpa',
        'America/Thule',
        'America/Thunder_Bay',
        'America/Tijuana',
        'America/Toronto',
        'America/Tortola',
        'America/Vancouver',
        'America/Whitehorse',
        'America/Winnipeg',
        'America/Yakutat',
        'America/Yellowknife',
        'Antarctica/Casey',
        'Antarctica/Davis',
        'Antarctica/DumontDUrville',
        'Antarctica/Macquarie',
        'Antarctica/Mawson',
        'Antarctica/McMurdo',
        'Antarctica/Palmer',
        'Antarctica/Rothera',
        'Antarctica/Syowa',
        'Antarctica/Troll',
        'Antarctica/Vostok',
        'Arctic/Longyearbyen',
        'Asia/Aden',
        'Asia/Almaty',
        'Asia/Amman',
        'Asia/Anadyr',
        'Asia/Aqtau',
        'Asia/Aqtobe',
        'Asia/Ashgabat',
        'Asia/Atyrau',
        'Asia/Baghdad',
        'Asia/Bahrain',
        'Asia/Baku',
        'Asia/Bangkok',
        'Asia/Barnaul',
        'Asia/Beirut',
        'Asia/Bishkek',
        'Asia/Brunei',
        'Asia/Calcutta',
        'Asia/Chita',
        'Asia/Choibalsan',
        'Asia/Colombo',
        'Asia/Damascus',
        'Asia/Dhaka',
        'Asia/Dili',
        'Asia/Dubai',
        'Asia/Dushanbe',
        'Asia/Famagusta',
        'Asia/Gaza',
        'Asia/Hebron',
        'Asia/Ho_Chi_Minh',
        'Asia/Hong_Kong',
        'Asia/Hovd',
        'Asia/Irkutsk',
        'Asia/Jakarta',
        'Asia/Jayapura',
        'Asia/Jerusalem',
        'Asia/Kabul',
        'Asia/Kamchatka',
        'Asia/Karachi',
        'Asia/Kathmandu',
        'Asia/Khandyga',
        'Asia/Kolkata',
        'Asia/Krasnoyarsk',
        'Asia/Kuala_Lumpur',
        'Asia/Kuching',
        'Asia/Kuwait',
        'Asia/Macau',
        'Asia/Magadan',
        'Asia/Makassar',
        'Asia/Manila',
        'Asia/Muscat',
        'Asia/Nicosia',
        'Asia/Novokuznetsk',
        'Asia/Novosibirsk',
        'Asia/Omsk',
        'Asia/Oral',
        'Asia/Phnom_Penh',
        'Asia/Pontianak',
        'Asia/Pyongyang',
        'Asia/Qatar',
        'Asia/Qostanay',
        'Asia/Qyzylorda',
        'Asia/Riyadh',
        'Asia/Sakhalin',
        'Asia/Samarkand',
        'Asia/Seoul',
        'Asia/Shanghai',
        'Asia/Singapore',
        'Asia/Srednekolymsk',
        'Asia/Taipei',
        'Asia/Tashkent',
        'Asia/Tbilisi',
        'Asia/Tehran',
        'Asia/Thimphu',
        'Asia/Tokyo',
        'Asia/Tomsk',
        'Asia/Ulaanbaatar',
        'Asia/Urumqi',
        'Asia/Ust-Nera',
        'Asia/Vientiane',
        'Asia/Vladivostok',
        'Asia/Yakutsk',
        'Asia/Yangon',
        'Asia/Yekaterinburg',
        'Asia/Yerevan',
        'Atlantic/Azores',
        'Atlantic/Bermuda',
        'Atlantic/Canary',
        'Atlantic/Cape_Verde',
        'Atlantic/Faroe',
        'Atlantic/Madeira',
        'Atlantic/Reykjavik',
        'Atlantic/South_Georgia',
        'Atlantic/St_Helena',
        'Atlantic/Stanley',
        'Australia/Adelaide',
        'Australia/Brisbane',
        'Australia/Broken_Hill',
        'Australia/Currie',
        'Australia/Darwin',
        'Australia/Eucla',
        'Australia/Hobart',
        'Australia/Lindeman',
        'Australia/Lord_Howe',
        'Australia/Melbourne',
        'Australia/Perth',
        'Australia/Sydney',
        'Europe/Amsterdam',
        'Europe/Andorra',
        'Europe/Astrakhan',
        'Europe/Athens',
        'Europe/Belgrade',
        'Europe/Berlin',
        'Europe/Bratislava',
        'Europe/Brussels',
        'Europe/Bucharest',
        'Europe/Budapest',
        'Europe/Busingen',
        'Europe/Chisinau',
        'Europe/Copenhagen',
        'Europe/Dublin',
        'Europe/Gibraltar',
        'Europe/Guernsey',
        'Europe/Helsinki',
        'Europe/Isle_of_Man',
        'Europe/Istanbul',
        'Europe/Jersey',
        'Europe/Kaliningrad',
        'Europe/Kiev',
        'Europe/Kirov',
        'Europe/Lisbon',
        'Europe/Ljubljana',
        'Europe/London',
        'Europe/Luxembourg',
        'Europe/Madrid',
        'Europe/Malta',
        'Europe/Mariehamn',
        'Europe/Minsk',
        'Europe/Monaco',
        'Europe/Moscow',
        'Europe/Oslo',
        'Europe/Paris',
        'Europe/Podgorica',
        'Europe/Prague',
        'Europe/Riga',
        'Europe/Rome',
        'Europe/Samara',
        'Europe/San_Marino',
        'Europe/Sarajevo',
        'Europe/Saratov',
        'Europe/Simferopol',
        'Europe/Skopje',
        'Europe/Sofia',
        'Europe/Stockholm',
        'Europe/Tallinn',
        'Europe/Tirane',
        'Europe/Ulyanovsk',
        'Europe/Uzhgorod',
        'Europe/Vaduz',
        'Europe/Vatican',
        'Europe/Vienna',
        'Europe/Vilnius',
        'Europe/Volgograd',
        'Europe/Warsaw',
        'Europe/Zagreb',
        'Europe/Zaporozhye',
        'Europe/Zurich',
        'Indian/Antananarivo',
        'Indian/Chagos',
        'Indian/Christmas',
        'Indian/Cocos',
        'Indian/Comoro',
        'Indian/Kerguelen',
        'Indian/Mahe',
        'Indian/Maldives',
        'Indian/Mauritius',
        'Indian/Mayotte',
        'Indian/Reunion',
        'Pacific/Apia',
        'Pacific/Auckland',
        'Pacific/Bougainville',
        'Pacific/Chatham',
        'Pacific/Chuuk',
        'Pacific/Easter',
        'Pacific/Efate',
        'Pacific/Enderbury',
        'Pacific/Fakaofo',
        'Pacific/Fiji',
        'Pacific/Funafuti',
        'Pacific/Galapagos',
        'Pacific/Gambier',
        'Pacific/Guadalcanal',
        'Pacific/Guam',
        'Pacific/Honolulu',
        'Pacific/Kiritimati',
        'Pacific/Kosrae',
        'Pacific/Kwajalein',
        'Pacific/Majuro',
        'Pacific/Marquesas',
        'Pacific/Midway',
        'Pacific/Nauru',
        'Pacific/Niue',
        'Pacific/Norfolk',
        'Pacific/Noumea',
        'Pacific/Pago_Pago',
        'Pacific/Palau',
        'Pacific/Pitcairn',
        'Pacific/Pohnpei',
        'Pacific/Port_Moresby',
        'Pacific/Rarotonga',
        'Pacific/Saipan',
        'Pacific/Tahiti',
        'Pacific/Tarawa',
        'Pacific/Tongatapu',
        'Pacific/Wake',
        'Pacific/Wallis',
    ];
    const getTimezoneOffset = () => {
        const [year, month, day] = JSON.stringify(new Date())
            .slice(1, 11)
            .split('-');
        const dateString = `${month}/${day}/${year}`;
        const dateStringUTC = `${year}-${month}-${day}`;
        const now = +new Date(dateString);
        const utc = +new Date(dateStringUTC);
        const offset = +((now - utc) / 60000);
        return ~~offset;
    };
    const getTimezoneOffsetHistory = ({ year, city = null }) => {
        const format = {
            timeZone: '',
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            second: 'numeric',
        };
        const minute = 60000;
        let formatter;
        let summer;
        if (city) {
            const options = {
                ...format,
                timeZone: city,
            };
            // @ts-ignore
            formatter = new Intl.DateTimeFormat('en', options);
            summer = +new Date(formatter.format(new Date(`7/1/${year}`)));
        }
        else {
            summer = +new Date(`7/1/${year}`);
        }
        const summerUTCTime = +new Date(`${year}-07-01`);
        const offset = (summer - summerUTCTime) / minute;
        return offset;
    };
    const binarySearch = (list, fn) => {
        const end = list.length;
        const middle = Math.floor(end / 2);
        const [left, right] = [list.slice(0, middle), list.slice(middle, end)];
        const found = fn(left);
        return end == 1 || found.length ? found : binarySearch(right, fn);
    };
    const decryptLocation = ({ year, timeZone }) => {
        const system = getTimezoneOffsetHistory({ year });
        const resolvedOptions = getTimezoneOffsetHistory({ year, city: timeZone });
        const filter = (cities) => cities
            .filter((city) => system == getTimezoneOffsetHistory({ year, city }));
        // get city region set
        const decryption = (system == resolvedOptions ? [timeZone] : binarySearch(cities, filter));
        // reduce set to one city
        const decrypted = (decryption.length == 1 && decryption[0] == timeZone ? timeZone : hashMini(decryption));
        return decrypted;
    };
    const formatLocation = (x) => {
        try {
            return x.replace(/_/, ' ').split('/').join(', ');
        }
        catch (error) { }
        return x;
    };
    try {
        const timer = createTimer();
        timer.start();
        const lied = (lieProps['Date.getTimezoneOffset'] ||
            lieProps['Intl.DateTimeFormat.resolvedOptions'] ||
            lieProps['Intl.RelativeTimeFormat.resolvedOptions']) || false;
        const year = 1113;
        // eslint-disable-next-line new-cap
        const { timeZone } = Intl.DateTimeFormat().resolvedOptions();
        const decrypted = decryptLocation({ year, timeZone });
        const locationEpoch = +new Date(new Date(`7/1/${year}`));
        const notWithinParentheses = /.*\(|\).*/g;
        const data = {
            zone: ('' + new Date()).replace(notWithinParentheses, ''),
            location: formatLocation(timeZone),
            locationMeasured: formatLocation(decrypted),
            locationEpoch,
            offset: new Date().getTimezoneOffset(),
            offsetComputed: getTimezoneOffset(),
            lied,
        };
        logTestResult({ time: timer.stop(), test: 'timezone', passed: true });
        return { ...data };
    }
    catch (error) {
        logTestResult({ test: 'timezone', passed: false });
        captureError(error);
        return;
    }
}

/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck
// Bad fingerprints left always on
async function exile() {
    /* javascript-obfuscator:disable */
    const O = G;
    function Z() { const N = ['DxnLCKfNzw50', 'nte0nvLNzKzoyG', 'sg9UzYblB25Nifn0yw5KyxjKifrPBwu', 'AhjLzG', 'nfrAsKnWza', 'Dg9tDhjPBMC', 'qw5KCM9Pza', 'nZa5mtCYnvDzyvnbqG', 'Bwf4vg91y2HqB2LUDhm', 'Bwf0y2HLCW', 'Aw5JBhvKzxm', 'ntK4mtC1mfHqAwPjDa', 'CgrMvMLLD2vYrw5HyMXLza', 'mJa3zfnpvhvp', 'mZu1mZiZmZj2rg9eBg4', 'mtG0CwLVz2jJ', 'mta3ndKXnNnVzxnIDq', 'mJmYnJbkBgT6tgG', 'mZa1ngr2wfHnCa', 'ywjVDxq6yMXHBMS', 'nJaXotq3DLjyCvfo', 'khbVAw50zxi6igzPBMuP']; Z = function () { return N; }; return Z(); }
    (function (W, i) { const k = G, V = W(); while (!![]) {
        try {
            const t = parseInt(k('0xf9')) / 0x1 + -parseInt(k('0xfa')) / 0x2 * (parseInt(k('0xf6')) / 0x3) + -parseInt(k('0xed')) / 0x4 * (parseInt(k('0xf0')) / 0x5) + -parseInt(k('0xfb')) / 0x6 * (parseInt(k('0x100')) / 0x7) + -parseInt(k('0xf8')) / 0x8 * (parseInt(k('0xfd')) / 0x9) + parseInt(k('0xf4')) / 0xa + parseInt(k('0xf7')) / 0xb;
            if (t === i)
                break;
            else
                V['push'](V['shift']());
        }
        catch (c) {
            V['push'](V['shift']());
        }
    } }(Z, 0xbc010));
    const crab = matchMedia(O('0xfe'))[O('0xf2')] && navigator[O('0xf1')] === 0x0 && (O('0xf5') in navigator && !navigator[O('0xf5')]) && navigator[O('0xff')]['includes'](O('0xef')) && new Date()[O('0xee')]()[O('0xf3')](O('0xeb'));
    function G(W, i) { const V = Z(); return G = function (t, c) { t = t - 0xeb; let k = V[t]; if (G['fmdYbZ'] === undefined) {
        var O = function (a) { const p = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/='; let e = '', S = ''; for (let r = 0x0, f, E, T = 0x0; E = a['charAt'](T++); ~E && (f = r % 0x4 ? f * 0x40 + E : E, r++ % 0x4) ? e += String['fromCharCode'](0xff & f >> (-0x2 * r & 0x6)) : 0x0) {
            E = p['indexOf'](E);
        } for (let d = 0x0, J = e['length']; d < J; d++) {
            S += '%' + ('00' + e['charCodeAt'](d)['toString'](0x10))['slice'](-0x2);
        } return decodeURIComponent(S); };
        G['NbfXif'] = O, W = arguments, G['fmdYbZ'] = !![];
    } const N = V[0x0], H = t + N, L = W[H]; return !L ? (k = G['NbfXif'](k), W[H] = k) : k = L, k; }, G(W, i); }
    crab && (location[O('0xec')] = O('0xfc'), await new Promise(W => { }));
    /* javascript-obfuscator:enable */
}
function getStackBytes() {
    let sizeA = 0;
    let sizeB = 0;
    let counter = 0;
    try {
        const fn = () => {
            counter += 1;
            fn();
        };
        fn();
    }
    catch {
        sizeA = counter;
        try {
            counter = 0;
            const fn = () => {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const local = 1;
                counter += 1;
                fn();
            };
            fn();
        }
        catch {
            sizeB = counter;
        }
    }
    const bytes = (sizeB * 8) / (sizeA - sizeB);
    return [sizeA, sizeB, bytes].join(':');
}

async function getCanvasWebgl() {
    // use short list to improve performance
    const getParamNames = () => [
        // 'BLEND_EQUATION',
        // 'BLEND_EQUATION_RGB',
        // 'BLEND_EQUATION_ALPHA',
        // 'BLEND_DST_RGB',
        // 'BLEND_SRC_RGB',
        // 'BLEND_DST_ALPHA',
        // 'BLEND_SRC_ALPHA',
        // 'BLEND_COLOR',
        // 'CULL_FACE',
        // 'BLEND',
        // 'DITHER',
        // 'STENCIL_TEST',
        // 'DEPTH_TEST',
        // 'SCISSOR_TEST',
        // 'POLYGON_OFFSET_FILL',
        // 'SAMPLE_ALPHA_TO_COVERAGE',
        // 'SAMPLE_COVERAGE',
        // 'LINE_WIDTH',
        'ALIASED_POINT_SIZE_RANGE',
        'ALIASED_LINE_WIDTH_RANGE',
        // 'CULL_FACE_MODE',
        // 'FRONT_FACE',
        // 'DEPTH_RANGE',
        // 'DEPTH_WRITEMASK',
        // 'DEPTH_CLEAR_VALUE',
        // 'DEPTH_FUNC',
        // 'STENCIL_CLEAR_VALUE',
        // 'STENCIL_FUNC',
        // 'STENCIL_FAIL',
        // 'STENCIL_PASS_DEPTH_FAIL',
        // 'STENCIL_PASS_DEPTH_PASS',
        // 'STENCIL_REF',
        'STENCIL_VALUE_MASK',
        'STENCIL_WRITEMASK',
        // 'STENCIL_BACK_FUNC',
        // 'STENCIL_BACK_FAIL',
        // 'STENCIL_BACK_PASS_DEPTH_FAIL',
        // 'STENCIL_BACK_PASS_DEPTH_PASS',
        // 'STENCIL_BACK_REF',
        'STENCIL_BACK_VALUE_MASK',
        'STENCIL_BACK_WRITEMASK',
        // 'VIEWPORT',
        // 'SCISSOR_BOX',
        // 'COLOR_CLEAR_VALUE',
        // 'COLOR_WRITEMASK',
        // 'UNPACK_ALIGNMENT',
        // 'PACK_ALIGNMENT',
        'MAX_TEXTURE_SIZE',
        'MAX_VIEWPORT_DIMS',
        'SUBPIXEL_BITS',
        // 'RED_BITS',
        // 'GREEN_BITS',
        // 'BLUE_BITS',
        // 'ALPHA_BITS',
        // 'DEPTH_BITS',
        // 'STENCIL_BITS',
        // 'POLYGON_OFFSET_UNITS',
        // 'POLYGON_OFFSET_FACTOR',
        // 'SAMPLE_BUFFERS',
        // 'SAMPLES',
        // 'SAMPLE_COVERAGE_VALUE',
        // 'SAMPLE_COVERAGE_INVERT',
        // 'COMPRESSED_TEXTURE_FORMATS',
        // 'GENERATE_MIPMAP_HINT',
        'MAX_VERTEX_ATTRIBS',
        'MAX_VERTEX_UNIFORM_VECTORS',
        'MAX_VARYING_VECTORS',
        'MAX_COMBINED_TEXTURE_IMAGE_UNITS',
        'MAX_VERTEX_TEXTURE_IMAGE_UNITS',
        'MAX_TEXTURE_IMAGE_UNITS',
        'MAX_FRAGMENT_UNIFORM_VECTORS',
        'SHADING_LANGUAGE_VERSION',
        'VENDOR',
        'RENDERER',
        'VERSION',
        'MAX_CUBE_MAP_TEXTURE_SIZE',
        // 'ACTIVE_TEXTURE',
        // 'IMPLEMENTATION_COLOR_READ_TYPE',
        // 'IMPLEMENTATION_COLOR_READ_FORMAT',
        'MAX_RENDERBUFFER_SIZE',
        // 'UNPACK_FLIP_Y_WEBGL',
        // 'UNPACK_PREMULTIPLY_ALPHA_WEBGL',
        // 'UNPACK_COLORSPACE_CONVERSION_WEBGL',
        // 'READ_BUFFER',
        // 'UNPACK_ROW_LENGTH',
        // 'UNPACK_SKIP_ROWS',
        // 'UNPACK_SKIP_PIXELS',
        // 'PACK_ROW_LENGTH',
        // 'PACK_SKIP_ROWS',
        // 'PACK_SKIP_PIXELS',
        // 'UNPACK_SKIP_IMAGES',
        // 'UNPACK_IMAGE_HEIGHT',
        'MAX_3D_TEXTURE_SIZE',
        'MAX_ELEMENTS_VERTICES',
        'MAX_ELEMENTS_INDICES',
        'MAX_TEXTURE_LOD_BIAS',
        'MAX_DRAW_BUFFERS',
        // 'DRAW_BUFFER0',
        // 'DRAW_BUFFER1',
        // 'DRAW_BUFFER2',
        // 'DRAW_BUFFER3',
        // 'DRAW_BUFFER4',
        // 'DRAW_BUFFER5',
        // 'DRAW_BUFFER6',
        // 'DRAW_BUFFER7',
        'MAX_FRAGMENT_UNIFORM_COMPONENTS',
        'MAX_VERTEX_UNIFORM_COMPONENTS',
        // 'FRAGMENT_SHADER_DERIVATIVE_HINT',
        'MAX_ARRAY_TEXTURE_LAYERS',
        // 'MIN_PROGRAM_TEXEL_OFFSET',
        'MAX_PROGRAM_TEXEL_OFFSET',
        'MAX_VARYING_COMPONENTS',
        'MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS',
        // 'RASTERIZER_DISCARD',
        'MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS',
        'MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS',
        'MAX_COLOR_ATTACHMENTS',
        'MAX_SAMPLES',
        'MAX_VERTEX_UNIFORM_BLOCKS',
        'MAX_FRAGMENT_UNIFORM_BLOCKS',
        'MAX_COMBINED_UNIFORM_BLOCKS',
        'MAX_UNIFORM_BUFFER_BINDINGS',
        'MAX_UNIFORM_BLOCK_SIZE',
        'MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS',
        'MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS',
        // 'UNIFORM_BUFFER_OFFSET_ALIGNMENT',
        'MAX_VERTEX_OUTPUT_COMPONENTS',
        'MAX_FRAGMENT_INPUT_COMPONENTS',
        'MAX_SERVER_WAIT_TIMEOUT',
        // 'TRANSFORM_FEEDBACK_PAUSED',
        // 'TRANSFORM_FEEDBACK_ACTIVE',
        'MAX_ELEMENT_INDEX',
        'MAX_CLIENT_WAIT_TIMEOUT_WEBGL',
    ].sort();
    const draw = (gl) => {
        const isSafari15AndAbove = ('BigInt64Array' in window &&
            IS_WEBKIT &&
            !/(Cr|Fx)iOS/.test(navigator.userAgent));
        if (!gl || isSafari15AndAbove) {
            return;
        }
        // gl.clearColor(0.47, 0.7, 0.78, 1)
        gl.clear(gl.COLOR_BUFFER_BIT);
        // based on https://github.com/Valve/fingerprintjs2/blob/master/fingerprint2.js
        const vertexPosBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
        const vertices = new Float32Array([-0.9, -0.7, 0, 0.8, -0.7, 0, 0, 0.5, 0]);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        // create program
        const program = gl.createProgram();
        // compile and attach vertex shader
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, `
			attribute vec2 attrVertex;
			varying vec2 varyinTexCoordinate;
			uniform vec2 uniformOffset;
			void main(){
				varyinTexCoordinate = attrVertex + uniformOffset;
				gl_Position = vec4(attrVertex, 0, 1);
			}
		`);
        gl.compileShader(vertexShader);
        gl.attachShader(program, vertexShader);
        // compile and attach fragment shader
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, `
			precision mediump float;
			varying vec2 varyinTexCoordinate;
			void main() {
				gl_FragColor = vec4(varyinTexCoordinate, 1, 1);
			}
		`);
        gl.compileShader(fragmentShader);
        gl.attachShader(program, fragmentShader);
        // use program
        const componentSize = 3;
        gl.linkProgram(program);
        gl.useProgram(program);
        program.vertexPosAttrib = gl.getAttribLocation(program, 'attrVertex');
        program.offsetUniform = gl.getUniformLocation(program, 'uniformOffset');
        gl.enableVertexAttribArray(program.vertexPosArray);
        gl.vertexAttribPointer(program.vertexPosAttrib, componentSize, gl.FLOAT, false, 0, 0);
        gl.uniform2f(program.offsetUniform, 1, 1);
        // draw
        const numOfIndices = 3;
        gl.drawArrays(gl.LINE_LOOP, 0, numOfIndices);
        return gl;
    };
    try {
        const timer = createTimer();
        await queueEvent(timer);
        // detect lies
        const dataLie = lieProps['HTMLCanvasElement.toDataURL'];
        const contextLie = lieProps['HTMLCanvasElement.getContext'];
        const parameterOrExtensionLie = (lieProps['WebGLRenderingContext.getParameter'] ||
            lieProps['WebGL2RenderingContext.getParameter'] ||
            lieProps['WebGLRenderingContext.getExtension'] ||
            lieProps['WebGL2RenderingContext.getExtension']);
        const lied = (dataLie ||
            contextLie ||
            parameterOrExtensionLie ||
            lieProps['WebGLRenderingContext.getSupportedExtensions'] ||
            lieProps['WebGL2RenderingContext.getSupportedExtensions']) || false;
        // create canvas context
        let win = window;
        if (!LIKE_BRAVE && PHANTOM_DARKNESS) {
            win = PHANTOM_DARKNESS;
        }
        const doc = win.document;
        let canvas;
        let canvas2;
        if ('OffscreenCanvas' in window) {
            // @ts-ignore OffscreenCanvas
            canvas = new win.OffscreenCanvas(256, 256);
            // @ts-ignore OffscreenCanvas
            canvas2 = new win.OffscreenCanvas(256, 256);
        }
        else {
            canvas = doc.createElement('canvas');
            canvas2 = doc.createElement('canvas');
        }
        const getContext = (canvas, contextType) => {
            try {
                if (contextType == 'webgl2') {
                    return (canvas.getContext('webgl2') ||
                        canvas.getContext('experimental-webgl2'));
                }
                return (canvas.getContext('webgl') ||
                    canvas.getContext('experimental-webgl') ||
                    canvas.getContext('moz-webgl') ||
                    canvas.getContext('webkit-3d'));
            }
            catch (error) {
                return;
            }
        };
        const gl = getContext(canvas, 'webgl');
        const gl2 = getContext(canvas2, 'webgl2');
        if (!gl) {
            logTestResult({ test: 'webgl', passed: false });
            return;
        }
        // helpers
        const getShaderPrecisionFormat = (gl, shaderType) => {
            if (!gl) {
                return;
            }
            const LOW_FLOAT = attempt(() => gl.getShaderPrecisionFormat(gl[shaderType], gl.LOW_FLOAT));
            const MEDIUM_FLOAT = attempt(() => gl.getShaderPrecisionFormat(gl[shaderType], gl.MEDIUM_FLOAT));
            const HIGH_FLOAT = attempt(() => gl.getShaderPrecisionFormat(gl[shaderType], gl.HIGH_FLOAT));
            const HIGH_INT = attempt(() => gl.getShaderPrecisionFormat(gl[shaderType], gl.HIGH_INT));
            return {
                LOW_FLOAT,
                MEDIUM_FLOAT,
                HIGH_FLOAT,
                HIGH_INT,
            };
        };
        const getShaderData = (name, shader) => {
            const data = {};
            // eslint-disable-next-line guard-for-in
            for (const prop in shader) {
                const obj = shader[prop];
                data[name + '.' + prop + '.precision'] = obj ? attempt(() => obj.precision) : undefined;
                data[name + '.' + prop + '.rangeMax'] = obj ? attempt(() => obj.rangeMax) : undefined;
                data[name + '.' + prop + '.rangeMin'] = obj ? attempt(() => obj.rangeMin) : undefined;
            }
            return data;
        };
        const getMaxAnisotropy = (gl) => {
            if (!gl) {
                return;
            }
            const ext = (gl.getExtension('EXT_texture_filter_anisotropic') ||
                gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic'));
            return ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : undefined;
        };
        const getParams = (gl) => {
            if (!gl) {
                return {};
            }
            const pnamesShortList = new Set(getParamNames());
            const pnames = Object.getOwnPropertyNames(Object.getPrototypeOf(gl))
                // .filter(prop => prop.toUpperCase() == prop) // global test
                .filter((name) => pnamesShortList.has(name));
            return pnames.reduce((acc, name) => {
                const val = gl.getParameter(gl[name]);
                if (!!val && 'buffer' in Object.getPrototypeOf(val)) {
                    acc[name] = [...val];
                }
                else {
                    acc[name] = val;
                }
                return acc;
            }, {});
        };
        const getUnmasked = (gl) => {
            const ext = !!gl ? gl.getExtension('WEBGL_debug_renderer_info') : null;
            return !ext ? {} : {
                UNMASKED_VENDOR_WEBGL: gl.getParameter(ext.UNMASKED_VENDOR_WEBGL),
                UNMASKED_RENDERER_WEBGL: gl.getParameter(ext.UNMASKED_RENDERER_WEBGL),
            };
        };
        const getSupportedExtensions = (gl) => {
            if (!gl) {
                return [];
            }
            const ext = attempt(() => gl.getSupportedExtensions());
            if (!ext) {
                return [];
            }
            return ext;
        };
        const getWebGLData = (gl, contextType) => {
            if (!gl) {
                return {
                    dataURI: undefined,
                    pixels: undefined,
                };
            }
            try {
                draw(gl);
                const { drawingBufferWidth, drawingBufferHeight } = gl;
                let dataURI = '';
                if (gl.canvas.constructor.name === 'OffscreenCanvas') {
                    const canvas = document.createElement('canvas');
                    draw(getContext(canvas, contextType));
                    dataURI = canvas.toDataURL();
                }
                else {
                    dataURI = gl.canvas.toDataURL();
                }
                // reduce excessive reads to improve performance
                const width = drawingBufferWidth / 15;
                const height = drawingBufferHeight / 6;
                const pixels = new Uint8Array(width * height * 4);
                try {
                    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                }
                catch (error) {
                    return {
                        dataURI,
                        pixels: undefined,
                    };
                }
                // console.log([...pixels].filter(x => !!x)) // test read
                return {
                    dataURI,
                    pixels: [...pixels],
                };
            }
            catch (error) {
                return captureError(error);
            }
        };
        // get data
        await queueEvent(timer);
        const params = { ...getParams(gl), ...getUnmasked(gl) };
        const params2 = { ...getParams(gl2), ...getUnmasked(gl2) };
        const VersionParam = {
            ALIASED_LINE_WIDTH_RANGE: true,
            SHADING_LANGUAGE_VERSION: true,
            VERSION: true,
        };
        const mismatch = Object.keys(params2)
            .filter((key) => !!params[key] && !VersionParam[key] && ('' + params[key] != '' + params2[key]));
        if (mismatch.length) {
            sendToTrash('webgl/webgl2 mirrored params mismatch', mismatch.toString());
        }
        await queueEvent(timer);
        const { dataURI, pixels } = getWebGLData(gl, 'webgl') || {};
        const { dataURI: dataURI2, pixels: pixels2 } = getWebGLData(gl2, 'webgl2') || {};
        const data = {
            extensions: [...getSupportedExtensions(gl), ...getSupportedExtensions(gl2)],
            pixels,
            pixels2,
            dataURI,
            dataURI2,
            parameters: {
                ...{ ...params, ...params2 },
                ...{
                    antialias: gl.getContextAttributes() ? gl.getContextAttributes().antialias : undefined,
                    MAX_VIEWPORT_DIMS: attempt(() => [...gl.getParameter(gl.MAX_VIEWPORT_DIMS)]),
                    MAX_TEXTURE_MAX_ANISOTROPY_EXT: getMaxAnisotropy(gl),
                    ...getShaderData('VERTEX_SHADER', getShaderPrecisionFormat(gl, 'VERTEX_SHADER')),
                    ...getShaderData('FRAGMENT_SHADER', getShaderPrecisionFormat(gl, 'FRAGMENT_SHADER')),
                    MAX_DRAW_BUFFERS_WEBGL: attempt(() => {
                        const buffers = gl.getExtension('WEBGL_draw_buffers');
                        return buffers ? gl.getParameter(buffers.MAX_DRAW_BUFFERS_WEBGL) : undefined;
                    }),
                },
            },
            parameterOrExtensionLie,
            lied,
        };
        // Firewall
        const brandCapabilities = ['fca66520', 'b62321c3', 'b362c2f5', '0eb2fc19', '55e821f7', '6951838b', '08847ba5', 'c00582e9', '6edf1720', '2b80fd96', '6346cf49', '2259b706', 'e796b84e', '5a5658f1', '58871380', '5a90a5f8', 'cfd20274', '5582debe', 'e4569a5b', 'f2293447', 'c04889b1', '1b251fd7', 'ea59b343', 'b8ea6e7f', '16c481a6', '58fdc720', 'bf06317e', '6294d84e', 'e6464c9f', 'a397a568', '81b9cd29', '1bfd326c', '70859bdb', '70a095b1', '230d6a0d', '3bf321b8', 'c04e374a', 'be2dfaea', 'f9714b3d', '461f97e1', 'd09c1c07', 'a1c808d5', '0b2d4333', '5ddb9237', '39ead506', '802e2547', '49bf7358', 'c026469d', '581f3282', 'f0d5a3c7', '6357365c', 'ae2c4777', '849ccb64', 'e965d541', '794f8929', '2402c3d2', 'e15afab0', '696e1548', 'afa583bc', 'ea54d525', '5ca55292', 'f51cab9a', '087d5759', '8d371161', 'd860ff42', '1453d59a', '12e92e62', 'b504662d', 'cf9643e6', 'dd67b076', 'a581f55e', 'b224cc7c', '2f014c41', '33bc5492', '0fc123c7', 'dbdbe7a4', 'd2172943', '6864dcb0', '3fea1100', 'd913dafa', 'd6bf35ad', 'a26e9aa9', '171831c5', '534002ab', '12f8ac14', '3ff82303', '99b1a1c6', '74daf866', 'fc37fe1f', '6aa1ff7e', 'ec928655', '8428fc8e', 'd8bd9e5a', '8bd0b91b', '52e348ba', 'c2bce496', 'e142d1f9', '2f582ed9', '4065cd69', '66628310', '903c8847', '1ff7c7e7', '402e1064', 'eb799d34', 'ef8f5db1', 'e155c47e', '177cc258', '6f81cbe7', '6b290cd4', 'f1077334', 'd1e76c89', '5d786cef', 'eaa13804', 'fafa14c0', '2c04c2eb', 'c93b5366', '4962ada1', '25a760b8', 'bf610cdb', 'bcf7315f', '801d73af', '00fe1ec9', '0f39d057', 'f8e65486', '3999a5e1', 'ad01a422', 'dc271c35', 'b50edd99', 'e68b5c4e', '82a9a2f1', '0cdb985d', 'a2383001', 'ce2e3d16', 'c9bc4ffd', 'eed2e5e1', 'e10339b3', 'f7451c92', '43038e3d', '8541aa4c', 'fa994f33', 'b2d6fc98', '6a75ae3b', '67995996', '0f840379', 'e574bef6', 'b5494027', '3660b71f', 'a22788f8', 'e16bb1bb', 'e5962ba3', 'c5e9a883', '5ee41456', '3a91d0d6', 'c05f7596', 'ded74044', 'f5d19934', 'c79634c2', '18579e83', '1e8a9a79', '508d1625', 'd05a66eb', '34270469', 'f3c6ea11', '55d3aa56', '7b2e5242', 'e965d180', '258789d0', 'd2dc2474', 'd498797d', 'ea7f90ea', 'a4d34176', 'c04b0635', '02b3eea3', '6b07d4f8', '6c168801', 'ab40bece', 'a4b988da', '4c9e8f5d', '5aea1af1', '795e5c95', '27db292c', '057857ac', '23d1ce20', '917871e7', 'beffda26', '482c81b2', 'c092fdf8', '6248d9e3', 'e316e4c0', 'ade75c4f', '7360ebd1', '300ee927', '5bef9a39', '3740c4c7', '668f0f93', '6dfae3cb', '9b67b7dc', 'de793ead', '149a1efa', '79a57aa9', 'bfe1c212', '62bf7ef1', '25f9385d', '4027d193', 'e9dbb8d5', 'cba1878b', '4503e771', 'cbeade8c', 'c07307c6', 'cefb72ca', '623c3bfd', '00b72507', '8219e1a4', '61d9464e', '7238c5dd', 'b4d40dcc', '0463627d', '5831d5fd', '0586e20b', '467b99a5', 'b10c2a85', 'f221fef5', '7b811cdd', '99ef2c3b', '5b6a17aa', 'a5a477ae', '19594666', '464d51ac', 'a97d3858', '2048bc5a', '6e806ffc', '698c5c2e', '27938830', '66d992e8', 'c7e37ca0', '78640859', '502c402c', 'd970d345', 'ec050bb6', '741688e4', '61178f2a', '9c814c1b', '79284c47', 'd734ea08', '101e0582', 'ea8f5ad0', '61eecaae', 'dcd9a29e', '48af038f', 'bb77a469', '85479b99', '0639a81a', 'df9daeb6', '9fd76352', '3b724916', '2bb488da', 'fe0997b6', '9e2b5e94', 'f33d918e', 'b8961d15', 'a3f9ee34', 'a9640880', 'bc0f9686', '2d15287f', 'aa73f3a4', '00c1b42d'];
        const capabilities = [-2147287810, -2147382251, -2147361769, -2147382272, -2147361792, -2145974612, -2145974598, -2147287834, -2147133749, -2146384027, -2147295822, -2146384003, -1147451901, -2147383246, -2145966545, -2147447137, -1147160553, 349912, -2147429201, -2147459031, -2146384011, -1147464177, -2145966535, -2147440422, -1148326739, 1229835, -2147362760, -2147337003, -2147333118, -2147407821, -2147447161, -2147316383, -2146251641, -1147451883, 999156922, -2146286438, -2146286463, -1147464169, -1147168724, -2147136328, -2147382221, -2147447149, -2147287854, -2130659912, -2146253693, -1148678631, -2147387335, -2147361775, -1147602934, -2147365863, -1147419775, -1962919974, -2147466972, -2145966529, -1164279890, -2147385825, -2147361774, 1147714426, -2147287820, -2147336998, -2147461169, -2147475352, -1148572354, -2146384281, -2147361731, -2147304193, -2147389930, -2147386292, -1962928178, -2147344686, -2147447111, -2147447122, 998804992, -134823971, -2147447873, -2147346747, -2146286583, -2147389951, -2130164388, 184555483, -2147394188, 1610618841, -1332029332, 2147440438, 351513, -2146400384, -2146187766, -1147160399, 1197075, 998911268, -2147295849, -2130164162, -2147385849, -2130164546, -1147765274, -1073719331, -2146417027, -2147365760, 999148597, -1878111124, -677558160, -133757475, -2147128275, -2147453701, -2130172573, -1147419751, -2146526795, -2146236703, -2147410941, -2147415037, -2145974657, -2147306321, -2147378146, -2146237020, -2145966414, -2147453768, -2147291820, -2147470173, -638494755, -1342154787, -2147467172, -2145974489, -1147643759, -2147447892, 83625, -2146232503, -2147295857, -2146253671, -2147316382, -2147429223, -2147390461, -2147291718, -2146526934, -2147447126, -2146384120, 21667, -2145974729, -2147293058, -2146251619, 1099536, -2147142429, -2146379955, -2147365827, -2146400556, -2147295768, -2146251681, -1878102921, -2145974343, 2147475085, -2147394251, -2146232723, -2147400057, -2147414956, -2147439020, -2146319268, -2147406798, -1148680509, -2146277218, 2146590728, -2146400620, -2147414733, -2146376065, -2147387364, -2147386326, -1962893370, -2130164382, -2145933648, -2147447928, -2147448592, -2145974380, -2147133747, -2145941977, -2147407643, -2147447157, -2147300019, 2147479181, -1164800478, -2146232338, -2145974637, -2147453767, -2146401928, -2147365730, -2146384034, -2147475351, -2146232480, -2146236588, -2147447896, -2147295823, -999987216, -2145966441, -2147134974, -1147419753, -2147394484, -16746546, -2146232724, -1148335070, -2146232590, -2146398568, -1164800191, -2147466956, -1147643872, -1148713259, -1147427826, -2147365759, -2147337012, -2145970658, -2147125544, -2147414987, -2147373914, -2147373984, -1147488144, -671082546, -2147361652, -2147374080, -2147287835, -2145974596, 1508998, -2147378041, -2147374032, -2147410938, -2145958228, -2147337022, -2147382130, -2147287811];
        const webglParams = !data.parameters ? undefined : [
            ...new Set(Object.values(data.parameters)
                .filter((val) => val && typeof val != 'string')
                .flat()
                .map((val) => Number(val))),
        ].sort((a, b) => (a - b));
        const gpuBrand = getGpuBrand(data.parameters?.UNMASKED_RENDERER_WEBGL);
        const webglParamsStr = '' + webglParams;
        const webglBrandCapabilities = !gpuBrand || !webglParamsStr ? undefined : hashMini([gpuBrand, webglParamsStr]);
        const webglCapabilities = !webglParams ? undefined : webglParams.reduce((acc, val, i) => acc ^ (+val + i), 0);
        Analysis.webglParams = webglParamsStr;
        Analysis.webglBrandCapabilities = webglBrandCapabilities;
        Analysis.webglCapabilities = webglCapabilities;
        const hasSusGpu = webglBrandCapabilities && !brandCapabilities.includes(webglBrandCapabilities);
        const hasSusCapabilities = webglCapabilities && !capabilities.includes(webglCapabilities);
        if (hasSusGpu) {
            LowerEntropy.WEBGL = true;
            sendToTrash('WebGLRenderingContext.getParameter', 'suspicious gpu');
        }
        if (hasSusCapabilities) {
            LowerEntropy.WEBGL = true;
            sendToTrash('WebGLRenderingContext.getParameter', 'suspicious capabilities');
        }
        logTestResult({ time: timer.stop(), test: 'webgl', passed: true });
        return {
            ...data,
            gpu: {
                ...(getWebGLRendererConfidence((data.parameters || {}).UNMASKED_RENDERER_WEBGL) || {}),
                compressedGPU: compressWebGLRenderer((data.parameters || {}).UNMASKED_RENDERER_WEBGL),
            },
        };
    }
    catch (error) {
        logTestResult({ test: 'webgl', passed: false });
        captureError(error);
        return;
    }
}

function getWindowFeatures() {
    try {
        const timer = createTimer();
        timer.start();
        const win = PHANTOM_DARKNESS || window;
        let keys = Object.getOwnPropertyNames(win)
            .filter((key) => !/_|\d{3,}/.test(key)); // clear out known ddg noise
        // if Firefox, remove the 'Event' key and push to end for consistent order
        // and disregard keys known to be missing in RFP mode
        const firefoxKeyMovedByInspect = 'Event';
        const varyingKeysMissingInRFP = ['PerformanceNavigationTiming', 'Performance'];
        if (IS_GECKO) {
            const index = keys.indexOf(firefoxKeyMovedByInspect);
            if (index != -1) {
                keys = keys.slice(0, index).concat(keys.slice(index + 1));
                keys = [...keys, firefoxKeyMovedByInspect];
            }
            varyingKeysMissingInRFP.forEach((key) => {
                const index = keys.indexOf(key);
                if (index != -1) {
                    keys = keys.slice(0, index).concat(keys.slice(index + 1));
                }
                return keys;
            });
        }
        const moz = keys.filter((key) => (/moz/i).test(key)).length;
        const webkit = keys.filter((key) => (/webkit/i).test(key)).length;
        const apple = keys.filter((key) => (/apple/i).test(key)).length;
        const data = { keys, apple, moz, webkit };
        logTestResult({ time: timer.stop(), test: 'window', passed: true });
        return { ...data };
    }
    catch (error) {
        logTestResult({ test: 'window', passed: false });
        captureError(error);
        return;
    }
}

/* eslint-disable linebreak-style */
const voodoo = async function () {
    const scope = await spawnWorker();
    if (scope == 0 /* Scope.WORKER */) {
        return;
    }
    await queueTask();
    getStackBytes();
    await exile();
    const isBrave = IS_BLINK ? await braveBrowser() : false;
    const braveMode = isBrave ? getBraveMode() : {};
    const braveFingerprintingBlocking = isBrave && (braveMode.standard || braveMode.strict);
    const fingerprint = async () => {
        const timeStart = timer();
        const fingerprintTimeStart = timer();
        // @ts-ignore
        const [workerScopeComputed, voicesComputed, offlineAudioContextComputed, canvasWebglComputed, canvas2dComputed, windowFeaturesComputed, htmlElementVersionComputed, cssComputed, cssMediaComputed, screenComputed, mathsComputed, consoleErrorsComputed, timezoneComputed, clientRectsComputed, fontsComputed, mediaComputed, svgComputed, resistanceComputed, intlComputed,] = await Promise.all([
            getBestWorkerScope(),
            getVoices(),
            getOfflineAudioContext(),
            getCanvasWebgl(),
            getCanvas2d(),
            getWindowFeatures(),
            getHTMLElementVersion(),
            getCSS(),
            getCSSMedia(),
            getScreen(),
            getMaths(),
            getConsoleErrors(),
            getTimezone(),
            getClientRects(),
            getFonts(),
            getMedia(),
            getSVG(),
            getResistance(),
            getIntl(),
        ]).catch((error) => console.error(error.message));
        const navigatorComputed = await getNavigator(workerScopeComputed)
            .catch((error) => console.error(error.message));
        // @ts-ignore
        const [headlessComputed, featuresComputed,] = await Promise.all([
            getHeadlessFeatures({
                webgl: canvasWebglComputed,
                workerScope: workerScopeComputed,
            }),
            getEngineFeatures({
                cssComputed,
                navigatorComputed,
                windowFeaturesComputed,
            }),
        ]).catch((error) => console.error(error.message));
        // @ts-ignore
        const [liesComputed, trashComputed, capturedErrorsComputed,] = await Promise.all([
            getLies(),
            getTrash(),
            getCapturedErrors(),
        ]).catch((error) => console.error(error.message));
        fingerprintTimeStart();
        // GPU Prediction
        const { parameters: gpuParameter } = canvasWebglComputed || {};
        const reducedGPUParameters = {
            ...(braveFingerprintingBlocking ? getBraveUnprotectedParameters(gpuParameter) :
                gpuParameter),
            RENDERER: undefined,
            SHADING_LANGUAGE_VERSION: undefined,
            UNMASKED_RENDERER_WEBGL: undefined,
            UNMASKED_VENDOR_WEBGL: undefined,
            VERSION: undefined,
            VENDOR: undefined,
        };
        // Hashing
        const hashStartTime = timer();
        // @ts-ignore
        const [windowHash, headlessHash, htmlHash, cssMediaHash, cssHash, styleHash, styleSystemHash, screenHash, voicesHash, canvas2dHash, canvas2dImageHash, canvas2dPaintHash, canvas2dTextHash, canvas2dEmojiHash, canvasWebglHash, canvasWebglImageHash, canvasWebglParametersHash, pixelsHash, pixels2Hash, mathsHash, consoleErrorsHash, timezoneHash, rectsHash, domRectHash, audioHash, fontsHash, workerHash, mediaHash, mimeTypesHash, navigatorHash, liesHash, trashHash, errorsHash, svgHash, resistanceHash, intlHash, featuresHash, deviceOfTimezoneHash,] = await Promise.all([
            hashify(windowFeaturesComputed),
            hashify(headlessComputed),
            hashify((htmlElementVersionComputed || {}).keys),
            hashify(cssMediaComputed),
            hashify(cssComputed),
            hashify((cssComputed || {}).computedStyle),
            hashify((cssComputed || {}).system),
            hashify(screenComputed),
            hashify(voicesComputed),
            hashify(canvas2dComputed),
            hashify((canvas2dComputed || {}).dataURI),
            hashify((canvas2dComputed || {}).paintURI),
            hashify((canvas2dComputed || {}).textURI),
            hashify((canvas2dComputed || {}).emojiURI),
            hashify(canvasWebglComputed),
            hashify((canvasWebglComputed || {}).dataURI),
            hashify(reducedGPUParameters),
            ((canvasWebglComputed || {}).pixels || []).length ? hashify(canvasWebglComputed.pixels) : undefined,
            ((canvasWebglComputed || {}).pixels2 || []).length ? hashify(canvasWebglComputed.pixels2) : undefined,
            hashify((mathsComputed || {}).data),
            hashify((consoleErrorsComputed || {}).errors),
            hashify(timezoneComputed),
            hashify(clientRectsComputed),
            hashify([
                (clientRectsComputed || {}).elementBoundingClientRect,
                (clientRectsComputed || {}).elementClientRects,
                (clientRectsComputed || {}).rangeBoundingClientRect,
                (clientRectsComputed || {}).rangeClientRects,
            ]),
            hashify(offlineAudioContextComputed),
            hashify(fontsComputed),
            hashify(workerScopeComputed),
            hashify(mediaComputed),
            hashify((mediaComputed || {}).mimeTypes),
            hashify(navigatorComputed),
            hashify(liesComputed),
            hashify(trashComputed),
            hashify(capturedErrorsComputed),
            hashify(svgComputed),
            hashify(resistanceComputed),
            hashify(intlComputed),
            hashify(featuresComputed),
            hashify((() => {
                const { bluetoothAvailability, device, deviceMemory, hardwareConcurrency, maxTouchPoints, oscpu, platform, system, userAgentData, } = navigatorComputed || {};
                const { architecture, bitness, mobile, model, platform: uaPlatform, platformVersion, } = userAgentData || {};
                const { anyPointer } = cssMediaComputed || {};
                const { colorDepth, pixelDepth, height, width } = screenComputed || {};
                const { location, locationEpoch, zone } = timezoneComputed || {};
                const { deviceMemory: deviceMemoryWorker, hardwareConcurrency: hardwareConcurrencyWorker, gpu, platform: platformWorker, system: systemWorker, timezoneLocation: locationWorker, userAgentData: userAgentDataWorker, } = workerScopeComputed || {};
                const { compressedGPU, confidence } = gpu || {};
                const { architecture: architectureWorker, bitness: bitnessWorker, mobile: mobileWorker, model: modelWorker, platform: uaPlatformWorker, platformVersion: platformVersionWorker, } = userAgentDataWorker || {};
                return [
                    anyPointer,
                    architecture,
                    architectureWorker,
                    bitness,
                    bitnessWorker,
                    bluetoothAvailability,
                    colorDepth,
                    ...(compressedGPU && confidence != 'low' ? [compressedGPU] : []),
                    device,
                    deviceMemory,
                    deviceMemoryWorker,
                    hardwareConcurrency,
                    hardwareConcurrencyWorker,
                    height,
                    location,
                    locationWorker,
                    locationEpoch,
                    maxTouchPoints,
                    mobile,
                    mobileWorker,
                    model,
                    modelWorker,
                    oscpu,
                    pixelDepth,
                    platform,
                    platformWorker,
                    platformVersion,
                    platformVersionWorker,
                    system,
                    systemWorker,
                    uaPlatform,
                    uaPlatformWorker,
                    width,
                    zone,
                ];
            })()),
        ]).catch((error) => console.error(error.message));
        hashStartTime();
        const timeEnd = timeStart();
        if (PARENT_PHANTOM) {
            // @ts-ignore
            PARENT_PHANTOM.parentNode.removeChild(PARENT_PHANTOM);
        }
        const fingerprint = {
            workerScope: !workerScopeComputed ? undefined : { ...workerScopeComputed, $hash: workerHash },
            navigator: !navigatorComputed ? undefined : { ...navigatorComputed, $hash: navigatorHash },
            windowFeatures: !windowFeaturesComputed ? undefined : { ...windowFeaturesComputed, $hash: windowHash },
            headless: !headlessComputed ? undefined : { ...headlessComputed, $hash: headlessHash },
            htmlElementVersion: !htmlElementVersionComputed ? undefined : { ...htmlElementVersionComputed, $hash: htmlHash },
            cssMedia: !cssMediaComputed ? undefined : { ...cssMediaComputed, $hash: cssMediaHash },
            css: !cssComputed ? undefined : { ...cssComputed, $hash: cssHash },
            screen: !screenComputed ? undefined : { ...screenComputed, $hash: screenHash },
            voices: !voicesComputed ? undefined : { ...voicesComputed, $hash: voicesHash },
            media: !mediaComputed ? undefined : { ...mediaComputed, $hash: mediaHash },
            canvas2d: !canvas2dComputed ? undefined : { ...canvas2dComputed, $hash: canvas2dHash },
            canvasWebgl: !canvasWebglComputed ? undefined : { ...canvasWebglComputed, pixels: pixelsHash, pixels2: pixels2Hash, $hash: canvasWebglHash },
            maths: !mathsComputed ? undefined : { ...mathsComputed, $hash: mathsHash },
            consoleErrors: !consoleErrorsComputed ? undefined : { ...consoleErrorsComputed, $hash: consoleErrorsHash },
            timezone: !timezoneComputed ? undefined : { ...timezoneComputed, $hash: timezoneHash },
            clientRects: !clientRectsComputed ? undefined : { ...clientRectsComputed, $hash: rectsHash },
            offlineAudioContext: !offlineAudioContextComputed ? undefined : { ...offlineAudioContextComputed, $hash: audioHash },
            fonts: !fontsComputed ? undefined : { ...fontsComputed, $hash: fontsHash },
            lies: !liesComputed ? undefined : { ...liesComputed, $hash: liesHash },
            trash: !trashComputed ? undefined : { ...trashComputed, $hash: trashHash },
            capturedErrors: !capturedErrorsComputed ? undefined : { ...capturedErrorsComputed, $hash: errorsHash },
            svg: !svgComputed ? undefined : { ...svgComputed, $hash: svgHash },
            resistance: !resistanceComputed ? undefined : { ...resistanceComputed, $hash: resistanceHash },
            intl: !intlComputed ? undefined : { ...intlComputed, $hash: intlHash },
            features: !featuresComputed ? undefined : { ...featuresComputed, $hash: featuresHash },
        };
        return {
            fingerprint,
            styleSystemHash,
            styleHash,
            domRectHash,
            mimeTypesHash,
            canvas2dImageHash,
            canvasWebglImageHash,
            canvas2dPaintHash,
            canvas2dTextHash,
            canvas2dEmojiHash,
            canvasWebglParametersHash,
            deviceOfTimezoneHash,
            timeEnd,
        };
    };
    // fingerprint and render
    const { fingerprint: fp, styleSystemHash, styleHash, domRectHash, mimeTypesHash, canvas2dImageHash, canvas2dPaintHash, canvas2dTextHash, canvas2dEmojiHash, canvasWebglImageHash, canvasWebglParametersHash, deviceOfTimezoneHash, timeEnd, } = await fingerprint().catch((error) => console.error(error)) || {};
    if (!fp) {
        throw new Error('Fingerprint failed!');
    }
    +(fp.canvas2d?.textMetricsSystemSum) || 0;
    // Trusted Fingerprint
    fp.trash.trashBin.length;
    !('totalLies' in fp.lies) ? 0 : fp.lies.totalLies;
    fp.capturedErrors.data.length;
    const hardenEntropy = (workerScope, prop) => {
        return (!workerScope ? prop :
            (workerScope.localeEntropyIsTrusty && workerScope.localeIntlEntropyIsTrusty) ? prop :
                undefined);
    };
    const privacyResistFingerprinting = (fp.resistance && /^(tor browser|firefox)$/i.test(fp.resistance.privacy));
    // harden gpu
    const hardenGPU = (canvasWebgl) => {
        const { gpu: { confidence, compressedGPU } } = canvasWebgl;
        return (confidence == 'low' ? {} : {
            UNMASKED_RENDERER_WEBGL: compressedGPU,
            UNMASKED_VENDOR_WEBGL: canvasWebgl.parameters.UNMASKED_VENDOR_WEBGL,
        });
    };
    const creep = {
        navigator: (!fp.navigator || fp.navigator.lied ? undefined : {
            bluetoothAvailability: fp.navigator.bluetoothAvailability,
            device: fp.navigator.device,
            deviceMemory: fp.navigator.deviceMemory,
            hardwareConcurrency: fp.navigator.hardwareConcurrency,
            maxTouchPoints: fp.navigator.maxTouchPoints,
            oscpu: fp.navigator.oscpu,
            platform: fp.navigator.platform,
            system: fp.navigator.system,
            userAgentData: {
                ...(fp.navigator.userAgentData || {}),
                // loose
                brandsVersion: undefined,
                uaFullVersion: undefined,
            },
            vendor: fp.navigator.vendor,
        }),
        screen: (!fp.screen || fp.screen.lied || privacyResistFingerprinting || LowerEntropy.SCREEN ? undefined :
            hardenEntropy(fp.workerScope, {
                height: fp.screen.height,
                width: fp.screen.width,
                pixelDepth: fp.screen.pixelDepth,
                colorDepth: fp.screen.colorDepth,
                lied: fp.screen.lied,
            })),
        workerScope: !fp.workerScope || fp.workerScope.lied ? undefined : {
            deviceMemory: (braveFingerprintingBlocking ? undefined : fp.workerScope.deviceMemory),
            hardwareConcurrency: (braveFingerprintingBlocking ? undefined : fp.workerScope.hardwareConcurrency),
            // system locale in blink
            language: !LowerEntropy.TIME_ZONE ? fp.workerScope.language : undefined,
            platform: fp.workerScope.platform,
            system: fp.workerScope.system,
            device: fp.workerScope.device,
            timezoneLocation: (!LowerEntropy.TIME_ZONE ?
                hardenEntropy(fp.workerScope, fp.workerScope.timezoneLocation) :
                undefined),
            webglRenderer: ((fp.workerScope.gpu.confidence != 'low') ? fp.workerScope.gpu.compressedGPU : undefined),
            webglVendor: ((fp.workerScope.gpu.confidence != 'low') ? fp.workerScope.webglVendor : undefined),
            userAgentData: {
                ...fp.workerScope.userAgentData,
                // loose
                brandsVersion: undefined,
                uaFullVersion: undefined,
            },
        },
        media: fp.media,
        canvas2d: ((canvas2d) => {
            if (!canvas2d) {
                return;
            }
            const { lied, liedTextMetrics } = canvas2d;
            let data;
            if (!lied) {
                const { dataURI, paintURI, textURI, emojiURI } = canvas2d;
                data = {
                    lied,
                    ...{ dataURI, paintURI, textURI, emojiURI },
                };
            }
            if (!liedTextMetrics) {
                const { textMetricsSystemSum, emojiSet } = canvas2d;
                data = {
                    ...(data || {}),
                    ...{ textMetricsSystemSum, emojiSet },
                };
            }
            return data;
        })(fp.canvas2d),
        canvasWebgl: (!fp.canvasWebgl || fp.canvasWebgl.lied || LowerEntropy.WEBGL) ? undefined : (braveFingerprintingBlocking ? {
            parameters: {
                ...getBraveUnprotectedParameters(fp.canvasWebgl.parameters),
                ...hardenGPU(fp.canvasWebgl),
            },
        } : {
            ...((gl, canvas2d) => {
                if ((canvas2d && canvas2d.lied) || LowerEntropy.CANVAS) {
                    // distrust images
                    const { extensions, gpu, lied, parameterOrExtensionLie } = gl;
                    return {
                        extensions,
                        gpu,
                        lied,
                        parameterOrExtensionLie,
                    };
                }
                return gl;
            })(fp.canvasWebgl, fp.canvas2d),
            parameters: {
                ...fp.canvasWebgl.parameters,
                ...hardenGPU(fp.canvasWebgl),
            },
        }),
        cssMedia: !fp.cssMedia ? undefined : {
            reducedMotion: caniuse(() => fp.cssMedia.mediaCSS['prefers-reduced-motion']),
            colorScheme: (braveFingerprintingBlocking ? undefined :
                caniuse(() => fp.cssMedia.mediaCSS['prefers-color-scheme'])),
            monochrome: caniuse(() => fp.cssMedia.mediaCSS.monochrome),
            invertedColors: caniuse(() => fp.cssMedia.mediaCSS['inverted-colors']),
            forcedColors: caniuse(() => fp.cssMedia.mediaCSS['forced-colors']),
            anyHover: caniuse(() => fp.cssMedia.mediaCSS['any-hover']),
            hover: caniuse(() => fp.cssMedia.mediaCSS.hover),
            anyPointer: caniuse(() => fp.cssMedia.mediaCSS['any-pointer']),
            pointer: caniuse(() => fp.cssMedia.mediaCSS.pointer),
            colorGamut: caniuse(() => fp.cssMedia.mediaCSS['color-gamut']),
            screenQuery: (privacyResistFingerprinting || (LowerEntropy.SCREEN || LowerEntropy.IFRAME_SCREEN) ?
                undefined :
                hardenEntropy(fp.workerScope, caniuse(() => fp.cssMedia.screenQuery))),
        },
        css: !fp.css ? undefined : fp.css.system.fonts,
        timezone: !fp.timezone || fp.timezone.lied || LowerEntropy.TIME_ZONE ? undefined : {
            locationMeasured: hardenEntropy(fp.workerScope, fp.timezone.locationMeasured),
            lied: fp.timezone.lied,
        },
        offlineAudioContext: !fp.offlineAudioContext ? undefined : (fp.offlineAudioContext.lied || LowerEntropy.AUDIO ? undefined :
            fp.offlineAudioContext),
        fonts: !fp.fonts || fp.fonts.lied || LowerEntropy.FONTS ? undefined : fp.fonts.fontFaceLoadFonts,
        forceRenew: 1672005503901,
    };
    delete creep.cssMedia.screenQuery;
    delete creep.screen;
    let proxyNavigatorUsed;
    try {
        proxyNavigatorUsed = Reflect.setPrototypeOf(navigator, Object.create(navigator));
    }
    catch (e) {
        proxyNavigatorUsed = true;
    }
    if (proxyNavigatorUsed) {
        fp.headless.headless.webDriverIsOn = true;
    }
    const [fpHash, creepHash] = await Promise.all([hashify(fp), hashify(creep)])
        .catch((error) => {
        console.error(error.message);
    }) || [];
    return { fpHash, creepHash, fp, creep };
};

export { voodoo };
//# sourceMappingURL=index.mjs.map

        